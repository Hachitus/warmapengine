<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">core/Map.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/Map.js~Map.html">Map</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/Map_layers.js~Map_layer.html">Map_layer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/Map_layers.js~Map_parentLayer.html">Map_parentLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/ObjectManager.js~ObjectManager.html">ObjectManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/Objects.js~Object_sprite.html">Object_sprite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/Objects.js~Object_sprite_terrain.html">Object_sprite_terrain</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/Objects.js~Object_sprite_unit.html">Object_sprite_unit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/UI_themeBase.js~UI_templateBase.html">UI_templateBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-UI">UI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-mapEvents">mapEvents</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">move</div><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-map_drag">map_drag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pluginName">pluginName</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/core/utils/Quadtree.js~Quadtree.html">Quadtree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataManipulation">dataManipulation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-effects">effects</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-utils">utils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-environmentDetection">environmentDetection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-general">general</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-mouse">mouse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-resize">resize</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">zoom</div><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-map_zoom">map_zoom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pluginName">pluginName</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">core/Map.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* global System, Q */

&apos;use strict&apos;;

/***********************
******** IMPORT ********
***********************/
import { Map_layer, Map_parentLayer, eventListeners, ObjectManager, mapEvents, utils } from &apos;/components/bundles/coreBundle&apos;;
import * as Q from &apos;/assets/lib/q/q&apos;;

/***********************
****** VARIABLES *******
***********************/
var _drawMapOnNextTick = false;
var isMapReadyPromises = [];
var eventlisteners, _staticLayer, _movableLayer, _renderer, boundResizer, ParentLayerConstructor;

/***********************
********* API **********
***********************/
/**
 * Main class for the whole engine, which initializes the whole structure and plugins
 *
 * You use the class by instantiating it with new and then initialize with init-method:
 * var map = new Map(canvasElement, mapOptions );
 * promises = map.init( gameData.pluginsToActivate, mapData.startPoint );
 *
 * Plugins can be added with activatePlugins-method by prodiving init(map) method in the plugin. Plugins are always
 * functions, not objects that are instantiated. Plugins are supposed to extend the map object or anything in it via
 * it&apos;s public methods.
 *
 * @requires PIXI.JS framework in global namespace
 * @requires canvas (webGL support recommended) HTML5-element supported.
 * @requires Hammer for touch events
 * @requires Hamster for mouse scroll events
 *
 * @requires Plugins that use eventlistener by default, use pointer events polyfill, such as: https://github.com/jquery/PEP
 * Plugins and eventlistener can be overriden, but they user pointer events by default (either the browser must support
 * them or use polyfill)
 **/
export class Map {
  /**
   * @class Map
   * @constructor
   * @param {HTML element} canvasContainer                          HTML element which will be container for the created canvas element
   * @param {Object} props                                           Extra properties
   * @param {{x: Integer, y: Integer}} props.startCoord              Coordinates where the map starts at
   * @param {{width: Integer, height: Integer}} props.bounds         Bounds of the map / mapSize
   * @param {Object} props.rendererOptions                           Renderer options passed to PIXI.autoDetectRenderer
   * @param {{width: Integer, height: Integer}} props.subContainers  Subcontainers size in pixels. If given, will activate subcontainers. If not given or false, subcontainers are not used.area.
   * @param {function(FPS: Number, FPStime: Number, renderTime: Number, drawCount: Number): void} trackFPSCB                                   Callback function for tracking FPS in renderer. So this is used for debugging and optimizing.
   *
   *
   * @return {Map}                                            new Map instance
   */
  constructor(canvasContainer = null,
      props = {
        startCoord: { x: 0, y: 0 },
        bounds: { width: 0, height: 0 },
        rendererOptions: { refreshEventListeners: true },
        subContainers: false,
        trackFPSCB: false }) {
    var { startCoord, bounds, rendererOptions, subContainers, trackFPSCB } = props;

    if (!canvasContainer) {
      throw new Error(this.constructor.name + &quot; needs canvasContainer!&quot;);
    }

    if (typeof canvasContainer === &quot;string&quot;) {
      canvasContainer = document.querySelector(canvasContainer);
    }

    _renderer = PIXI.autoDetectRenderer(bounds.width, bounds.height, rendererOptions);
    /* We handle all the events ourselves through addEventListeners-method on canvas, so destroy pixi native method */
    _renderer.plugins.interaction.destroy();
    canvasContainer.innerHTML = &quot;&quot;;
    canvasContainer.appendChild(_renderer.view, canvasContainer);
    let interactionManager = new PIXI.interaction.InteractionManager(_renderer);

    /* This defines which class we use to generate layer on the map. Under movableLayer */
    ParentLayerConstructor = subContainers ? Map_parentLayer : Map_layer;

    /* These are the 2 topmost layers on the map:
     * - staticLayer: Keeps at the same coordinates always and is responsible for holding map scale value and possible
     * objects that do not move with the map.
     * - movableLayer: Moves the map, when the user commands. Can hold e.g. UI objects that move with the map. Like
     * graphics that show which area or object is currently selected. */
    _staticLayer = new Map_layer({ name:&quot;staticLayer&quot;, coord: { x: 0, y: 0 } });
    _movableLayer = new Map_layer({ name:&quot;movableLayer&quot;, coord: startCoord });
    _staticLayer.addChild(_movableLayer);

    /* InteractionManager is responsible for finding what objects are under certain coordinates. E.g. when selecting */
    eventlisteners = eventListeners(this.canvas, true);

    /* needed for fullsize canvas in PIXI */
    _renderer.view.style.position = &quot;absolute&quot;;
    _renderer.view.style.display = &quot;block&quot;;
    /* stop scrollbars of showing */
    document.getElementsByTagName(&quot;body&quot;)[0].style.overflow = &quot;hidden&quot;;
    _renderer.view.style.left = &quot;0px&quot;;
    _renderer.view.style.top = &quot;0px&quot;;

    /**
     * canvas element that was generated and is being used by this new generated Map instance.
     *
     * @type {Canvas element}
     */
    this.canvas = _renderer.view;
    /**
     * list of plugins that the map uses and are initialized
     * @see class/core/Map.js~Map.html#instance-method-activatePlugins
     *
     * @type {Set}
     */
    this.plugins = new Set();
    /**
     * Subcontainers size that we want to generate, when layers use subcontainers
     *
     * @type {{width: Integer, height: Int}}
     */
    this.subContainersConfig = subContainers;
    /**
     * Callback function that gets the current FPS on the map and shows it in DOM
     *
     * @type {Function}
     */
    this.trackFPSCB = trackFPSCB;
    /**
     * ObjectManager instance. Responsible for retrieving the objects from the map, on desired occasions. Like when the player clicks the map to select some object.
     *
     * @type {ObjectManager}
     */
    this.objectManager = new ObjectManager(interactionManager); // Fill this with quadtrees or such

    /* PRIVATE */
    this._mapInMove = false;
  }
  /**
   * initialization method
   *
   * @method init
   * @param {Array of Strings} plugins    Plugins to be activated for the map. Normally you should give the plugins here
   * instead of separately passing them to activatePlugins method. You can provide the module strings or module objects.
   * @param {x: ? y:?} coord              Starting coordinates for the map
   * @param {Function} tickCB             callback function for tick. Tick callback is initiated in every frame. So map draws happen during ticks
   * @param {Object} options              Fullsize: Do we set fullsize canvas or not.
   * @return {Array}                      Returns an array of Promises. If this is empty / zero. Then there is nothing to wait for, if it contains promises, you have to wait for them to finish for the plugins to work and map be ready.
   * */
  init(plugins = [], coord = { x: 0, y: 0 }, tickCB = null, options = { fullsize: true }) {
    var allPromises = [];

    options.fullsize &amp;&amp; this.toggleFullsize();

    if (plugins.length &amp;&amp; typeof plugins[0] === &quot;object&quot;) {
      this.activatePlugins(plugins);
    } else if (plugins.length &amp;&amp; typeof plugins[0] === &quot;string&quot;) {
      plugins.map(plugin =&gt; {
        let thisPromise;

        thisPromise = System.import(plugin).then( (plugin) =&gt; {
          this.activatePlugin(plugin);
        });

        allPromises.push(thisPromise);
      });
    }

    coord &amp;&amp; Object.assign(_movableLayer, coord);

    this.drawOnNextTick();
    _defaultTick(this, PIXI.ticker.shared);
    tickCB &amp;&amp; this.customTickOn(tickCB);

    isMapReadyPromises = allPromises;

    return allPromises;
  }
  /**
   * The correct way to update / redraw the map. Check happens at every tick and thus in every frame.
   * @return the current map instance
   * */
  whenReady() {
    return Q.all(isMapReadyPromises);
  }
  /**
   * The correct way to update / redraw the map. Check happens at every tick and thus in every frame.
   * @return the current map instance
   * */
  drawOnNextTick() {
    _drawMapOnNextTick = true;

    return this;
  }
  /**
   * The correct way to update / redraw the map. Check happens at every tick and thus in every frame.
   * @return the current map instance
   * */
  getLayersWithAttributes(attribute, value) {
    return _staticLayer.children[0].children.filter(layer =&gt; {
      return layer[attribute] === value;
    });
  }
  createUILayer(name = &quot;default UI layer&quot;, coord = { x: 0, y: 0 }) {
    var layer = new Map_layer(name, coord);

    return layer;
  }
  /**
   * All parameters are passed to Map_layer constructor
   * @return created Map_layer instance
   * */
  addLayer(layerOptions) {
    var thisLayer;

    if (this.getSubContainerConfigs() &amp;&amp; layerOptions.subContainers !== false) {
      layerOptions.subContainers = this.getSubContainerConfigs();
    }

    thisLayer = new ParentLayerConstructor(layerOptions);
    _movableLayer.addChild(thisLayer);

    return thisLayer;
  }
  /**
   * Does the map use subContainers
   */
  usesSubContainers() {
    return this.subContainersConfig ? true : false;
  }
  getSubContainerConfigs() {
    return this.subContainersConfig;
  }
  /**
   * Get the size of area that is shown to the player. Depends a bit if we want to show the maximum possible or current.
   *
   * @param  {Boolean} isLocal       Do we want to use moving layer or static (global) coordinates
   * @return {Object}                x- and y-coordinates and the width and height of the viewport
   */
  getViewportArea(isLocal = false) {
    var layer = isLocal ? this.getMovableLayer() : this.getStaticLayer();

    return {
      x: layer.x,
      y: layer.y,
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
  /**
   * @param {Map_layer} layer - the layer object to be removed
   * */
  removeLayer(layer) {
    _movableLayer.removeChild(layer);

    return layer;
  }
  /**
   * @return layer with the passed layer name
   * */
  getLayerNamed(name) {
    return _movableLayer.getChildNamed(name);
  }
  /**
   * Moves the map the amount of given x and y pixels. Note that this is not the destination coordinate, but the amount of movement that the map should move. Internally it moves the movableLayer, taking into account necessary properties (like scale).
   *
   * @param {{x: Number, y: Number}} coord      The amount of x and y coordinates we want the map to move. I.e. { x: 5, y: 0 }. With this we want the map to move horizontally 5 pixels and vertically stay at the same position.
   * @param {Object} informCoordinates          THIS IS EXPERIMENTAL, TO FIX THE INCORRECT EVENT COORDINATES THIS SEND TO mapEvents, WHEN SCALING
   **/
  moveMap(coord = { x: 0, y: 0 }, informCoordinates = coord) {
    var realCoordinates = {
      x: Math.round(coord.x / _staticLayer.getScale()),
      y: Math.round(coord.y / _staticLayer.getScale())
    };
    _movableLayer.move(realCoordinates);
    mapEvents.publish(&quot;mapMoved&quot;, informCoordinates || realCoordinates);
    this.drawOnNextTick();

    return this;
  }
  /**
   * Cache the map. This provides significant performance boost, when used correctly. cacheMap iterates through all the
   * layer on the map and caches the ones that return true from getCacheEnabled-method.
   **/
  cacheMap() {
    _movableLayer.children.forEach(child =&gt; {
      child.setCache(child.getCacheEnabled());
    });

    return this;
  }
  /**
   * unCache the map.
   *
   * @return this map instance
   * */
  unCacheMap() {
    _movableLayer.children.forEach(child =&gt; {
      child.setCache(false);
    });

    return this;
  }
  /**
   * Activate plugins for the map. Plugins need .pluginName property and .init-method
   *
   * @param {Object[]} pluginsArray         Array that consists the plugin modules to be activated
   * */
  activatePlugins(pluginsArray = []) {
    pluginsArray.forEach(plugin =&gt; {
      this.activatePlugin(plugin);
    });

    return this;
  }
  /**
   * Activate plugins for the map. Plugins need .pluginName property and .init-method
   *
   * @param {Object} plugin        Plugin module instance.
   * */
  activatePlugin(plugin) {
    try {
      if (!plugin || !plugin.pluginName) {
        throw new Error(&quot;plugin or plugin.pluginName missing&quot;);
      }

      if (this.plugins.add(plugin[plugin.pluginName])) {
        plugin[plugin.pluginName].init(this);
      }
    } catch (e) {
      console.log(&quot;An error initializing plugin &quot; + plugin ? plugin.pluginName : &quot;no plugin name&quot;, e);
    }
  }
  /**
   * getter and setter for detecting if map is moved and setting the maps status as moved or not moved
   *
   * @param {Boolean} yesOrNo         Has the map moved, or not.
   * @param {Boolean} isFinal         Is this the last time map has been moved with this event chain.
   * */
  mapMoved(yesOrNo, isFinal) {
    isFinal &amp;&amp; mapEvents.publish(&quot;mapMovedFinal&quot;);

    if (yesOrNo !== undefined) {
      this._mapInMove = yesOrNo;
      return yesOrNo;
    }

    return this._mapInMove;
  }
  setPrototype(property, value) {
    var thisPrototype = Object.getPrototypeOf(this);

    thisPrototype[property] = value;
  }
  /**
   * Resize the canvas to fill the whole browser area. Uses this.eventCBs.fullsize as callback, so when you need to overwrite
   * the eventlistener callback use this.eventCBs
   */
  toggleFullsize() {
    if (!boundResizer) {
      boundResizer = _resizeCanvas.bind(this);
    }

    mapEvents.publish(&quot;mapResized&quot;);

    return eventlisteners.toggleFullSizeListener(boundResizer);
  }
  /**
   * Toggles fullscreen mode. Uses this.eventCBs.fullscreen as callback, so when you need to overwrite
   * the eventlistener callback use this.eventCBs
   * */
  toggleFullScreen () {
    var eventListenerCB = setFullScreen.bind(this);

    eventlisteners.toggleFullscreen(eventListenerCB);
  }
  getSubcontainersUnderPoint(globalCoords) {
    var primaryLayers = this.getMovableLayer().getPrimaryLayers();
    var allMatchingSubcontainers = [];
    var allCoords = {
      globalCoords: globalCoords,
      localCoords: this.getMovableLayer().toLocal(new PIXI.Point(globalCoords.x, globalCoords.y))
    };
    var thisLayersSubcontainers;

    allCoords.localCoords.width = globalCoords.width;
    allCoords.localCoords.height = globalCoords.height;

    primaryLayers.forEach(layer =&gt; {
      thisLayersSubcontainers = layer.getSubContainersByCoordinates(allCoords.localCoords);
      allMatchingSubcontainers = allMatchingSubcontainers.concat(thisLayersSubcontainers);
    });

    return allMatchingSubcontainers;
  }
  /**
   * Filter objects based on quadtree and then based on possible group provided
   *
   * @param  {x: Number, y: Number} globalCoords      The global coordinates on canvas, that is hitTested.
   * @param  {String} type                            Type of the objects / layer to find.
   * @return {Array}                                  Array of object found on the map.
   */
  getObjectsUnderPoint(globalCoords = { x: 0, y: 0, width: 0, height: 0 }, type = undefined) {
    var objects = {};
    var allCoords = {
      globalCoords: globalCoords,
      localCoords: this.getMovableLayer().toLocal(new PIXI.Point(globalCoords.x, globalCoords.y))
    };
    // allCoords.localCoords.width = globalCoords.width;
    // allCoords.localCoords.height = globalCoords.height;

    if (this.usesSubContainers()) {
      let allMatchingSubcontainers = [];
      let thisLayersSubcontainers = [];
      let primaryLayers = this.getMovableLayer().getPrimaryLayers();

      primaryLayers.forEach(layer =&gt; {
        thisLayersSubcontainers = layer.getSubContainersByCoordinates(allCoords.globalCoords);
        allMatchingSubcontainers = allMatchingSubcontainers.concat(thisLayersSubcontainers);
      });

      if (type) {
        objects[type] = this.objectManager.retrieve(allCoords, type, {
          subcontainers: allMatchingSubcontainers,
          size: {
            width: globalCoords.width,
            height: globalCoords.height
          }
        });
      } else {
        objects = this.objectManager.retrieve(allCoords, type, {
          subcontainers: allMatchingSubcontainers,
          size: {
            width: globalCoords.width,
            height: globalCoords.height
          }
        });
      }
    } else {
      if (type) {
        objects[type] = this.objectManager.retrieve(allCoords, type, {
            quadtree: true,
            size: {
              width: globalCoords.width,
              height: globalCoords.height
            }
          });
      } else {
        objects = this.objectManager.retrieve(allCoords, type, {
          quadtree: true,
          size: {
            width: globalCoords.width,
            height: globalCoords.height
          }
        });
      }
    }

    return objects;
  }
  /**
   * @return { x: Number, y: Number }, current coordinates for the moved map
   * */
  getMapPosition() {
    return {
      x: _movableLayer.x,
      y: _movableLayer.y
    };
  }
  getCanvas() {
    return this.canvas;
  }
  getZoomLayer() {
    return _staticLayer;
  }
  setScale(scale) {
    return _staticLayer.setScale(scale);
  }
  getScale() {
    return _staticLayer.getScale();
  }
  getUILayer() {
    return _staticLayer;
  }
  getMovableLayer() {
    return _movableLayer;
  }
  getRenderer() {
    return _renderer;
  }
  getStage() {
    return _staticLayer;
  }
  getStaticLayer() {
    return _staticLayer;
  }
  /*************************************
   ******* APIS THROUGH PLUGINS ********
   ************************************/
  zoomIn() { return &quot;notImplementedYet. Activate with plugin&quot;; }
  zoomOut() { return &quot;notImplementedYet. Activate with plugin&quot;; }
  /*
   * Selection of objects on the map. For more efficient solution, we implement these APIs thorugh plugin.
   * Default uses quadtree
   * @param { x: Number, y: Number } coordinates to search from
   * @param { String } type type of the objects to search for
   * @param { String } object The object to add
   * */
  addObjectsForSelection() { return &quot;notImplementedYet&quot;; }
  /*
   * Selection of objects on the map. For more efficient solution, we implement these APIs thorugh plugin.
   * Default uses quadtree
   *
   * @param {{x: Number, y: Number }} coordinates to search from
   * @param { String } type type of the objects to search for
   * @param { String } object The object to add
   * */
  removeObjectsForSelection() { return &quot;notImplementedYet&quot;; }
  /*
   * Selection of objects on the map. For more efficient solution, we implement these APIs thorugh plugin.
   * Default uses quadtree
   * @param { x: Number, y: Number } coordinates to search from
   * @param { String } shape The shape to match against
   * @param { String } type type of the objects to search for
   * */
  getObjectsUnderShape() { return &quot;notImplementedYet&quot;; /* Can be implemented if needed. We need more sophisticated quadtree for this */ }
}

/***********************
******* PRIVATE ********
***********************/
/**
 * @private
 * This handles the default drawing of the map, so that map always updates when drawOnNextTick === true. This tick
 * callback is always set and should not be removed or overruled
 */
function _defaultTick(map, ticker) {
  const ONE_SECOND = 1000;
  var FPSCount = 0;
  var fpsTimer = new Date().getTime();
  var renderStart, totalRenderTime;

  ticker.add(function () {
    if (_drawMapOnNextTick === true) {
      if (map.trackFPSCB) {
        renderStart = new Date().getTime();
      }
      _renderer.render(_staticLayer);
      _drawMapOnNextTick = false;
      if (map.trackFPSCB) {
        totalRenderTime += Math.round( Math.abs( renderStart - new Date().getTime() ) );
      }
    }
    if (map.trackFPSCB) {
      FPSCount++;

      if (fpsTimer + ONE_SECOND &lt; new Date().getTime()) {
        map.trackFPSCB( {
          FPS: FPSCount,
          FPStime: fpsTimer,
          renderTime: totalRenderTime,
          drawCount: _renderer.drawCount
        });
        FPSCount = 0;
        totalRenderTime = 0;
        fpsTimer = new Date().getTime();
      }
    }
  });
}
/**
 * @private
 * Resizes the canvas to the current most wide and high element status. Basically canvas size === window size.
 */
function _resizeCanvas() {
  let windowSize = utils.resize.getWindowSize();

  _renderer.autoResize = true;
  _renderer.resize(windowSize.x, windowSize.y);
  mapEvents.publish(&quot;mapResized&quot;);
  this.drawOnNextTick();
}
/**
 * @private
 * Activate the browsers fullScreen mode and expand the canvas to fullsize
 */
function setFullScreen() {
  utils.resize.toggleFullScreen();
  mapEvents.publish(&quot;mapResized&quot;);
  _resizeCanvas.call(this);
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
