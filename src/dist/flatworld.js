"bundle";
System.registerDynamic("npm:loglevel@1.4.0/lib/loglevel.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(root, definition) {
    "use strict";
    if (typeof module === 'object' && module.exports && typeof $__require === 'function') {
      module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
      define(definition);
    } else {
      root.log = definition();
    }
  }(this, function() {
    "use strict";
    var noop = function() {};
    var undefinedType = "undefined";
    function realMethod(methodName) {
      if (typeof console === undefinedType) {
        return false;
      } else if (console[methodName] !== undefined) {
        return bindMethod(console, methodName);
      } else if (console.log !== undefined) {
        return bindMethod(console, 'log');
      } else {
        return noop;
      }
    }
    function bindMethod(obj, methodName) {
      var method = obj[methodName];
      if (typeof method.bind === 'function') {
        return method.bind(obj);
      } else {
        try {
          return Function.prototype.bind.call(method, obj);
        } catch (e) {
          return function() {
            return Function.prototype.apply.apply(method, [obj, arguments]);
          };
        }
      }
    }
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
      return function() {
        if (typeof console !== undefinedType) {
          replaceLoggingMethods.call(this, level, loggerName);
          this[methodName].apply(this, arguments);
        }
      };
    }
    function replaceLoggingMethods(level, loggerName) {
      for (var i = 0; i < logMethods.length; i++) {
        var methodName = logMethods[i];
        this[methodName] = (i < level) ? noop : this.methodFactory(methodName, level, loggerName);
      }
    }
    function defaultMethodFactory(methodName, level, loggerName) {
      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
    }
    var logMethods = ["trace", "debug", "info", "warn", "error"];
    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }
      function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
        try {
          window.localStorage[storageKey] = levelName;
          return;
        } catch (ignore) {}
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
        } catch (ignore) {}
      }
      function getPersistedLevel() {
        var storedLevel;
        try {
          storedLevel = window.localStorage[storageKey];
        } catch (ignore) {}
        if (typeof storedLevel === undefinedType) {
          try {
            var cookie = window.document.cookie;
            var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
            if (location) {
              storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
            }
          } catch (ignore) {}
        }
        if (self.levels[storedLevel] === undefined) {
          storedLevel = undefined;
        }
        return storedLevel;
      }
      self.levels = {
        "TRACE": 0,
        "DEBUG": 1,
        "INFO": 2,
        "WARN": 3,
        "ERROR": 4,
        "SILENT": 5
      };
      self.methodFactory = factory || defaultMethodFactory;
      self.getLevel = function() {
        return currentLevel;
      };
      self.setLevel = function(level, persist) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
          level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
          currentLevel = level;
          if (persist !== false) {
            persistLevelIfPossible(level);
          }
          replaceLoggingMethods.call(self, level, name);
          if (typeof console === undefinedType && level < self.levels.SILENT) {
            return "No console available for logging";
          }
        } else {
          throw "log.setLevel() called with invalid level: " + level;
        }
      };
      self.setDefaultLevel = function(level) {
        if (!getPersistedLevel()) {
          self.setLevel(level, false);
        }
      };
      self.enableAll = function(persist) {
        self.setLevel(self.levels.TRACE, persist);
      };
      self.disableAll = function(persist) {
        self.setLevel(self.levels.SILENT, persist);
      };
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
        initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }
    var defaultLogger = new Logger();
    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
      if (typeof name !== "string" || name === "") {
        throw new TypeError("You must supply a name when creating a logger.");
      }
      var logger = _loggersByName[name];
      if (!logger) {
        logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
      }
      return logger;
    };
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
      if (typeof window !== undefinedType && window.log === defaultLogger) {
        window.log = _log;
      }
      return defaultLogger;
    };
    return defaultLogger;
  }));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:loglevel@1.4.0.js", ["npm:loglevel@1.4.0/lib/loglevel.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:loglevel@1.4.0/lib/loglevel.js');
  global.define = __define;
  return module.exports;
});

System.register('components/logger/log.js', ['npm:loglevel@1.4.0.js'], function (_export) {
  'use strict';

  /*---------------------
  --------- API ---------
  ----------------------*/

  var log;
  return {
    setters: [function (_npmLoglevel140Js) {
      log = _npmLoglevel140Js['default'];
    }],
    execute: function () {

      log.enableAll();
      /**
       * @class log
       * @requires loglevel.js for frontend logging, or something similar
       **/

      _export('default', {
        debug: function debug(e, errorText) {
          log.debug(errorText, e);
        }
      });
    }
  };
});
System.register('components/map/extensions/basicActions/basicActions.js', [], function (_export) {
  'use strict';

  /*---------------------
  ------- IMPORT --------
  ----------------------*/

  /*---------------------
  --------- API ---------
  ----------------------*/
  function extendUnit(object) {
    object.prototype.move = function () {};
  }
  return {
    setters: [],
    execute: function () {
      _export('extendUnit', extendUnit);
    }
  };
});
System.register('components/map/extensions/mapMovement/mapMovement.js', ['npm:babel-runtime@5.8.24/core-js/object/assign.js', 'bundles/coreBundle.js', 'components/utilities/general.js'], function (_export) {
  var _Object$assign, mapEvents, arrays, viewportWorker, mapMovement;

  /*-----------------------
  -------- PUBLIC ---------
  -----------------------*/
  /** This module manages visibility of the objects, based on are they visible to the player (on the canvas / webgl) or outside of it. This makes the map a lot faster and reliable resource-wise and lags otherwise. Requires subcontainers atm.
   *
   * @class mapMovement
   **/
  function setupMapMovement() {
    var VIEWPORT_OFFSET = 0.15;
    var CHECK_INTERVAL = 20;
    var queue = {};
    var changedCoordinates = {
      width: 0,
      height: 0
    };

    return {
      init: init,
      pluginName: "mapMovement",
      addAll: addAll,
      check: check,
      startEventListeners: startEventListeners
    };
    /**
     * Ínitialize as a plugin
     *
     * @method init
     * @param  {Map} map     Instance of Map
     */
    function init(map) {
      addAll(map);
      startEventListeners(map);
      map.drawOnNextTick();
      /**
       * For debugging. Shows the amount of currectly active and inactive subcontainers. Console.logs the data. Also extends window object.
       *
       * @method window.FlaTWorld_mapMovement_subCheck
       * @static
       */
      window.FlaTWorld_mapMovement_subCheck = function () {
        map.getPrimaryLayers().forEach(function (layer) {
          var subcontainers = arrays.flatten2Levels(layer.getSubcontainers());
          var visibleContainers, invisibleContainers;

          visibleContainers = subcontainers.filter(function (subcontainer) {
            return subcontainer.visible;
          });
          invisibleContainers = subcontainers.filter(function (subcontainer) {
            return !subcontainer.visible;
          });

          console.log("visible subcontainers: " + visibleContainers.length + ":" + visibleContainers, "\n\ninvisible: " + invisibleContainers.length + ":" + invisibleContainers);
        });
      };
      /**
       * For debugging. Sets all primaryLayers subcontainers on the map as visible = true.
       *
       * @method window.FlaTWorld_mapMovement_deactivate
       * @static
       */
      window.FlaTWorld_mapMovement_deactivate = function () {
        map.getPrimaryLayers().forEach(function (layer) {
          var subcontainers = arrays.flatten2Levels(layer.getSubcontainers());
          var visibleContainers, invisibleContainers;

          visibleContainers = subcontainers.forEach(function (subcontainer) {
            subcontainer.visible = false;
          });
        });
      };
    }
    /**
     * Ínitialize as a plugin
     *
     * @method addAll
     * @param  {Map} map     Instance of Map
     */
    function addAll(map) {
      var scale = map.getZoom();
      var viewportArea;

      viewportArea = map.getViewportArea();
      _Object$assign(viewportArea, getViewportsRightSideCoordinates(viewportArea));
      _Object$assign(viewportArea, applyScaleToViewport(viewportArea, map.getZoom()));

      map.getPrimaryLayers().forEach(function (layer) {
        var subcontainers = arrays.flatten2Levels(layer.getSubcontainers());

        subcontainers.forEach(function (subcontainer) {
          subcontainer.visible = isObjectOutsideViewport(subcontainer, viewportArea, false, scale) ? false : true;
        });
      });
    }
    /**
     * This one checks the that the objects that should currently be visible in the viewport area are visible and outside
     * of the viewport objects are set .visible = false. This affect performance a lot. Basically when the map moves, we
     * set a check in the future based on the given intervalCheck milliseconds. And immediately after it we check if there
     * is another map movement. If there is we set another timeout. This works better with timeouts.
     *
     * This uses webWorkers. They seemed to speed up the check, when timing with performance.now.
     *
     * @method check
     * @param  {Map} map        The current Map instance
     * @return {Boolean}        True
     */
    function check(map) {
      if (queue.processing) {
        return false;
      }
      queue.processing = true;

      var viewportFn = setupHandleViewportArea(queue, map, changedCoordinates);
      window.setTimeout(viewportFn, CHECK_INTERVAL);

      function setupHandleViewportArea(queue, map, changedCoordinates) {
        var viewportArea = map.getViewportArea();

        if (window.Worker) {
          viewportWorker.onmessage = function (e) {
            var scale = map.getZoom();
            var scaledViewport = e.data[0];
            var smallerScaledViewport = e.data[1];
            var containersUnderChangedArea = [];
            var usesCache = map.isCacheActivated();
            var isOutside, scaledAndChangedViewport;

            scaledAndChangedViewport = _Object$assign({}, scaledViewport);

            scaledAndChangedViewport.width += Math.round(Math.abs(changedCoordinates.width));
            scaledAndChangedViewport.height += Math.round(Math.abs(changedCoordinates.height));

            /* RESET */
            changedCoordinates.width = 0;
            changedCoordinates.height = 0;

            containersUnderChangedArea = map.getPrimaryLayers().map(function (layer) {
              return layer.getSubcontainersByCoordinates(scaledAndChangedViewport);
            });
            containersUnderChangedArea = arrays.flatten2Levels(containersUnderChangedArea);

            containersUnderChangedArea.forEach(function (thisContainer) {
              isOutside = isObjectOutsideViewport(thisContainer, smallerScaledViewport, true, scale);

              if (isOutside) {
                thisContainer.visible = false;
              } else {
                thisContainer.visible = true;
              }
            });

            queue.processing = false;

            map.drawOnNextTick();
          };
          viewportWorker.postMessage([1, viewportArea, map.getZoom(), changedCoordinates]);
        } else {
          queue.processing = false;
          throw new Error("ERROR WITH WEB WORKER");
        }
      }

      return;
    }
    /**
     * @method startEventListeners
     * @param  {Map} map     Instance of Map
     */
    function startEventListeners(map) {
      mapEvents.subscribe("mapMoved", moveCb);
      mapEvents.subscribe("mapResized", resizeCb);

      function moveCb(type) {
        var movedCoordinates = type.customData[0];

        changedCoordinates.width += movedCoordinates.x;
        changedCoordinates.height += movedCoordinates.y;
        mapMovement.check(map);
      }
      function resizeCb() {
        mapMovement.check(map);
      }
    }
    /*-----------------------
    -------- PRIVATE --------
    -----------------------*/
    /**
     * @private
     * @static
     * @method isObjectOutsideViewport
     * @param  {Object}  object                 Object / layer we are testing
     * @param  {Object} viewportArea            ViewportArea location and size
     * @param  {Integer} viewportArea.x         X coordinate
     * @param  {Integer} viewportArea.y         Y coordinate
     * @param  {Integer} viewportArea.width     Viewports width (in pixels)
     * @param  {Integer} viewportArea.height    Viewports height (in pixels)
     * @param  {Boolean} hasParent              default = true
     * @param  {Number}  scale                  default = 1 (equals to no defaul scale / no scale)
     * @return {Boolean}
     */
    function isObjectOutsideViewport(object, viewportArea) {
      var hasParent = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
      var scale = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

      var isIt, globalCoords;

      globalCoords = object.getSubcontainerArea(scale, { toGlobal: hasParent });

      isIt = !testRectangleIntersect(globalCoords, viewportArea);

      return isIt;
    }
    /**
     * @private
     * @static
     * @method getViewportsRightSideCoordinates
     * @private
     * @param  {Object} viewportArea            ViewportArea location and size
     * @param  {Integer} viewportArea.x         X coordinate
     * @param  {Integer} viewportArea.y         Y coordinate
     * @param  {Integer} viewportArea.width     Viewports width (in pixels)
     * @param  {Integer} viewportArea.height    Viewports height (in pixels)
     */
    function getViewportsRightSideCoordinates(viewportArea) {
      var offsetSize = Math.abs(viewportArea.width * VIEWPORT_OFFSET * 2);

      return {
        x2: Math.round(viewportArea.x + Math.abs(viewportArea.width) + offsetSize),
        y2: Math.round(viewportArea.y + Math.abs(viewportArea.height) + offsetSize),
        width: Math.round(viewportArea.width + offsetSize),
        height: Math.round(viewportArea.height + offsetSize)
      };
    }
    /**
     * Calculates and modifies coordinates and size according to current scale / zoom on the map.
     *
     * @private
     * @static
     * @method applyScaleToViewport
     * @private
     * @param  {Object} viewportArea            ViewportArea location and size
     * @param  {Integer} viewportArea.x         X coordinate
     * @param  {Integer} viewportArea.y         Y coordinate
     * @param  {Integer} viewportArea.width     Viewports width (in pixels)
     * @param  {Integer} viewportArea.height    Viewports height (in pixels)
     * @param {Number} scale
     */
    function applyScaleToViewport(viewportArea, scale) {
      return {
        x: Math.round(viewportArea.x / scale),
        y: Math.round(viewportArea.y / scale),
        x2: Math.round(viewportArea.x2 / scale),
        y2: Math.round(viewportArea.y2 / scale),
        width: Math.round(viewportArea.width / scale),
        height: Math.round(viewportArea.height / scale)
      };
    }
  }
  /*-----------------------
  -------- PRIVATE --------
  -----------------------*/
  /**
   * @private
   * @static
   * @method testRectangleIntersect
   */
  function testRectangleIntersect(a, b) {
    return a.x <= b.x + b.width && b.x <= a.x + a.width && a.y <= b.y + b.height && b.y <= a.y + a.height;
  }
  return {
    setters: [function (_npmBabelRuntime5824CoreJsObjectAssignJs) {
      _Object$assign = _npmBabelRuntime5824CoreJsObjectAssignJs['default'];
    }, function (_bundlesCoreBundleJs) {
      mapEvents = _bundlesCoreBundleJs.mapEvents;
    }, function (_componentsUtilitiesGeneralJs) {
      arrays = _componentsUtilitiesGeneralJs.arrays;
    }],
    execute: function () {
      /* global console */

      /*-----------------------
      ------- VARIABLES -------
      -----------------------*/

      /*-----------------------
      --------- IMPORT --------
      -----------------------*/
      'use strict';viewportWorker = new Worker("/components/map/extensions/mapMovement/mapMovementWorker.js");

      /*-----------------------
      ---------- API ----------
      -----------------------*/
      /* For debugging. This will show up if the plugin fails to load in Map.js */
      mapMovement = setupMapMovement();

      _export('mapMovement', mapMovement);
    }
  };
});
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
!function(a, b) {
  "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
    if (!a.document)
      throw new Error("jQuery requires a window with a document");
    return b(a);
  } : b(a);
}("undefined" != typeof window ? window : this, function(a, b) {
  var c = [],
      d = c.slice,
      e = c.concat,
      f = c.push,
      g = c.indexOf,
      h = {},
      i = h.toString,
      j = h.hasOwnProperty,
      k = {},
      l = a.document,
      m = "2.1.1 -deprecated,-dimensions,-event-alias,-offset,-css/hiddenVisibleSelectors,-effects/animatedSelector,-wrap",
      n = function(a, b) {
        return new n.fn.init(a, b);
      },
      o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      p = /^-ms-/,
      q = /-([\da-z])/gi,
      r = function(a, b) {
        return b.toUpperCase();
      };
  n.fn = n.prototype = {
    jquery: m,
    constructor: n,
    selector: "",
    length: 0,
    toArray: function() {
      return d.call(this);
    },
    get: function(a) {
      return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this);
    },
    pushStack: function(a) {
      var b = n.merge(this.constructor(), a);
      return b.prevObject = this, b.context = this.context, b;
    },
    each: function(a, b) {
      return n.each(this, a, b);
    },
    map: function(a) {
      return this.pushStack(n.map(this, function(b, c) {
        return a.call(b, c, b);
      }));
    },
    slice: function() {
      return this.pushStack(d.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(a) {
      var b = this.length,
          c = +a + (0 > a ? b : 0);
      return this.pushStack(c >= 0 && b > c ? [this[c]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor(null);
    },
    push: f,
    sort: c.sort,
    splice: c.splice
  }, n.extend = n.fn.extend = function() {
    var a,
        b,
        c,
        d,
        e,
        f,
        g = arguments[0] || {},
        h = 1,
        i = arguments.length,
        j = !1;
    for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)
      if (null != (a = arguments[h]))
        for (b in a)
          c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));
    return g;
  }, n.extend({
    expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function(a) {
      throw new Error(a);
    },
    noop: function() {},
    isFunction: function(a) {
      return "function" === n.type(a);
    },
    isArray: Array.isArray,
    isWindow: function(a) {
      return null != a && a === a.window;
    },
    isNumeric: function(a) {
      return !n.isArray(a) && a - parseFloat(a) >= 0;
    },
    isPlainObject: function(a) {
      return "object" !== n.type(a) || a.nodeType || n.isWindow(a) ? !1 : a.constructor && !j.call(a.constructor.prototype, "isPrototypeOf") ? !1 : !0;
    },
    isEmptyObject: function(a) {
      var b;
      for (b in a)
        return !1;
      return !0;
    },
    type: function(a) {
      return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a;
    },
    globalEval: function(a) {
      var b,
          c = eval;
      a = n.trim(a), a && (1 === a.indexOf("use strict") ? (b = l.createElement("script"), b.text = a, l.head.appendChild(b).parentNode.removeChild(b)) : c(a));
    },
    camelCase: function(a) {
      return a.replace(p, "ms-").replace(q, r);
    },
    nodeName: function(a, b) {
      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
    },
    each: function(a, b, c) {
      var d,
          e = 0,
          f = a.length,
          g = s(a);
      if (c) {
        if (g) {
          for (; f > e; e++)
            if (d = b.apply(a[e], c), d === !1)
              break;
        } else
          for (e in a)
            if (d = b.apply(a[e], c), d === !1)
              break;
      } else if (g) {
        for (; f > e; e++)
          if (d = b.call(a[e], e, a[e]), d === !1)
            break;
      } else
        for (e in a)
          if (d = b.call(a[e], e, a[e]), d === !1)
            break;
      return a;
    },
    trim: function(a) {
      return null == a ? "" : (a + "").replace(o, "");
    },
    makeArray: function(a, b) {
      var c = b || [];
      return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c;
    },
    inArray: function(a, b, c) {
      return null == b ? -1 : g.call(b, a, c);
    },
    merge: function(a, b) {
      for (var c = +b.length,
          d = 0,
          e = a.length; c > d; d++)
        a[e++] = b[d];
      return a.length = e, a;
    },
    grep: function(a, b, c) {
      for (var d,
          e = [],
          f = 0,
          g = a.length,
          h = !c; g > f; f++)
        d = !b(a[f], f), d !== h && e.push(a[f]);
      return e;
    },
    map: function(a, b, c) {
      var d,
          f = 0,
          g = a.length,
          h = s(a),
          i = [];
      if (h)
        for (; g > f; f++)
          d = b(a[f], f, c), null != d && i.push(d);
      else
        for (f in a)
          d = b(a[f], f, c), null != d && i.push(d);
      return e.apply([], i);
    },
    guid: 1,
    proxy: function(a, b) {
      var c,
          e,
          f;
      return "string" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (e = d.call(arguments, 2), f = function() {
        return a.apply(b || this, e.concat(d.call(arguments)));
      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;
    },
    now: Date.now,
    support: k
  }), n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
    h["[object " + b + "]"] = b.toLowerCase();
  });
  function s(a) {
    var b = a.length,
        c = n.type(a);
    return "function" === c || n.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a;
  }
  var t = a.document.documentElement,
      u,
      v = t.matches || t.webkitMatchesSelector || t.mozMatchesSelector || t.oMatchesSelector || t.msMatchesSelector,
      w = function(a, b) {
        if (a === b)
          return u = !0, 0;
        var c = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
        return c ? 1 & c ? a === l || n.contains(l, a) ? -1 : b === l || n.contains(l, b) ? 1 : 0 : 4 & c ? -1 : 1 : a.compareDocumentPosition ? -1 : 1;
      };
  n.extend({
    find: function(a, b, c, d) {
      var e,
          f,
          g = 0;
      if (c = c || [], b = b || l, !a || "string" != typeof a)
        return c;
      if (1 !== (f = b.nodeType) && 9 !== f)
        return [];
      if (d)
        while (e = d[g++])
          n.find.matchesSelector(e, a) && c.push(e);
      else
        n.merge(c, b.querySelectorAll(a));
      return c;
    },
    unique: function(a) {
      var b,
          c = [],
          d = 0,
          e = 0;
      if (u = !1, a.sort(w), u) {
        while (b = a[d++])
          b === a[d] && (e = c.push(d));
        while (e--)
          a.splice(c[e], 1);
      }
      return a;
    },
    text: function(a) {
      var b,
          c = "",
          d = 0,
          e = a.nodeType;
      if (e) {
        if (1 === e || 9 === e || 11 === e)
          return a.textContent;
        if (3 === e || 4 === e)
          return a.nodeValue;
      } else
        while (b = a[d++])
          c += n.text(b);
      return c;
    },
    contains: function(a, b) {
      var c = 9 === a.nodeType ? a.documentElement : a,
          d = b && b.parentNode;
      return a === d || !(!d || 1 !== d.nodeType || !c.contains(d));
    },
    isXMLDoc: function(a) {
      return "HTML" !== (a.ownerDocument || a).documentElement.nodeName;
    },
    expr: {
      attrHandle: {},
      match: {
        bool: /^(?:checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)$/i,
        needsContext: /^[\x20\t\r\n\f]*[>+~]/
      }
    }
  }), n.extend(n.find, {
    matches: function(a, b) {
      return n.find(a, null, null, b);
    },
    matchesSelector: function(a, b) {
      return v.call(a, b);
    },
    attr: function(a, b) {
      return a.getAttribute(b);
    }
  });
  var x = n.expr.match.needsContext,
      y = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      z = /^.[^:#\[\.,]*$/;
  function A(a, b, c) {
    if (n.isFunction(b))
      return n.grep(a, function(a, d) {
        return !!b.call(a, d, a) !== c;
      });
    if (b.nodeType)
      return n.grep(a, function(a) {
        return a === b !== c;
      });
    if ("string" == typeof b) {
      if (z.test(b))
        return n.filter(b, a, c);
      b = n.filter(b, a);
    }
    return n.grep(a, function(a) {
      return g.call(b, a) >= 0 !== c;
    });
  }
  n.filter = function(a, b, c) {
    var d = b[0];
    return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function(a) {
      return 1 === a.nodeType;
    }));
  }, n.fn.extend({
    find: function(a) {
      var b,
          c = this.length,
          d = [],
          e = this;
      if ("string" != typeof a)
        return this.pushStack(n(a).filter(function() {
          for (b = 0; c > b; b++)
            if (n.contains(e[b], this))
              return !0;
        }));
      for (b = 0; c > b; b++)
        n.find(a, e[b], d);
      return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d;
    },
    filter: function(a) {
      return this.pushStack(A(this, a || [], !1));
    },
    not: function(a) {
      return this.pushStack(A(this, a || [], !0));
    },
    is: function(a) {
      return !!A(this, "string" == typeof a && x.test(a) ? n(a) : a || [], !1).length;
    }
  });
  var B,
      C = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      D = n.fn.init = function(a, b) {
        var c,
            d;
        if (!a)
          return this;
        if ("string" == typeof a) {
          if (c = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : C.exec(a), !c || !c[1] && b)
            return !b || b.jquery ? (b || B).find(a) : this.constructor(b).find(a);
          if (c[1]) {
            if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : l, !0)), y.test(c[1]) && n.isPlainObject(b))
              for (c in b)
                n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
            return this;
          }
          return d = l.getElementById(c[2]), d && d.parentNode && (this.length = 1, this[0] = d), this.context = l, this.selector = a, this;
        }
        return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? "undefined" != typeof B.ready ? B.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));
      };
  D.prototype = n.fn, B = n(l);
  var E = /^(?:parents|prev(?:Until|All))/,
      F = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
      };
  n.extend({
    dir: function(a, b, c) {
      var d = [],
          e = void 0 !== c;
      while ((a = a[b]) && 9 !== a.nodeType)
        if (1 === a.nodeType) {
          if (e && n(a).is(c))
            break;
          d.push(a);
        }
      return d;
    },
    sibling: function(a, b) {
      for (var c = []; a; a = a.nextSibling)
        1 === a.nodeType && a !== b && c.push(a);
      return c;
    }
  }), n.fn.extend({
    has: function(a) {
      var b = n(a, this),
          c = b.length;
      return this.filter(function() {
        for (var a = 0; c > a; a++)
          if (n.contains(this, b[a]))
            return !0;
      });
    },
    closest: function(a, b) {
      for (var c,
          d = 0,
          e = this.length,
          f = [],
          g = x.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++)
        for (c = this[d]; c && c !== b; c = c.parentNode)
          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {
            f.push(c);
            break;
          }
      return this.pushStack(f.length > 1 ? n.unique(f) : f);
    },
    index: function(a) {
      return a ? "string" == typeof a ? g.call(n(a), this[0]) : g.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
    },
    add: function(a, b) {
      return this.pushStack(n.unique(n.merge(this.get(), n(a, b))));
    },
    addBack: function(a) {
      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
    }
  });
  function G(a, b) {
    while ((a = a[b]) && 1 !== a.nodeType)
      ;
    return a;
  }
  n.each({
    parent: function(a) {
      var b = a.parentNode;
      return b && 11 !== b.nodeType ? b : null;
    },
    parents: function(a) {
      return n.dir(a, "parentNode");
    },
    parentsUntil: function(a, b, c) {
      return n.dir(a, "parentNode", c);
    },
    next: function(a) {
      return G(a, "nextSibling");
    },
    prev: function(a) {
      return G(a, "previousSibling");
    },
    nextAll: function(a) {
      return n.dir(a, "nextSibling");
    },
    prevAll: function(a) {
      return n.dir(a, "previousSibling");
    },
    nextUntil: function(a, b, c) {
      return n.dir(a, "nextSibling", c);
    },
    prevUntil: function(a, b, c) {
      return n.dir(a, "previousSibling", c);
    },
    siblings: function(a) {
      return n.sibling((a.parentNode || {}).firstChild, a);
    },
    children: function(a) {
      return n.sibling(a.firstChild);
    },
    contents: function(a) {
      return a.contentDocument || n.merge([], a.childNodes);
    }
  }, function(a, b) {
    n.fn[a] = function(c, d) {
      var e = n.map(this, b, c);
      return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (F[a] || n.unique(e), E.test(a) && e.reverse()), this.pushStack(e);
    };
  });
  var H = /\S+/g,
      I = {};
  function J(a) {
    var b = I[a] = {};
    return n.each(a.match(H) || [], function(a, c) {
      b[c] = !0;
    }), b;
  }
  n.Callbacks = function(a) {
    a = "string" == typeof a ? I[a] || J(a) : n.extend({}, a);
    var b,
        c,
        d,
        e,
        f,
        g,
        h = [],
        i = !a.once && [],
        j = function(l) {
          for (b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0; h && f > g; g++)
            if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
              b = !1;
              break;
            }
          d = !1, h && (i ? i.length && j(i.shift()) : b ? h = [] : k.disable());
        },
        k = {
          add: function() {
            if (h) {
              var c = h.length;
              !function g(b) {
                n.each(b, function(b, c) {
                  var d = n.type(c);
                  "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && g(c);
                });
              }(arguments), d ? f = h.length : b && (e = c, j(b));
            }
            return this;
          },
          remove: function() {
            return h && n.each(arguments, function(a, b) {
              var c;
              while ((c = n.inArray(b, h, c)) > -1)
                h.splice(c, 1), d && (f >= c && f--, g >= c && g--);
            }), this;
          },
          has: function(a) {
            return a ? n.inArray(a, h) > -1 : !(!h || !h.length);
          },
          empty: function() {
            return h = [], f = 0, this;
          },
          disable: function() {
            return h = i = b = void 0, this;
          },
          disabled: function() {
            return !h;
          },
          lock: function() {
            return i = void 0, b || k.disable(), this;
          },
          locked: function() {
            return !i;
          },
          fireWith: function(a, b) {
            return !h || c && !i || (b = b || [], b = [a, b.slice ? b.slice() : b], d ? i.push(b) : j(b)), this;
          },
          fire: function() {
            return k.fireWith(this, arguments), this;
          },
          fired: function() {
            return !!c;
          }
        };
    return k;
  }, n.extend({
    Deferred: function(a) {
      var b = [["resolve", "done", n.Callbacks("once memory"), "resolved"], ["reject", "fail", n.Callbacks("once memory"), "rejected"], ["notify", "progress", n.Callbacks("memory")]],
          c = "pending",
          d = {
            state: function() {
              return c;
            },
            always: function() {
              return e.done(arguments).fail(arguments), this;
            },
            then: function() {
              var a = arguments;
              return n.Deferred(function(c) {
                n.each(b, function(b, f) {
                  var g = n.isFunction(a[b]) && a[b];
                  e[f[1]](function() {
                    var a = g && g.apply(this, arguments);
                    a && n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments);
                  });
                }), a = null;
              }).promise();
            },
            promise: function(a) {
              return null != a ? n.extend(a, d) : d;
            }
          },
          e = {};
      return d.pipe = d.then, n.each(b, function(a, f) {
        var g = f[2],
            h = f[3];
        d[f[1]] = g.add, h && g.add(function() {
          c = h;
        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
          return e[f[0] + "With"](this === e ? d : this, arguments), this;
        }, e[f[0] + "With"] = g.fireWith;
      }), d.promise(e), a && a.call(e, e), e;
    },
    when: function(a) {
      var b = 0,
          c = d.call(arguments),
          e = c.length,
          f = 1 !== e || a && n.isFunction(a.promise) ? e : 0,
          g = 1 === f ? a : n.Deferred(),
          h = function(a, b, c) {
            return function(e) {
              b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
            };
          },
          i,
          j,
          k;
      if (e > 1)
        for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++)
          c[b] && n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
      return f || g.resolveWith(k, c), g.promise();
    }
  });
  var K;
  n.fn.ready = function(a) {
    return n.ready.promise().done(a), this;
  }, n.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function(a) {
      a ? n.readyWait++ : n.ready(!0);
    },
    ready: function(a) {
      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (K.resolveWith(l, [n]), n.fn.triggerHandler && (n(l).triggerHandler("ready"), n(l).off("ready"))));
    }
  });
  function L() {
    l.removeEventListener("DOMContentLoaded", L, !1), a.removeEventListener("load", L, !1), n.ready();
  }
  n.ready.promise = function(b) {
    return K || (K = n.Deferred(), "complete" === l.readyState ? setTimeout(n.ready) : (l.addEventListener("DOMContentLoaded", L, !1), a.addEventListener("load", L, !1))), K.promise(b);
  }, n.ready.promise();
  var M = n.access = function(a, b, c, d, e, f, g) {
    var h = 0,
        i = a.length,
        j = null == c;
    if ("object" === n.type(c)) {
      e = !0;
      for (h in c)
        n.access(a, b, h, c[h], !0, f, g);
    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
      return j.call(n(a), c);
    })), b))
      for (; i > h; h++)
        b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
    return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
  };
  n.acceptData = function(a) {
    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;
  };
  function N() {
    Object.defineProperty(this.cache = {}, 0, {get: function() {
        return {};
      }}), this.expando = n.expando + Math.random();
  }
  N.uid = 1, N.accepts = n.acceptData, N.prototype = {
    key: function(a) {
      if (!N.accepts(a))
        return 0;
      var b = {},
          c = a[this.expando];
      if (!c) {
        c = N.uid++;
        try {
          b[this.expando] = {value: c}, Object.defineProperties(a, b);
        } catch (d) {
          b[this.expando] = c, n.extend(a, b);
        }
      }
      return this.cache[c] || (this.cache[c] = {}), c;
    },
    set: function(a, b, c) {
      var d,
          e = this.key(a),
          f = this.cache[e];
      if ("string" == typeof b)
        f[b] = c;
      else if (n.isEmptyObject(f))
        n.extend(this.cache[e], b);
      else
        for (d in b)
          f[d] = b[d];
      return f;
    },
    get: function(a, b) {
      var c = this.cache[this.key(a)];
      return void 0 === b ? c : c[b];
    },
    access: function(a, b, c) {
      var d;
      return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);
    },
    remove: function(a, b) {
      var c,
          d,
          e,
          f = this.key(a),
          g = this.cache[f];
      if (void 0 === b)
        this.cache[f] = {};
      else {
        n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in g ? d = [b, e] : (d = e, d = d in g ? [d] : d.match(H) || [])), c = d.length;
        while (c--)
          delete g[d[c]];
      }
    },
    hasData: function(a) {
      return !n.isEmptyObject(this.cache[a[this.expando]] || {});
    },
    discard: function(a) {
      a[this.expando] && delete this.cache[a[this.expando]];
    }
  };
  var O = new N,
      P = new N,
      Q = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      R = /([A-Z])/g;
  function S(a, b, c) {
    var d;
    if (void 0 === c && 1 === a.nodeType)
      if (d = "data-" + b.replace(R, "-$1").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
        try {
          c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : Q.test(c) ? n.parseJSON(c) : c;
        } catch (e) {}
        P.set(a, b, c);
      } else
        c = void 0;
    return c;
  }
  n.extend({
    hasData: function(a) {
      return P.hasData(a) || O.hasData(a);
    },
    data: function(a, b, c) {
      return P.access(a, b, c);
    },
    removeData: function(a, b) {
      P.remove(a, b);
    },
    _data: function(a, b, c) {
      return O.access(a, b, c);
    },
    _removeData: function(a, b) {
      O.remove(a, b);
    }
  }), n.fn.extend({
    data: function(a, b) {
      var c,
          d,
          e,
          f = this[0],
          g = f && f.attributes;
      if (void 0 === a) {
        if (this.length && (e = P.get(f), 1 === f.nodeType && !O.get(f, "hasDataAttrs"))) {
          c = g.length;
          while (c--)
            g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), S(f, d, e[d])));
          O.set(f, "hasDataAttrs", !0);
        }
        return e;
      }
      return "object" == typeof a ? this.each(function() {
        P.set(this, a);
      }) : M(this, function(b) {
        var c,
            d = n.camelCase(a);
        if (f && void 0 === b) {
          if (c = P.get(f, a), void 0 !== c)
            return c;
          if (c = P.get(f, d), void 0 !== c)
            return c;
          if (c = S(f, d, void 0), void 0 !== c)
            return c;
        } else
          this.each(function() {
            var c = P.get(this, d);
            P.set(this, d, b), -1 !== a.indexOf("-") && void 0 !== c && P.set(this, a, b);
          });
      }, null, b, arguments.length > 1, null, !0);
    },
    removeData: function(a) {
      return this.each(function() {
        P.remove(this, a);
      });
    }
  }), n.extend({
    queue: function(a, b, c) {
      var d;
      return a ? (b = (b || "fx") + "queue", d = O.get(a, b), c && (!d || n.isArray(c) ? d = O.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;
    },
    dequeue: function(a, b) {
      b = b || "fx";
      var c = n.queue(a, b),
          d = c.length,
          e = c.shift(),
          f = n._queueHooks(a, b),
          g = function() {
            n.dequeue(a, b);
          };
      "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
    },
    _queueHooks: function(a, b) {
      var c = b + "queueHooks";
      return O.get(a, c) || O.access(a, c, {empty: n.Callbacks("once memory").add(function() {
          O.remove(a, [b + "queue", c]);
        })});
    }
  }), n.fn.extend({
    queue: function(a, b) {
      var c = 2;
      return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function() {
        var c = n.queue(this, a, b);
        n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a);
      });
    },
    dequeue: function(a) {
      return this.each(function() {
        n.dequeue(this, a);
      });
    },
    clearQueue: function(a) {
      return this.queue(a || "fx", []);
    },
    promise: function(a, b) {
      var c,
          d = 1,
          e = n.Deferred(),
          f = this,
          g = this.length,
          h = function() {
            --d || e.resolveWith(f, [f]);
          };
      "string" != typeof a && (b = a, a = void 0), a = a || "fx";
      while (g--)
        c = O.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
      return h(), e.promise(b);
    }
  });
  var T = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
      U = ["Top", "Right", "Bottom", "Left"],
      V = function(a, b) {
        return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a);
      },
      W = /^(?:checkbox|radio)$/i;
  !function() {
    var a = l.createDocumentFragment(),
        b = a.appendChild(l.createElement("div")),
        c = l.createElement("input");
    c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;
  }();
  var X = "undefined";
  k.focusinBubbles = "onfocusin" in a;
  var Y = /^key/,
      Z = /^(?:mouse|pointer|contextmenu)|click/,
      $ = /^(?:focusinfocus|focusoutblur)$/,
      _ = /^([^.]*)(?:\.(.+)|)$/;
  function ab() {
    return !0;
  }
  function bb() {
    return !1;
  }
  function cb() {
    try {
      return l.activeElement;
    } catch (a) {}
  }
  n.event = {
    global: {},
    add: function(a, b, c, d, e) {
      var f,
          g,
          h,
          i,
          j,
          k,
          l,
          m,
          o,
          p,
          q,
          r = O.get(a);
      if (r) {
        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function(b) {
          return typeof n !== X && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;
        }), b = (b || "").match(H) || [""], j = b.length;
        while (j--)
          h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({
            type: o,
            origType: q,
            data: d,
            handler: c,
            guid: c.guid,
            selector: e,
            needsContext: e && n.expr.match.needsContext.test(e),
            namespace: p.join(".")
          }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g, !1)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);
      }
    },
    remove: function(a, b, c, d, e) {
      var f,
          g,
          h,
          i,
          j,
          k,
          l,
          m,
          o,
          p,
          q,
          r = O.hasData(a) && O.get(a);
      if (r && (i = r.events)) {
        b = (b || "").match(H) || [""], j = b.length;
        while (j--)
          if (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length;
            while (f--)
              k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
            g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);
          } else
            for (o in i)
              n.event.remove(a, o + b[j], c, d, !0);
        n.isEmptyObject(i) && (delete r.handle, O.remove(a, "events"));
      }
    },
    trigger: function(b, c, d, e) {
      var f,
          g,
          h,
          i,
          k,
          m,
          o,
          p = [d || l],
          q = j.call(b, "type") ? b.type : b,
          r = j.call(b, "namespace") ? b.namespace.split(".") : [];
      if (g = h = d = d || l, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(q + n.event.triggered) && (q.indexOf(".") >= 0 && (r = q.split("."), q = r.shift(), r.sort()), k = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = r.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, e || !o.trigger || o.trigger.apply(d, c) !== !1)) {
        if (!e && !o.noBubble && !n.isWindow(d)) {
          for (i = o.delegateType || q, $.test(i + q) || (g = g.parentNode); g; g = g.parentNode)
            p.push(g), h = g;
          h === (d.ownerDocument || l) && p.push(h.defaultView || h.parentWindow || a);
        }
        f = 0;
        while ((g = p[f++]) && !b.isPropagationStopped())
          b.type = f > 1 ? i : o.bindType || q, m = (O.get(g, "events") || {})[b.type] && O.get(g, "handle"), m && m.apply(g, c), m = k && g[k], m && m.apply && n.acceptData(g) && (b.result = m.apply(g, c), b.result === !1 && b.preventDefault());
        return b.type = q, e || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !n.acceptData(d) || k && n.isFunction(d[q]) && !n.isWindow(d) && (h = d[k], h && (d[k] = null), n.event.triggered = q, d[q](), n.event.triggered = void 0, h && (d[k] = h)), b.result;
      }
    },
    dispatch: function(a) {
      a = n.event.fix(a);
      var b,
          c,
          e,
          f,
          g,
          h = [],
          i = d.call(arguments),
          j = (O.get(this, "events") || {})[a.type] || [],
          k = n.event.special[a.type] || {};
      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
        h = n.event.handlers.call(this, a, j), b = 0;
        while ((f = h[b++]) && !a.isPropagationStopped()) {
          a.currentTarget = f.elem, c = 0;
          while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped())
            (!a.namespace_re || a.namespace_re.test(g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (a.result = e) === !1 && (a.preventDefault(), a.stopPropagation()));
        }
        return k.postDispatch && k.postDispatch.call(this, a), a.result;
      }
    },
    handlers: function(a, b) {
      var c,
          d,
          e,
          f,
          g = [],
          h = b.delegateCount,
          i = a.target;
      if (h && i.nodeType && (!a.button || "click" !== a.type))
        for (; i !== this; i = i.parentNode || this)
          if (i.disabled !== !0 || "click" !== a.type) {
            for (d = [], c = 0; h > c; c++)
              f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) >= 0 : n.find(e, this, null, [i]).length), d[e] && d.push(f);
            d.length && g.push({
              elem: i,
              handlers: d
            });
          }
      return h < b.length && g.push({
        elem: this,
        handlers: b.slice(h)
      }), g;
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(a, b) {
        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(a, b) {
        var c,
            d,
            e,
            f = b.button;
        return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || l, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a;
      }
    },
    fix: function(a) {
      if (a[n.expando])
        return a;
      var b,
          c,
          d,
          e = a.type,
          f = a,
          g = this.fixHooks[e];
      g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new n.Event(f), b = d.length;
      while (b--)
        c = d[b], a[c] = f[c];
      return a.target || (a.target = l), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a;
    },
    special: {
      load: {noBubble: !0},
      focus: {
        trigger: function() {
          return this !== cb() && this.focus ? (this.focus(), !1) : void 0;
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          return this === cb() && this.blur ? (this.blur(), !1) : void 0;
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0;
        },
        _default: function(a) {
          return n.nodeName(a.target, "a");
        }
      },
      beforeunload: {postDispatch: function(a) {
          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
        }}
    },
    simulate: function(a, b, c, d) {
      var e = n.extend(new n.Event, c, {
        type: a,
        isSimulated: !0,
        originalEvent: {}
      });
      d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
    }
  }, n.removeEvent = function(a, b, c) {
    a.removeEventListener && a.removeEventListener(b, c, !1);
  }, n.Event = function(a, b) {
    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ab : bb) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(a, b);
  }, n.Event.prototype = {
    isDefaultPrevented: bb,
    isPropagationStopped: bb,
    isImmediatePropagationStopped: bb,
    preventDefault: function() {
      var a = this.originalEvent;
      this.isDefaultPrevented = ab, a && a.preventDefault && a.preventDefault();
    },
    stopPropagation: function() {
      var a = this.originalEvent;
      this.isPropagationStopped = ab, a && a.stopPropagation && a.stopPropagation();
    },
    stopImmediatePropagation: function() {
      var a = this.originalEvent;
      this.isImmediatePropagationStopped = ab, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation();
    }
  }, n.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(a, b) {
    n.event.special[a] = {
      delegateType: b,
      bindType: b,
      handle: function(a) {
        var c,
            d = this,
            e = a.relatedTarget,
            f = a.handleObj;
        return (!e || e !== d && !n.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;
      }
    };
  }), k.focusinBubbles || n.each({
    focus: "focusin",
    blur: "focusout"
  }, function(a, b) {
    var c = function(a) {
      n.event.simulate(b, a.target, n.event.fix(a), !0);
    };
    n.event.special[b] = {
      setup: function() {
        var d = this.ownerDocument || this,
            e = O.access(d, b);
        e || d.addEventListener(a, c, !0), O.access(d, b, (e || 0) + 1);
      },
      teardown: function() {
        var d = this.ownerDocument || this,
            e = O.access(d, b) - 1;
        e ? O.access(d, b, e) : (d.removeEventListener(a, c, !0), O.remove(d, b));
      }
    };
  }), n.fn.extend({
    on: function(a, b, c, d, e) {
      var f,
          g;
      if ("object" == typeof a) {
        "string" != typeof b && (c = c || b, b = void 0);
        for (g in a)
          this.on(g, b, c, a[g], e);
        return this;
      }
      if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1)
        d = bb;
      else if (!d)
        return this;
      return 1 === e && (f = d, d = function(a) {
        return n().off(a), f.apply(this, arguments);
      }, d.guid = f.guid || (f.guid = n.guid++)), this.each(function() {
        n.event.add(this, a, d, c, b);
      });
    },
    one: function(a, b, c, d) {
      return this.on(a, b, c, d, 1);
    },
    off: function(a, b, c) {
      var d,
          e;
      if (a && a.preventDefault && a.handleObj)
        return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
      if ("object" == typeof a) {
        for (e in a)
          this.off(e, b, a[e]);
        return this;
      }
      return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = bb), this.each(function() {
        n.event.remove(this, a, c, b);
      });
    },
    trigger: function(a, b) {
      return this.each(function() {
        n.event.trigger(a, b, this);
      });
    },
    triggerHandler: function(a, b) {
      var c = this[0];
      return c ? n.event.trigger(a, b, c, !0) : void 0;
    }
  });
  var db = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      eb = /<([\w:]+)/,
      fb = /<|&#?\w+;/,
      gb = /<(?:script|style|link)/i,
      hb = /checked\s*(?:[^=]|=\s*.checked.)/i,
      ib = /^$|\/(?:java|ecma)script/i,
      jb = /^true\/(.*)/,
      kb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      lb = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
  lb.optgroup = lb.option, lb.tbody = lb.tfoot = lb.colgroup = lb.caption = lb.thead, lb.th = lb.td;
  function mb(a, b) {
    return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
  }
  function nb(a) {
    return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a;
  }
  function ob(a) {
    var b = jb.exec(a.type);
    return b ? a.type = b[1] : a.removeAttribute("type"), a;
  }
  function pb(a, b) {
    for (var c = 0,
        d = a.length; d > c; c++)
      O.set(a[c], "globalEval", !b || O.get(b[c], "globalEval"));
  }
  function qb(a, b) {
    var c,
        d,
        e,
        f,
        g,
        h,
        i,
        j;
    if (1 === b.nodeType) {
      if (O.hasData(a) && (f = O.access(a), g = O.set(b, f), j = f.events)) {
        delete g.handle, g.events = {};
        for (e in j)
          for (c = 0, d = j[e].length; d > c; c++)
            n.event.add(b, e, j[e][c]);
      }
      P.hasData(a) && (h = P.access(a), i = n.extend({}, h), P.set(b, i));
    }
  }
  function rb(a, b) {
    var c = a.getElementsByTagName ? a.getElementsByTagName(b || "*") : a.querySelectorAll ? a.querySelectorAll(b || "*") : [];
    return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;
  }
  function sb(a, b) {
    var c = b.nodeName.toLowerCase();
    "input" === c && W.test(a.type) ? b.checked = a.checked : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
  }
  n.extend({
    clone: function(a, b, c) {
      var d,
          e,
          f,
          g,
          h = a.cloneNode(!0),
          i = n.contains(a.ownerDocument, a);
      if (!(k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a)))
        for (g = rb(h), f = rb(a), d = 0, e = f.length; e > d; d++)
          sb(f[d], g[d]);
      if (b)
        if (c)
          for (f = f || rb(a), g = g || rb(h), d = 0, e = f.length; e > d; d++)
            qb(f[d], g[d]);
        else
          qb(a, h);
      return g = rb(h, "script"), g.length > 0 && pb(g, !i && rb(a, "script")), h;
    },
    buildFragment: function(a, b, c, d) {
      for (var e,
          f,
          g,
          h,
          i,
          j,
          k = b.createDocumentFragment(),
          l = [],
          m = 0,
          o = a.length; o > m; m++)
        if (e = a[m], e || 0 === e)
          if ("object" === n.type(e))
            n.merge(l, e.nodeType ? [e] : e);
          else if (fb.test(e)) {
            f = f || k.appendChild(b.createElement("div")), g = (eb.exec(e) || ["", ""])[1].toLowerCase(), h = lb[g] || lb._default, f.innerHTML = h[1] + e.replace(db, "<$1></$2>") + h[2], j = h[0];
            while (j--)
              f = f.lastChild;
            n.merge(l, f.childNodes), f = k.firstChild, f.textContent = "";
          } else
            l.push(b.createTextNode(e));
      k.textContent = "", m = 0;
      while (e = l[m++])
        if ((!d || -1 === n.inArray(e, d)) && (i = n.contains(e.ownerDocument, e), f = rb(k.appendChild(e), "script"), i && pb(f), c)) {
          j = 0;
          while (e = f[j++])
            ib.test(e.type || "") && c.push(e);
        }
      return k;
    },
    cleanData: function(a) {
      for (var b,
          c,
          d,
          e,
          f = n.event.special,
          g = 0; void 0 !== (c = a[g]); g++) {
        if (n.acceptData(c) && (e = c[O.expando], e && (b = O.cache[e]))) {
          if (b.events)
            for (d in b.events)
              f[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);
          O.cache[e] && delete O.cache[e];
        }
        delete P.cache[c[P.expando]];
      }
    }
  }), n.fn.extend({
    text: function(a) {
      return M(this, function(a) {
        return void 0 === a ? n.text(this) : this.empty().each(function() {
          (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a);
        });
      }, null, a, arguments.length);
    },
    append: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = mb(this, a);
          b.appendChild(a);
        }
      });
    },
    prepend: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = mb(this, a);
          b.insertBefore(a, b.firstChild);
        }
      });
    },
    before: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode && this.parentNode.insertBefore(a, this);
      });
    },
    after: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
      });
    },
    remove: function(a, b) {
      for (var c,
          d = a ? n.filter(a, this) : this,
          e = 0; null != (c = d[e]); e++)
        b || 1 !== c.nodeType || n.cleanData(rb(c)), c.parentNode && (b && n.contains(c.ownerDocument, c) && pb(rb(c, "script")), c.parentNode.removeChild(c));
      return this;
    },
    empty: function() {
      for (var a,
          b = 0; null != (a = this[b]); b++)
        1 === a.nodeType && (n.cleanData(rb(a, !1)), a.textContent = "");
      return this;
    },
    clone: function(a, b) {
      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
        return n.clone(this, a, b);
      });
    },
    html: function(a) {
      return M(this, function(a) {
        var b = this[0] || {},
            c = 0,
            d = this.length;
        if (void 0 === a && 1 === b.nodeType)
          return b.innerHTML;
        if ("string" == typeof a && !gb.test(a) && !lb[(eb.exec(a) || ["", ""])[1].toLowerCase()]) {
          a = a.replace(db, "<$1></$2>");
          try {
            for (; d > c; c++)
              b = this[c] || {}, 1 === b.nodeType && (n.cleanData(rb(b, !1)), b.innerHTML = a);
            b = 0;
          } catch (e) {}
        }
        b && this.empty().append(a);
      }, null, a, arguments.length);
    },
    replaceWith: function() {
      var a = arguments[0];
      return this.domManip(arguments, function(b) {
        a = this.parentNode, n.cleanData(rb(this)), a && a.replaceChild(b, this);
      }), a && (a.length || a.nodeType) ? this : this.remove();
    },
    detach: function(a) {
      return this.remove(a, !0);
    },
    domManip: function(a, b) {
      a = e.apply([], a);
      var c,
          d,
          f,
          g,
          h,
          i,
          j = 0,
          l = this.length,
          m = this,
          o = l - 1,
          p = a[0],
          q = n.isFunction(p);
      if (q || l > 1 && "string" == typeof p && !k.checkClone && hb.test(p))
        return this.each(function(c) {
          var d = m.eq(c);
          q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
        });
      if (l && (c = n.buildFragment(a, this[0].ownerDocument, !1, this), d = c.firstChild, 1 === c.childNodes.length && (c = d), d)) {
        for (f = n.map(rb(c, "script"), nb), g = f.length; l > j; j++)
          h = c, j !== o && (h = n.clone(h, !0, !0), g && n.merge(f, rb(h, "script"))), b.call(this[j], h, j);
        if (g)
          for (i = f[f.length - 1].ownerDocument, n.map(f, ob), j = 0; g > j; j++)
            h = f[j], ib.test(h.type || "") && !O.access(h, "globalEval") && n.contains(i, h) && (h.src ? n._evalUrl && n._evalUrl(h.src) : n.globalEval(h.textContent.replace(kb, "")));
      }
      return this;
    }
  }), n.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(a, b) {
    n.fn[a] = function(a) {
      for (var c,
          d = [],
          e = n(a),
          g = e.length - 1,
          h = 0; g >= h; h++)
        c = h === g ? this : this.clone(!0), n(e[h])[b](c), f.apply(d, c.get());
      return this.pushStack(d);
    };
  });
  var tb,
      ub = {};
  function vb(b, c) {
    var d,
        e = n(c.createElement(b)).appendTo(c.body),
        f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : n.css(e[0], "display");
    return e.detach(), f;
  }
  function wb(a) {
    var b = l,
        c = ub[a];
    return c || (c = vb(a, b), "none" !== c && c || (tb = (tb || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = tb[0].contentDocument, b.write(), b.close(), c = vb(a, b), tb.detach()), ub[a] = c), c;
  }
  var xb = /^margin/,
      yb = new RegExp("^(" + T + ")(?!px)[a-z%]+$", "i"),
      zb = function(a) {
        return a.ownerDocument.defaultView.getComputedStyle(a, null);
      };
  function Ab(a, b, c) {
    var d,
        e,
        f,
        g,
        h = a.style;
    return c = c || zb(a), c && (g = c.getPropertyValue(b) || c[b]), c && ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), yb.test(g) && xb.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + "" : g;
  }
  function Bb(a, b) {
    return {get: function() {
        return a() ? void delete this.get : (this.get = b).apply(this, arguments);
      }};
  }
  !function() {
    var b,
        c,
        d = l.documentElement,
        e = l.createElement("div"),
        f = l.createElement("div");
    if (f.style) {
      f.style.backgroundClip = "content-box", f.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === f.style.backgroundClip, e.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", e.appendChild(f);
      function g() {
        f.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", f.innerHTML = "", d.appendChild(e);
        var g = a.getComputedStyle(f, null);
        b = "1%" !== g.top, c = "4px" === g.width, d.removeChild(e);
      }
      a.getComputedStyle && n.extend(k, {
        pixelPosition: function() {
          return g(), b;
        },
        boxSizingReliable: function() {
          return null == c && g(), c;
        },
        reliableMarginRight: function() {
          var b,
              c = f.appendChild(l.createElement("div"));
          return c.style.cssText = f.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", f.style.width = "1px", d.appendChild(e), b = !parseFloat(a.getComputedStyle(c, null).marginRight), d.removeChild(e), b;
        }
      });
    }
  }(), n.swap = function(a, b, c, d) {
    var e,
        f,
        g = {};
    for (f in b)
      g[f] = a.style[f], a.style[f] = b[f];
    e = c.apply(a, d || []);
    for (f in b)
      a.style[f] = g[f];
    return e;
  };
  var Cb = /^(none|table(?!-c[ea]).+)/,
      Db = new RegExp("^(" + T + ")(.*)$", "i"),
      Eb = new RegExp("^([+-])=(" + T + ")", "i"),
      Fb = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      Gb = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      Hb = ["Webkit", "O", "Moz", "ms"];
  function Ib(a, b) {
    if (b in a)
      return b;
    var c = b[0].toUpperCase() + b.slice(1),
        d = b,
        e = Hb.length;
    while (e--)
      if (b = Hb[e] + c, b in a)
        return b;
    return d;
  }
  function Jb(a, b, c) {
    var d = Db.exec(b);
    return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
  }
  function Kb(a, b, c, d, e) {
    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0,
        g = 0; 4 > f; f += 2)
      "margin" === c && (g += n.css(a, c + U[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + U[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e), "padding" !== c && (g += n.css(a, "border" + U[f] + "Width", !0, e)));
    return g;
  }
  function Lb(a, b, c) {
    var d = !0,
        e = "width" === b ? a.offsetWidth : a.offsetHeight,
        f = zb(a),
        g = "border-box" === n.css(a, "boxSizing", !1, f);
    if (0 >= e || null == e) {
      if (e = Ab(a, b, f), (0 > e || null == e) && (e = a.style[b]), yb.test(e))
        return e;
      d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
    }
    return e + Kb(a, b, c || (g ? "border" : "content"), d, f) + "px";
  }
  function Mb(a, b) {
    for (var c,
        d,
        e,
        f = [],
        g = 0,
        h = a.length; h > g; g++)
      d = a[g], d.style && (f[g] = O.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && V(d) && (f[g] = O.access(d, "olddisplay", wb(d.nodeName)))) : (e = V(d), "none" === c && e || O.set(d, "olddisplay", e ? c : n.css(d, "display"))));
    for (g = 0; h > g; g++)
      d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
    return a;
  }
  n.extend({
    cssHooks: {opacity: {get: function(a, b) {
          if (b) {
            var c = Ab(a, "opacity");
            return "" === c ? "1" : c;
          }
        }}},
    cssNumber: {
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {float: "cssFloat"},
    style: function(a, b, c, d) {
      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
        var e,
            f,
            g,
            h = n.camelCase(b),
            i = a.style;
        return b = n.cssProps[h] || (n.cssProps[h] = Ib(i, h)), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, "string" === f && (e = Eb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)), f = "number"), null != c && c === c && ("number" !== f || n.cssNumber[h] || (c += "px"), k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);
      }
    },
    css: function(a, b, c, d) {
      var e,
          f,
          g,
          h = n.camelCase(b);
      return b = n.cssProps[h] || (n.cssProps[h] = Ib(a.style, h)), g = n.cssHooks[b] || n.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Ab(a, b, d)), "normal" === e && b in Gb && (e = Gb[b]), "" === c || c ? (f = parseFloat(e), c === !0 || n.isNumeric(f) ? f || 0 : e) : e;
    }
  }), n.each(["height", "width"], function(a, b) {
    n.cssHooks[b] = {
      get: function(a, c, d) {
        return c ? Cb.test(n.css(a, "display")) && 0 === a.offsetWidth ? n.swap(a, Fb, function() {
          return Lb(a, b, d);
        }) : Lb(a, b, d) : void 0;
      },
      set: function(a, c, d) {
        var e = d && zb(a);
        return Jb(a, c, d ? Kb(a, b, d, "border-box" === n.css(a, "boxSizing", !1, e), e) : 0);
      }
    };
  }), n.cssHooks.marginRight = Bb(k.reliableMarginRight, function(a, b) {
    return b ? n.swap(a, {display: "inline-block"}, Ab, [a, "marginRight"]) : void 0;
  }), n.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(a, b) {
    n.cssHooks[a + b] = {expand: function(c) {
        for (var d = 0,
            e = {},
            f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++)
          e[a + U[d] + b] = f[d] || f[d - 2] || f[0];
        return e;
      }}, xb.test(a) || (n.cssHooks[a + b].set = Jb);
  }), n.fn.extend({
    css: function(a, b) {
      return M(this, function(a, b, c) {
        var d,
            e,
            f = {},
            g = 0;
        if (n.isArray(b)) {
          for (d = zb(a), e = b.length; e > g; g++)
            f[b[g]] = n.css(a, b[g], !1, d);
          return f;
        }
        return void 0 !== c ? n.style(a, b, c) : n.css(a, b);
      }, a, b, arguments.length > 1);
    },
    show: function() {
      return Mb(this, !0);
    },
    hide: function() {
      return Mb(this);
    },
    toggle: function(a) {
      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
        V(this) ? n(this).show() : n(this).hide();
      });
    }
  });
  function Nb(a, b, c, d, e) {
    return new Nb.prototype.init(a, b, c, d, e);
  }
  n.Tween = Nb, Nb.prototype = {
    constructor: Nb,
    init: function(a, b, c, d, e, f) {
      this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px");
    },
    cur: function() {
      var a = Nb.propHooks[this.prop];
      return a && a.get ? a.get(this) : Nb.propHooks._default.get(this);
    },
    run: function(a) {
      var b,
          c = Nb.propHooks[this.prop];
      return this.pos = b = this.options.duration ? n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Nb.propHooks._default.set(this), this;
    }
  }, Nb.prototype.init.prototype = Nb.prototype, Nb.propHooks = {_default: {
      get: function(a) {
        var b;
        return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) : a.elem[a.prop];
      },
      set: function(a) {
        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop]) ? n.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
      }
    }}, Nb.propHooks.scrollTop = Nb.propHooks.scrollLeft = {set: function(a) {
      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
    }}, n.easing = {
    linear: function(a) {
      return a;
    },
    swing: function(a) {
      return .5 - Math.cos(a * Math.PI) / 2;
    }
  }, n.fx = Nb.prototype.init, n.fx.step = {};
  var Ob,
      Pb,
      Qb = /^(?:toggle|show|hide)$/,
      Rb = new RegExp("^(?:([+-])=|)(" + T + ")([a-z%]*)$", "i"),
      Sb = /queueHooks$/,
      Tb = [Yb],
      Ub = {"*": [function(a, b) {
          var c = this.createTween(a, b),
              d = c.cur(),
              e = Rb.exec(b),
              f = e && e[3] || (n.cssNumber[a] ? "" : "px"),
              g = (n.cssNumber[a] || "px" !== f && +d) && Rb.exec(n.css(c.elem, a)),
              h = 1,
              i = 20;
          if (g && g[3] !== f) {
            f = f || g[3], e = e || [], g = +d || 1;
            do
              h = h || ".5", g /= h, n.style(c.elem, a, g + f);
 while (h !== (h = c.cur() / d) && 1 !== h && --i);
          }
          return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c;
        }]};
  function Vb() {
    return setTimeout(function() {
      Ob = void 0;
    }), Ob = n.now();
  }
  function Wb(a, b) {
    var c,
        d = 0,
        e = {height: a};
    for (b = b ? 1 : 0; 4 > d; d += 2 - b)
      c = U[d], e["margin" + c] = e["padding" + c] = a;
    return b && (e.opacity = e.width = a), e;
  }
  function Xb(a, b, c) {
    for (var d,
        e = (Ub[b] || []).concat(Ub["*"]),
        f = 0,
        g = e.length; g > f; f++)
      if (d = e[f].call(c, b, a))
        return d;
  }
  function Yb(a, b, c) {
    var d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l = this,
        m = {},
        o = a.style,
        p = a.nodeType && V(a),
        q = O.get(a, "fxshow");
    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {
      h.unqueued || i();
    }), h.unqueued++, l.always(function() {
      l.always(function() {
        h.unqueued--, n.queue(a, "fx").length || h.empty.fire();
      });
    })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, "display"), k = "none" === j ? O.get(a, "olddisplay") || wb(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always(function() {
      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];
    }));
    for (d in b)
      if (e = b[d], Qb.exec(e)) {
        if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
          if ("show" !== e || !q || void 0 === q[d])
            continue;
          p = !0;
        }
        m[d] = q && q[d] || n.style(a, d);
      } else
        j = void 0;
    if (n.isEmptyObject(m))
      "inline" === ("none" === j ? wb(a.nodeName) : j) && (o.display = j);
    else {
      q ? "hidden" in q && (p = q.hidden) : q = O.access(a, "fxshow", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function() {
        n(a).hide();
      }), l.done(function() {
        var b;
        O.remove(a, "fxshow");
        for (b in m)
          n.style(a, b, m[b]);
      });
      for (d in m)
        g = Xb(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0));
    }
  }
  function Zb(a, b) {
    var c,
        d,
        e,
        f,
        g;
    for (c in a)
      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand" in g) {
        f = g.expand(f), delete a[d];
        for (c in f)
          c in a || (a[c] = f[c], b[c] = e);
      } else
        b[d] = e;
  }
  function $b(a, b, c) {
    var d,
        e,
        f = 0,
        g = Tb.length,
        h = n.Deferred().always(function() {
          delete i.elem;
        }),
        i = function() {
          if (e)
            return !1;
          for (var b = Ob || Vb(),
              c = Math.max(0, j.startTime + j.duration - b),
              d = c / j.duration || 0,
              f = 1 - d,
              g = 0,
              i = j.tweens.length; i > g; g++)
            j.tweens[g].run(f);
          return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);
        },
        j = h.promise({
          elem: a,
          props: n.extend({}, b),
          opts: n.extend(!0, {specialEasing: {}}, c),
          originalProperties: b,
          originalOptions: c,
          startTime: Ob || Vb(),
          duration: c.duration,
          tweens: [],
          createTween: function(b, c) {
            var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
            return j.tweens.push(d), d;
          },
          stop: function(b) {
            var c = 0,
                d = b ? j.tweens.length : 0;
            if (e)
              return this;
            for (e = !0; d > c; c++)
              j.tweens[c].run(1);
            return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this;
          }
        }),
        k = j.props;
    for (Zb(k, j.opts.specialEasing); g > f; f++)
      if (d = Tb[f].call(j, a, k, j.opts))
        return d;
    return n.map(k, Xb, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
      elem: a,
      anim: j,
      queue: j.opts.queue
    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
  }
  n.Animation = n.extend($b, {
    tweener: function(a, b) {
      n.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");
      for (var c,
          d = 0,
          e = a.length; e > d; d++)
        c = a[d], Ub[c] = Ub[c] || [], Ub[c].unshift(b);
    },
    prefilter: function(a, b) {
      b ? Tb.unshift(a) : Tb.push(a);
    }
  }), n.speed = function(a, b, c) {
    var d = a && "object" == typeof a ? n.extend({}, a) : {
      complete: c || !c && b || n.isFunction(a) && a,
      duration: a,
      easing: c && b || b && !n.isFunction(b) && b
    };
    return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function() {
      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);
    }, d;
  }, n.fn.extend({
    fadeTo: function(a, b, c, d) {
      return this.filter(V).css("opacity", 0).show().end().animate({opacity: b}, a, c, d);
    },
    animate: function(a, b, c, d) {
      var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function() {
            var b = $b(this, n.extend({}, a), f);
            (e || O.get(this, "finish")) && b.stop(!0);
          };
      return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);
    },
    stop: function(a, b, c) {
      var d = function(a) {
        var b = a.stop;
        delete a.stop, b(c);
      };
      return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function() {
        var b = !0,
            e = null != a && a + "queueHooks",
            f = n.timers,
            g = O.get(this);
        if (e)
          g[e] && g[e].stop && d(g[e]);
        else
          for (e in g)
            g[e] && g[e].stop && Sb.test(e) && d(g[e]);
        for (e = f.length; e--; )
          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
        (b || !c) && n.dequeue(this, a);
      });
    },
    finish: function(a) {
      return a !== !1 && (a = a || "fx"), this.each(function() {
        var b,
            c = O.get(this),
            d = c[a + "queue"],
            e = c[a + "queueHooks"],
            f = n.timers,
            g = d ? d.length : 0;
        for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--; )
          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
        for (b = 0; g > b; b++)
          d[b] && d[b].finish && d[b].finish.call(this);
        delete c.finish;
      });
    }
  }), n.each(["toggle", "show", "hide"], function(a, b) {
    var c = n.fn[b];
    n.fn[b] = function(a, d, e) {
      return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Wb(b, !0), a, d, e);
    };
  }), n.each({
    slideDown: Wb("show"),
    slideUp: Wb("hide"),
    slideToggle: Wb("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(a, b) {
    n.fn[a] = function(a, c, d) {
      return this.animate(b, a, c, d);
    };
  }), n.timers = [], n.fx.tick = function() {
    var a,
        b = 0,
        c = n.timers;
    for (Ob = n.now(); b < c.length; b++)
      a = c[b], a() || c[b] !== a || c.splice(b--, 1);
    c.length || n.fx.stop(), Ob = void 0;
  }, n.fx.timer = function(a) {
    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();
  }, n.fx.interval = 13, n.fx.start = function() {
    Pb || (Pb = setInterval(n.fx.tick, n.fx.interval));
  }, n.fx.stop = function() {
    clearInterval(Pb), Pb = null;
  }, n.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  }, n.fn.delay = function(a, b) {
    return a = n.fx ? n.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
      var d = setTimeout(b, a);
      c.stop = function() {
        clearTimeout(d);
      };
    });
  }, function() {
    var a = l.createElement("input"),
        b = l.createElement("select"),
        c = b.appendChild(l.createElement("option"));
    a.type = "checkbox", k.checkOn = "" !== a.value, k.optSelected = c.selected, b.disabled = !0, k.optDisabled = !c.disabled, a = l.createElement("input"), a.value = "t", a.type = "radio", k.radioValue = "t" === a.value;
  }();
  var _b,
      ac,
      bc = n.expr.attrHandle;
  n.fn.extend({
    attr: function(a, b) {
      return M(this, n.attr, a, b, arguments.length > 1);
    },
    removeAttr: function(a) {
      return this.each(function() {
        n.removeAttr(this, a);
      });
    }
  }), n.extend({
    attr: function(a, b, c) {
      var d,
          e,
          f = a.nodeType;
      if (a && 3 !== f && 8 !== f && 2 !== f)
        return typeof a.getAttribute === X ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ac : _b)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void n.removeAttr(a, b));
    },
    removeAttr: function(a, b) {
      var c,
          d,
          e = 0,
          f = b && b.match(H);
      if (f && 1 === a.nodeType)
        while (c = f[e++])
          d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);
    },
    attrHooks: {type: {set: function(a, b) {
          if (!k.radioValue && "radio" === b && n.nodeName(a, "input")) {
            var c = a.value;
            return a.setAttribute("type", b), c && (a.value = c), b;
          }
        }}}
  }), ac = {set: function(a, b, c) {
      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;
    }}, n.each(n.expr.match.bool.source.match(/\w+/g), function(a, b) {
    var c = bc[b] || n.find.attr;
    bc[b] = function(a, b, d) {
      var e,
          f;
      return d || (f = bc[b], bc[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bc[b] = f), e;
    };
  });
  var cc = /^(?:input|select|textarea|button)$/i;
  n.fn.extend({
    prop: function(a, b) {
      return M(this, n.prop, a, b, arguments.length > 1);
    },
    removeProp: function(a) {
      return this.each(function() {
        delete this[n.propFix[a] || a];
      });
    }
  }), n.extend({
    propFix: {
      for: "htmlFor",
      class: "className"
    },
    prop: function(a, b, c) {
      var d,
          e,
          f,
          g = a.nodeType;
      if (a && 3 !== g && 8 !== g && 2 !== g)
        return f = 1 !== g || !n.isXMLDoc(a), f && (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];
    },
    propHooks: {tabIndex: {get: function(a) {
          return a.hasAttribute("tabindex") || cc.test(a.nodeName) || a.href ? a.tabIndex : -1;
        }}}
  }), k.optSelected || (n.propHooks.selected = {get: function(a) {
      var b = a.parentNode;
      return b && b.parentNode && b.parentNode.selectedIndex, null;
    }}), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    n.propFix[this.toLowerCase()] = this;
  });
  var dc = /[\t\r\n\f]/g;
  n.fn.extend({
    addClass: function(a) {
      var b,
          c,
          d,
          e,
          f,
          g,
          h = "string" == typeof a && a,
          i = 0,
          j = this.length;
      if (n.isFunction(a))
        return this.each(function(b) {
          n(this).addClass(a.call(this, b, this.className));
        });
      if (h)
        for (b = (a || "").match(H) || []; j > i; i++)
          if (c = this[i], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(dc, " ") : " ")) {
            f = 0;
            while (e = b[f++])
              d.indexOf(" " + e + " ") < 0 && (d += e + " ");
            g = n.trim(d), c.className !== g && (c.className = g);
          }
      return this;
    },
    removeClass: function(a) {
      var b,
          c,
          d,
          e,
          f,
          g,
          h = 0 === arguments.length || "string" == typeof a && a,
          i = 0,
          j = this.length;
      if (n.isFunction(a))
        return this.each(function(b) {
          n(this).removeClass(a.call(this, b, this.className));
        });
      if (h)
        for (b = (a || "").match(H) || []; j > i; i++)
          if (c = this[i], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(dc, " ") : "")) {
            f = 0;
            while (e = b[f++])
              while (d.indexOf(" " + e + " ") >= 0)
                d = d.replace(" " + e + " ", " ");
            g = a ? n.trim(d) : "", c.className !== g && (c.className = g);
          }
      return this;
    },
    toggleClass: function(a, b) {
      var c = typeof a;
      return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function(c) {
        n(this).toggleClass(a.call(this, c, this.className, b), b);
      } : function() {
        if ("string" === c) {
          var b,
              d = 0,
              e = n(this),
              f = a.match(H) || [];
          while (b = f[d++])
            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
        } else
          (c === X || "boolean" === c) && (this.className && O.set(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : O.get(this, "__className__") || "");
      });
    },
    hasClass: function(a) {
      for (var b = " " + a + " ",
          c = 0,
          d = this.length; d > c; c++)
        if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(dc, " ").indexOf(b) >= 0)
          return !0;
      return !1;
    }
  });
  var ec = /\r/g;
  n.fn.extend({val: function(a) {
      var b,
          c,
          d,
          e = this[0];
      {
        if (arguments.length)
          return d = n.isFunction(a), this.each(function(c) {
            var e;
            1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function(a) {
              return null == a ? "" : a + "";
            })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
          });
        if (e)
          return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(ec, "") : null == c ? "" : c);
      }
    }}), n.extend({valHooks: {
      option: {get: function(a) {
          var b = n.find.attr(a, "value");
          return null != b ? b : n.trim(n.text(a));
        }},
      select: {
        get: function(a) {
          for (var b,
              c,
              d = a.options,
              e = a.selectedIndex,
              f = "select-one" === a.type || 0 > e,
              g = f ? null : [],
              h = f ? e + 1 : d.length,
              i = 0 > e ? h : f ? e : 0; h > i; i++)
            if (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && n.nodeName(c.parentNode, "optgroup"))) {
              if (b = n(c).val(), f)
                return b;
              g.push(b);
            }
          return g;
        },
        set: function(a, b) {
          var c,
              d,
              e = a.options,
              f = n.makeArray(b),
              g = e.length;
          while (g--)
            d = e[g], (d.selected = n.inArray(d.value, f) >= 0) && (c = !0);
          return c || (a.selectedIndex = -1), f;
        }
      }
    }}), n.each(["radio", "checkbox"], function() {
    n.valHooks[this] = {set: function(a, b) {
        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) >= 0 : void 0;
      }}, k.checkOn || (n.valHooks[this].get = function(a) {
      return null === a.getAttribute("value") ? "on" : a.value;
    });
  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
    n.fn[b] = function(a, c) {
      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
    };
  }), n.fn.extend({
    hover: function(a, b) {
      return this.mouseenter(a).mouseleave(b || a);
    },
    bind: function(a, b, c) {
      return this.on(a, null, b, c);
    },
    unbind: function(a, b) {
      return this.off(a, null, b);
    },
    delegate: function(a, b, c, d) {
      return this.on(b, a, c, d);
    },
    undelegate: function(a, b, c) {
      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
    }
  });
  var fc = n.now(),
      gc = /\?/;
  n.parseJSON = function(a) {
    return JSON.parse(a + "");
  }, n.parseXML = function(a) {
    var b,
        c;
    if (!a || "string" != typeof a)
      return null;
    try {
      c = new DOMParser, b = c.parseFromString(a, "text/xml");
    } catch (d) {
      b = void 0;
    }
    return (!b || b.getElementsByTagName("parsererror").length) && n.error("Invalid XML: " + a), b;
  };
  var hc,
      ic,
      jc = /#.*$/,
      kc = /([?&])_=[^&]*/,
      lc = /^(.*?):[ \t]*([^\r\n]*)$/gm,
      mc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      nc = /^(?:GET|HEAD)$/,
      oc = /^\/\//,
      pc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
      qc = {},
      rc = {},
      sc = "*/".concat("*");
  try {
    ic = location.href;
  } catch (tc) {
    ic = l.createElement("a"), ic.href = "", ic = ic.href;
  }
  hc = pc.exec(ic.toLowerCase()) || [];
  function uc(a) {
    return function(b, c) {
      "string" != typeof b && (c = b, b = "*");
      var d,
          e = 0,
          f = b.toLowerCase().match(H) || [];
      if (n.isFunction(c))
        while (d = f[e++])
          "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
    };
  }
  function vc(a, b, c, d) {
    var e = {},
        f = a === rc;
    function g(h) {
      var i;
      return e[h] = !0, n.each(a[h] || [], function(a, h) {
        var j = h(b, c, d);
        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);
      }), i;
    }
    return g(b.dataTypes[0]) || !e["*"] && g("*");
  }
  function wc(a, b) {
    var c,
        d,
        e = n.ajaxSettings.flatOptions || {};
    for (c in b)
      void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
    return d && n.extend(!0, a, d), a;
  }
  function xc(a, b, c) {
    var d,
        e,
        f,
        g,
        h = a.contents,
        i = a.dataTypes;
    while ("*" === i[0])
      i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
    if (d)
      for (e in h)
        if (h[e] && h[e].test(d)) {
          i.unshift(e);
          break;
        }
    if (i[0] in c)
      f = i[0];
    else {
      for (e in c) {
        if (!i[0] || a.converters[e + " " + i[0]]) {
          f = e;
          break;
        }
        g || (g = e);
      }
      f = f || g;
    }
    return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
  }
  function yc(a, b, c, d) {
    var e,
        f,
        g,
        h,
        i,
        j = {},
        k = a.dataTypes.slice();
    if (k[1])
      for (g in a.converters)
        j[g.toLowerCase()] = a.converters[g];
    f = k.shift();
    while (f)
      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
        if ("*" === f)
          f = i;
        else if ("*" !== i && i !== f) {
          if (g = j[i + " " + f] || j["* " + f], !g)
            for (e in j)
              if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                break;
              }
          if (g !== !0)
            if (g && a["throws"])
              b = g(b);
            else
              try {
                b = g(b);
              } catch (l) {
                return {
                  state: "parsererror",
                  error: g ? l : "No conversion from " + i + " to " + f
                };
              }
        }
    return {
      state: "success",
      data: b
    };
  }
  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ic,
      type: "GET",
      isLocal: mc.test(hc[1]),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": sc,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function(a, b) {
      return b ? wc(wc(a, n.ajaxSettings), b) : wc(n.ajaxSettings, a);
    },
    ajaxPrefilter: uc(qc),
    ajaxTransport: uc(rc),
    ajax: function(a, b) {
      "object" == typeof a && (b = a, a = void 0), b = b || {};
      var c,
          d,
          e,
          f,
          g,
          h,
          i,
          j,
          k = n.ajaxSetup({}, b),
          l = k.context || k,
          m = k.context && (l.nodeType || l.jquery) ? n(l) : n.event,
          o = n.Deferred(),
          p = n.Callbacks("once memory"),
          q = k.statusCode || {},
          r = {},
          s = {},
          t = 0,
          u = "canceled",
          v = {
            readyState: 0,
            getResponseHeader: function(a) {
              var b;
              if (2 === t) {
                if (!f) {
                  f = {};
                  while (b = lc.exec(e))
                    f[b[1].toLowerCase()] = b[2];
                }
                b = f[a.toLowerCase()];
              }
              return null == b ? null : b;
            },
            getAllResponseHeaders: function() {
              return 2 === t ? e : null;
            },
            setRequestHeader: function(a, b) {
              var c = a.toLowerCase();
              return t || (a = s[c] = s[c] || a, r[a] = b), this;
            },
            overrideMimeType: function(a) {
              return t || (k.mimeType = a), this;
            },
            statusCode: function(a) {
              var b;
              if (a)
                if (2 > t)
                  for (b in a)
                    q[b] = [q[b], a[b]];
                else
                  v.always(a[v.status]);
              return this;
            },
            abort: function(a) {
              var b = a || u;
              return c && c.abort(b), x(0, b), this;
            }
          };
      if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || ic) + "").replace(jc, "").replace(oc, hc[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim(k.dataType || "*").toLowerCase().match(H) || [""], null == k.crossDomain && (h = pc.exec(k.url.toLowerCase()), k.crossDomain = !(!h || h[1] === hc[1] && h[2] === hc[2] && (h[3] || ("http:" === h[1] ? "80" : "443")) === (hc[3] || ("http:" === hc[1] ? "80" : "443")))), k.data && k.processData && "string" != typeof k.data && (k.data = n.param(k.data, k.traditional)), vc(qc, k, b, v), 2 === t)
        return v;
      i = k.global, i && 0 === n.active++ && n.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !nc.test(k.type), d = k.url, k.hasContent || (k.data && (d = k.url += (gc.test(d) ? "&" : "?") + k.data, delete k.data), k.cache === !1 && (k.url = kc.test(d) ? d.replace(kc, "$1_=" + fc++) : d + (gc.test(d) ? "&" : "?") + "_=" + fc++)), k.ifModified && (n.lastModified[d] && v.setRequestHeader("If-Modified-Since", n.lastModified[d]), n.etag[d] && v.setRequestHeader("If-None-Match", n.etag[d])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + sc + "; q=0.01" : "") : k.accepts["*"]);
      for (j in k.headers)
        v.setRequestHeader(j, k.headers[j]);
      if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t))
        return v.abort();
      u = "abort";
      for (j in {
        success: 1,
        error: 1,
        complete: 1
      })
        v[j](k[j]);
      if (c = vc(rc, k, b, v)) {
        v.readyState = 1, i && m.trigger("ajaxSend", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function() {
          v.abort("timeout");
        }, k.timeout));
        try {
          t = 1, c.send(r, x);
        } catch (w) {
          if (!(2 > t))
            throw w;
          x(-1, w);
        }
      } else
        x(-1, "No Transport");
      function x(a, b, f, h) {
        var j,
            r,
            s,
            u,
            w,
            x = b;
        2 !== t && (t = 2, g && clearTimeout(g), c = void 0, e = h || "", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, f && (u = xc(k, v, f)), u = yc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (n.lastModified[d] = w), w = v.getResponseHeader("etag"), w && (n.etag[d] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, i && m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), i && (m.trigger("ajaxComplete", [v, k]), --n.active || n.event.trigger("ajaxStop")));
      }
      return v;
    },
    getJSON: function(a, b, c) {
      return n.get(a, b, c, "json");
    },
    getScript: function(a, b) {
      return n.get(a, void 0, b, "script");
    }
  }), n.each(["get", "post"], function(a, b) {
    n[b] = function(a, c, d, e) {
      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax({
        url: a,
        type: b,
        dataType: e,
        data: c,
        success: d
      });
    };
  }), n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
    n.fn[b] = function(a) {
      return this.on(b, a);
    };
  }), n._evalUrl = function(a) {
    return n.ajax({
      url: a,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      throws: !0
    });
  };
  var zc = /%20/g,
      Ac = /\[\]$/,
      Bc = /\r?\n/g,
      Cc = /^(?:submit|button|image|reset|file)$/i,
      Dc = /^(?:input|select|textarea|keygen)/i;
  function Ec(a, b, c, d) {
    var e;
    if (n.isArray(b))
      n.each(b, function(b, e) {
        c || Ac.test(a) ? d(a, e) : Ec(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
      });
    else if (c || "object" !== n.type(b))
      d(a, b);
    else
      for (e in b)
        Ec(a + "[" + e + "]", b[e], c, d);
  }
  n.param = function(a, b) {
    var c,
        d = [],
        e = function(a, b) {
          b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
        };
    if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a))
      n.each(a, function() {
        e(this.name, this.value);
      });
    else
      for (c in a)
        Ec(c, a[c], b, e);
    return d.join("&").replace(zc, "+");
  }, n.fn.extend({
    serialize: function() {
      return n.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var a = n.prop(this, "elements");
        return a ? n.makeArray(a) : this;
      }).filter(function() {
        var a = this.type;
        return this.name && !n(this).is(":disabled") && Dc.test(this.nodeName) && !Cc.test(a) && (this.checked || !W.test(a));
      }).map(function(a, b) {
        var c = n(this).val();
        return null == c ? null : n.isArray(c) ? n.map(c, function(a) {
          return {
            name: b.name,
            value: a.replace(Bc, "\r\n")
          };
        }) : {
          name: b.name,
          value: c.replace(Bc, "\r\n")
        };
      }).get();
    }
  }), n.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest;
    } catch (a) {}
  };
  var Fc = 0,
      Gc = {},
      Hc = {
        0: 200,
        1223: 204
      },
      Ic = n.ajaxSettings.xhr();
  a.ActiveXObject && n(a).on("unload", function() {
    for (var a in Gc)
      Gc[a]();
  }), k.cors = !!Ic && "withCredentials" in Ic, k.ajax = Ic = !!Ic, n.ajaxTransport(function(a) {
    var b;
    return k.cors || Ic && !a.crossDomain ? {
      send: function(c, d) {
        var e,
            f = a.xhr(),
            g = ++Fc;
        if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)
          for (e in a.xhrFields)
            f[e] = a.xhrFields[e];
        a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
        for (e in c)
          f.setRequestHeader(e, c[e]);
        b = function(a) {
          return function() {
            b && (delete Gc[g], b = f.onload = f.onerror = null, "abort" === a ? f.abort() : "error" === a ? d(f.status, f.statusText) : d(Hc[f.status] || f.status, f.statusText, "string" == typeof f.responseText ? {text: f.responseText} : void 0, f.getAllResponseHeaders()));
          };
        }, f.onload = b(), f.onerror = b("error"), b = Gc[g] = b("abort");
        try {
          f.send(a.hasContent && a.data || null);
        } catch (h) {
          if (b)
            throw h;
        }
      },
      abort: function() {
        b && b();
      }
    } : void 0;
  }), n.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
    contents: {script: /(?:java|ecma)script/},
    converters: {"text script": function(a) {
        return n.globalEval(a), a;
      }}
  }), n.ajaxPrefilter("script", function(a) {
    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET");
  }), n.ajaxTransport("script", function(a) {
    if (a.crossDomain) {
      var b,
          c;
      return {
        send: function(d, e) {
          b = n("<script>").prop({
            async: !0,
            charset: a.scriptCharset,
            src: a.url
          }).on("load error", c = function(a) {
            b.remove(), c = null, a && e("error" === a.type ? 404 : 200, a.type);
          }), l.head.appendChild(b[0]);
        },
        abort: function() {
          c && c();
        }
      };
    }
  });
  var Jc = [],
      Kc = /(=)\?(?=&|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var a = Jc.pop() || n.expando + "_" + fc++;
      return this[a] = !0, a;
    }
  }), n.ajaxPrefilter("json jsonp", function(b, c, d) {
    var e,
        f,
        g,
        h = b.jsonp !== !1 && (Kc.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && Kc.test(b.data) && "data");
    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kc, "$1" + e) : b.jsonp !== !1 && (b.url += (gc.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
      return g || n.error(e + " was not called"), g[0];
    }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
      g = arguments;
    }, d.always(function() {
      a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jc.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;
    }), "script") : void 0;
  }), n.parseHTML = function(a, b, c) {
    if (!a || "string" != typeof a)
      return null;
    "boolean" == typeof b && (c = b, b = !1), b = b || l;
    var d = y.exec(a),
        e = !c && [];
    return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e), e && e.length && n(e).remove(), n.merge([], d.childNodes));
  };
  var Lc = n.fn.load;
  n.fn.load = function(a, b, c) {
    if ("string" != typeof a && Lc)
      return Lc.apply(this, arguments);
    var d,
        e,
        f,
        g = this,
        h = a.indexOf(" ");
    return h >= 0 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && n.ajax({
      url: a,
      type: e,
      dataType: "html",
      data: b
    }).done(function(a) {
      f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a);
    }).complete(c && function(a, b) {
      g.each(c, f || [a.responseText, b, a]);
    }), this;
  }, "function" == typeof define && define.amd && define("assets/lib/jquery/jquery-css-ajax-effects.min.js", [], function() {
    return n;
  });
  var Mc = a.jQuery,
      Nc = a.$;
  return n.noConflict = function(b) {
    return a.$ === n && (a.$ = Nc), b && a.jQuery === n && (a.jQuery = Mc), n;
  }, typeof b === X && (a.jQuery = a.$ = n), n;
});

_removeDefine();
})();
System.register('components/map/UIs/default/default.js', ['npm:babel-runtime@5.8.24/helpers/get.js', 'npm:babel-runtime@5.8.24/helpers/inherits.js', 'npm:babel-runtime@5.8.24/helpers/create-class.js', 'npm:babel-runtime@5.8.24/helpers/class-call-check.js', 'assets/lib/jquery/jquery-css-ajax-effects.min.js', 'components/map/UIs/default/layout/templates.js', 'components/map/extensions/hexagons/utils/createHexagon.js', 'bundles/coreBundle.js'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, $, templates, createVisibleHexagon, UI_templateBase, UI, FADE_ANIMATION, cssClasses, $elements, UI_default;

  /*----------------------
  ------- PRIVATE --------
  ----------------------*/
  /**
   * @private
   * @static
   * @method _get$Element
   * @param  {[type]} which [description]
   * @return {[type]}       [description]
   */
  function _get$Element(which) {
    /* Set the jQuery element to collection only once */
    if (!$elements[which]) {
      var $element = $(cssClasses[which]);
      $elements[which] = $element;
    }

    return $elements[which];
  }
  return {
    setters: [function (_npmBabelRuntime5824HelpersGetJs) {
      _get = _npmBabelRuntime5824HelpersGetJs['default'];
    }, function (_npmBabelRuntime5824HelpersInheritsJs) {
      _inherits = _npmBabelRuntime5824HelpersInheritsJs['default'];
    }, function (_npmBabelRuntime5824HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5824HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs['default'];
    }, function (_assetsLibJqueryJqueryCssAjaxEffectsMinJs) {
      $ = _assetsLibJqueryJqueryCssAjaxEffectsMinJs['default'];
    }, function (_componentsMapUIsDefaultLayoutTemplatesJs) {
      templates = _componentsMapUIsDefaultLayoutTemplatesJs.templates;
    }, function (_componentsMapExtensionsHexagonsUtilsCreateHexagonJs) {
      createVisibleHexagon = _componentsMapExtensionsHexagonsUtilsCreateHexagonJs.createVisibleHexagon;
    }, function (_bundlesCoreBundleJs) {
      UI_templateBase = _bundlesCoreBundleJs.UI_templateBase;
      UI = _bundlesCoreBundleJs.UI;
    }],
    execute: function () {
      /* global $ */

      //import { drawShapes } from 'components/map/UIs/default/utils/arrows';

      /*---------------------
      ------ VARIABLES ------
      ----------------------*/
      'use strict';

      /*---------------------
      ------- IMPORT --------
      ----------------------*/
      FADE_ANIMATION = "slow";
      cssClasses = {
        select: "#dialog_select"
      };
      $elements = {};

      /*---------------------
      --------- API ---------
      ----------------------*/

      UI_default = (function (_UI_templateBase) {
        _inherits(UI_default, _UI_templateBase);

        /**
         * The simplest default UI implementation. Implemented UI functionalities for: showSelections, highlightSelectedObject
         *
         * @class UI_default
         * @constructor
         * @requires Handlebars
         * @requires jQuery
         * @todo  should take jQuery away from this, as soon as we refactor the animations and graphics for selections
         * @param  {HTMLElement} modal
         * @param  {Map} map
         * @param  {Object} options
         */

        function UI_default(modal, map) {
          var options = arguments.length <= 2 || arguments[2] === undefined ? { styles: "#F0F0F0" } : arguments[2];

          _classCallCheck(this, UI_default);

          _get(Object.getPrototypeOf(UI_default.prototype), 'constructor', this).call(this, cssClasses);
          // Add a media (and/or media query) here if you'd like!
          // style.setAttribute("media", "screen")
          // style.setAttribute("media", "only screen and (max-width : 1024px)")

          this.map = map;
          this.modal = modal || document.getElementById("dialog_select");
          this.styles = options.styles;
        }

        /**
         * @method getTemplates
         * Required by the map/core/UI.js API
         */

        _createClass(UI_default, [{
          key: 'getTemplates',
          value: function getTemplates() {
            return templates;
          }

          /**
           * Required by the map.UI API
           *
           * @method showSelections
           * @param  {Object} objects     Objects that have been selected. See core.UI for more information
           * @param {Object} getDatas       See explanation in core.UI
           * @param {Object} options        Extra options
           */
        }, {
          key: 'showSelections',
          value: function showSelections(objects, getDatas, options) {
            var _this = this;

            var updateCB = this.map.drawOnNextTick.bind(this.map);
            var UILayer = this.map.getMovableLayer();
            var cb;

            /* We add the objects to be highlighted to the correct UI layer */
            //objectsToUI(UILayer, objects);

            if (objects && objects.length > 1) {
              cb = function () {
                _this.modal.innerHTML = templates.multiSelection({
                  title: "Objects",
                  objects: objects
                });

                _this.showModal(_this.modal, cssClasses);

                console.log(objects);

                _get$Element("select").fadeIn(FADE_ANIMATION);
              };
            } else if (objects.length === 1) {
              cb = function () {
                _this.highlightSelectedObject(objects[0]);

                console.log(objects);
              };
            } else {
              cb = function () {
                UILayer.emptyUIObjects();
                updateCB();
                console.log("Error occured selecting the objects on this coordinates! Nothing found");
              };
            }

            _get$Element("select").fadeOut(FADE_ANIMATION, cb);
          }

          /**
           * Required by the map.UI API
           *
           * @method highlightSelectedObject
           * @param  {Object} object        Object that has been selected. See core.UI for more information
           * @param {Object} getDatas       See explanation in core.UI
           * @param {Object} options        Extra options. Like dropping a shadow etc.
           */
        }, {
          key: 'highlightSelectedObject',
          value: function highlightSelectedObject(object, getDatas) {
            var options = arguments.length <= 2 || arguments[2] === undefined ? { shadow: { color: "0x0000", distance: 5, alpha: 0.55, angle: 45, blur: 5 } } : arguments[2];
            var shadow = options.shadow;

            var highlightableObject, objectDatas;

            objectDatas = getDatas.allData(object);

            this.modal.innerHTML = templates.singleSelection({
              title: "Selected",
              object: {
                name: objectDatas.name
              }
            });
            this.showModal(this.modal, cssClasses);

            highlightableObject = this._highlightSelectedObject(object, this.map.getRenderer());

            highlightableObject.dropShadow({
              color: shadow.color,
              distance: shadow.distance,
              alpha: shadow.alpha,
              angle: shadow.angle,
              blur: shadow.blur
            });

            this.map.drawOnNextTick();

            _get$Element("select").fadeIn(FADE_ANIMATION);

            return highlightableObject;
          }

          /**
           * @method showUnitMovement
           */
        }, {
          key: 'showUnitMovement',
          value: function showUnitMovement() {}

          /**
           * @method init
           */
        }, {
          key: 'init',
          value: function init() {}

          /*----------------------
          ------- PRIVATE --------
          ----------------------*/
          /**
           * @private
           * @static
           * @method _highlightSelectedObject
           * @param  {Object} object
           * @param  {MapLayer} movableLayer
           * @param  {PIXI.Renderer} renderer
           */
        }, {
          key: '_highlightSelectedObject',
          value: function _highlightSelectedObject(object, renderer) {
            var movableLayer = this.map.getMovableLayer();
            var clonedObject;

            clonedObject = object.clone(renderer);
            clonedObject.__proto__ = object.__proto__;

            var coord = object.toGlobal(new PIXI.Point(0, 0));
            coord = movableLayer.toLocal(coord);

            coord.x -= object.width * object.anchor.x;
            coord.y -= object.height * object.anchor.y;

            this.createHighlight(clonedObject, { coords: coord });

            return clonedObject;
          }

          /**
           * @private
           * @static
           * @method createHighlight
           */
        }, {
          key: 'createHighlight',
          value: function createHighlight(object) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? { coords: new PIXI.Point(0, 0) } : arguments[1];

            var radius = 47;
            var movableLayer = this.map.getMovableLayer();
            var container = new this.map.createSpecialLayer("UILayer", { toLayer: movableLayer });
            var objCoords = {
              x: Number(object.x),
              y: Number(object.y)
            };
            var highlighterObject;

            highlighterObject = createVisibleHexagon(radius, { color: "#F0F0F0" });
            highlighterObject.x = objCoords.x + 32;
            highlighterObject.y = objCoords.y + 27;

            highlighterObject.alpha = 0.5;

            /* We add the children first to subcontainer, since it's much easier to handle the x and y in it, rather than
             * handle graphics x and y */
            container.addChild(highlighterObject);
            container.addChild(object);

            container.position = options.coords;

            this.map.removeUIObject(this.map.layerTypes.movableType.id, [container]);
            this.map.addUIObjects(this.map.layerTypes.movableType.id, [container]);
          }
        }]);

        return UI_default;
      })(UI_templateBase);

      _export('UI_default', UI_default);
    }
  };
});
System.registerDynamic("github:components/handlebars.js@4.0.5/handlebars.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "Handlebars", null);
  (function() {
    "format global";
    "exports Handlebars";
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
      else if (typeof define === 'function' && define.amd)
        define([], factory);
      else if (typeof exports === 'object')
        exports["Handlebars"] = factory();
      else
        root["Handlebars"] = factory();
    })(this, function() {
      return (function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
          module.loaded = true;
          return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      })([function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        var _handlebarsRuntime = __webpack_require__(2);
        var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
        var _handlebarsCompilerAst = __webpack_require__(21);
        var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
        var _handlebarsCompilerBase = __webpack_require__(22);
        var _handlebarsCompilerCompiler = __webpack_require__(27);
        var _handlebarsCompilerJavascriptCompiler = __webpack_require__(28);
        var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
        var _handlebarsCompilerVisitor = __webpack_require__(25);
        var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
        var _handlebarsNoConflict = __webpack_require__(20);
        var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
        var _create = _handlebarsRuntime2['default'].create;
        function create() {
          var hb = _create();
          hb.compile = function(input, options) {
            return _handlebarsCompilerCompiler.compile(input, options, hb);
          };
          hb.precompile = function(input, options) {
            return _handlebarsCompilerCompiler.precompile(input, options, hb);
          };
          hb.AST = _handlebarsCompilerAst2['default'];
          hb.Compiler = _handlebarsCompilerCompiler.Compiler;
          hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
          hb.Parser = _handlebarsCompilerBase.parser;
          hb.parse = _handlebarsCompilerBase.parse;
          return hb;
        }
        var inst = create();
        inst.create = create;
        _handlebarsNoConflict2['default'](inst);
        inst.Visitor = _handlebarsCompilerVisitor2['default'];
        inst['default'] = inst;
        exports['default'] = inst;
        module.exports = exports['default'];
      }, function(module, exports) {
        "use strict";
        exports["default"] = function(obj) {
          return obj && obj.__esModule ? obj : {"default": obj};
        };
        exports.__esModule = true;
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireWildcard = __webpack_require__(3)['default'];
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        var _handlebarsBase = __webpack_require__(4);
        var base = _interopRequireWildcard(_handlebarsBase);
        var _handlebarsSafeString = __webpack_require__(18);
        var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
        var _handlebarsException = __webpack_require__(6);
        var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
        var _handlebarsUtils = __webpack_require__(5);
        var Utils = _interopRequireWildcard(_handlebarsUtils);
        var _handlebarsRuntime = __webpack_require__(19);
        var runtime = _interopRequireWildcard(_handlebarsRuntime);
        var _handlebarsNoConflict = __webpack_require__(20);
        var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
        function create() {
          var hb = new base.HandlebarsEnvironment();
          Utils.extend(hb, base);
          hb.SafeString = _handlebarsSafeString2['default'];
          hb.Exception = _handlebarsException2['default'];
          hb.Utils = Utils;
          hb.escapeExpression = Utils.escapeExpression;
          hb.VM = runtime;
          hb.template = function(spec) {
            return runtime.template(spec, hb);
          };
          return hb;
        }
        var inst = create();
        inst.create = create;
        _handlebarsNoConflict2['default'](inst);
        inst['default'] = inst;
        exports['default'] = inst;
        module.exports = exports['default'];
      }, function(module, exports) {
        "use strict";
        exports["default"] = function(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};
            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key))
                  newObj[key] = obj[key];
              }
            }
            newObj["default"] = obj;
            return newObj;
          }
        };
        exports.__esModule = true;
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        exports.HandlebarsEnvironment = HandlebarsEnvironment;
        var _utils = __webpack_require__(5);
        var _exception = __webpack_require__(6);
        var _exception2 = _interopRequireDefault(_exception);
        var _helpers = __webpack_require__(7);
        var _decorators = __webpack_require__(15);
        var _logger = __webpack_require__(17);
        var _logger2 = _interopRequireDefault(_logger);
        var VERSION = '4.0.5';
        exports.VERSION = VERSION;
        var COMPILER_REVISION = 7;
        exports.COMPILER_REVISION = COMPILER_REVISION;
        var REVISION_CHANGES = {
          1: '<= 1.0.rc.2',
          2: '== 1.0.0-rc.3',
          3: '== 1.0.0-rc.4',
          4: '== 1.x.x',
          5: '== 2.0.0-alpha.x',
          6: '>= 2.0.0-beta.1',
          7: '>= 4.0.0'
        };
        exports.REVISION_CHANGES = REVISION_CHANGES;
        var objectType = '[object Object]';
        function HandlebarsEnvironment(helpers, partials, decorators) {
          this.helpers = helpers || {};
          this.partials = partials || {};
          this.decorators = decorators || {};
          _helpers.registerDefaultHelpers(this);
          _decorators.registerDefaultDecorators(this);
        }
        HandlebarsEnvironment.prototype = {
          constructor: HandlebarsEnvironment,
          logger: _logger2['default'],
          log: _logger2['default'].log,
          registerHelper: function registerHelper(name, fn) {
            if (_utils.toString.call(name) === objectType) {
              if (fn) {
                throw new _exception2['default']('Arg not supported with multiple helpers');
              }
              _utils.extend(this.helpers, name);
            } else {
              this.helpers[name] = fn;
            }
          },
          unregisterHelper: function unregisterHelper(name) {
            delete this.helpers[name];
          },
          registerPartial: function registerPartial(name, partial) {
            if (_utils.toString.call(name) === objectType) {
              _utils.extend(this.partials, name);
            } else {
              if (typeof partial === 'undefined') {
                throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
              }
              this.partials[name] = partial;
            }
          },
          unregisterPartial: function unregisterPartial(name) {
            delete this.partials[name];
          },
          registerDecorator: function registerDecorator(name, fn) {
            if (_utils.toString.call(name) === objectType) {
              if (fn) {
                throw new _exception2['default']('Arg not supported with multiple decorators');
              }
              _utils.extend(this.decorators, name);
            } else {
              this.decorators[name] = fn;
            }
          },
          unregisterDecorator: function unregisterDecorator(name) {
            delete this.decorators[name];
          }
        };
        var log = _logger2['default'].log;
        exports.log = log;
        exports.createFrame = _utils.createFrame;
        exports.logger = _logger2['default'];
      }, function(module, exports) {
        'use strict';
        exports.__esModule = true;
        exports.extend = extend;
        exports.indexOf = indexOf;
        exports.escapeExpression = escapeExpression;
        exports.isEmpty = isEmpty;
        exports.createFrame = createFrame;
        exports.blockParams = blockParams;
        exports.appendContextPath = appendContextPath;
        var escape = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#x27;',
          '`': '&#x60;',
          '=': '&#x3D;'
        };
        var badChars = /[&<>"'`=]/g,
            possible = /[&<>"'`=]/;
        function escapeChar(chr) {
          return escape[chr];
        }
        function extend(obj) {
          for (var i = 1; i < arguments.length; i++) {
            for (var key in arguments[i]) {
              if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                obj[key] = arguments[i][key];
              }
            }
          }
          return obj;
        }
        var toString = Object.prototype.toString;
        exports.toString = toString;
        var isFunction = function isFunction(value) {
          return typeof value === 'function';
        };
        if (isFunction(/x/)) {
          exports.isFunction = isFunction = function(value) {
            return typeof value === 'function' && toString.call(value) === '[object Function]';
          };
        }
        exports.isFunction = isFunction;
        var isArray = Array.isArray || function(value) {
          return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
        };
        exports.isArray = isArray;
        function indexOf(array, value) {
          for (var i = 0,
              len = array.length; i < len; i++) {
            if (array[i] === value) {
              return i;
            }
          }
          return -1;
        }
        function escapeExpression(string) {
          if (typeof string !== 'string') {
            if (string && string.toHTML) {
              return string.toHTML();
            } else if (string == null) {
              return '';
            } else if (!string) {
              return string + '';
            }
            string = '' + string;
          }
          if (!possible.test(string)) {
            return string;
          }
          return string.replace(badChars, escapeChar);
        }
        function isEmpty(value) {
          if (!value && value !== 0) {
            return true;
          } else if (isArray(value) && value.length === 0) {
            return true;
          } else {
            return false;
          }
        }
        function createFrame(object) {
          var frame = extend({}, object);
          frame._parent = object;
          return frame;
        }
        function blockParams(params, ids) {
          params.path = ids;
          return params;
        }
        function appendContextPath(contextPath, id) {
          return (contextPath ? contextPath + '.' : '') + id;
        }
      }, function(module, exports) {
        'use strict';
        exports.__esModule = true;
        var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
        function Exception(message, node) {
          var loc = node && node.loc,
              line = undefined,
              column = undefined;
          if (loc) {
            line = loc.start.line;
            column = loc.start.column;
            message += ' - ' + line + ':' + column;
          }
          var tmp = Error.prototype.constructor.call(this, message);
          for (var idx = 0; idx < errorProps.length; idx++) {
            this[errorProps[idx]] = tmp[errorProps[idx]];
          }
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, Exception);
          }
          if (loc) {
            this.lineNumber = line;
            this.column = column;
          }
        }
        Exception.prototype = new Error();
        exports['default'] = Exception;
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        exports.registerDefaultHelpers = registerDefaultHelpers;
        var _helpersBlockHelperMissing = __webpack_require__(8);
        var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
        var _helpersEach = __webpack_require__(9);
        var _helpersEach2 = _interopRequireDefault(_helpersEach);
        var _helpersHelperMissing = __webpack_require__(10);
        var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
        var _helpersIf = __webpack_require__(11);
        var _helpersIf2 = _interopRequireDefault(_helpersIf);
        var _helpersLog = __webpack_require__(12);
        var _helpersLog2 = _interopRequireDefault(_helpersLog);
        var _helpersLookup = __webpack_require__(13);
        var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
        var _helpersWith = __webpack_require__(14);
        var _helpersWith2 = _interopRequireDefault(_helpersWith);
        function registerDefaultHelpers(instance) {
          _helpersBlockHelperMissing2['default'](instance);
          _helpersEach2['default'](instance);
          _helpersHelperMissing2['default'](instance);
          _helpersIf2['default'](instance);
          _helpersLog2['default'](instance);
          _helpersLookup2['default'](instance);
          _helpersWith2['default'](instance);
        }
      }, function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        var _utils = __webpack_require__(5);
        exports['default'] = function(instance) {
          instance.registerHelper('blockHelperMissing', function(context, options) {
            var inverse = options.inverse,
                fn = options.fn;
            if (context === true) {
              return fn(this);
            } else if (context === false || context == null) {
              return inverse(this);
            } else if (_utils.isArray(context)) {
              if (context.length > 0) {
                if (options.ids) {
                  options.ids = [options.name];
                }
                return instance.helpers.each(context, options);
              } else {
                return inverse(this);
              }
            } else {
              if (options.data && options.ids) {
                var data = _utils.createFrame(options.data);
                data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
                options = {data: data};
              }
              return fn(context, options);
            }
          });
        };
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        var _utils = __webpack_require__(5);
        var _exception = __webpack_require__(6);
        var _exception2 = _interopRequireDefault(_exception);
        exports['default'] = function(instance) {
          instance.registerHelper('each', function(context, options) {
            if (!options) {
              throw new _exception2['default']('Must pass iterator to #each');
            }
            var fn = options.fn,
                inverse = options.inverse,
                i = 0,
                ret = '',
                data = undefined,
                contextPath = undefined;
            if (options.data && options.ids) {
              contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
            }
            if (_utils.isFunction(context)) {
              context = context.call(this);
            }
            if (options.data) {
              data = _utils.createFrame(options.data);
            }
            function execIteration(field, index, last) {
              if (data) {
                data.key = field;
                data.index = index;
                data.first = index === 0;
                data.last = !!last;
                if (contextPath) {
                  data.contextPath = contextPath + field;
                }
              }
              ret = ret + fn(context[field], {
                data: data,
                blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
              });
            }
            if (context && typeof context === 'object') {
              if (_utils.isArray(context)) {
                for (var j = context.length; i < j; i++) {
                  if (i in context) {
                    execIteration(i, i, i === context.length - 1);
                  }
                }
              } else {
                var priorKey = undefined;
                for (var key in context) {
                  if (context.hasOwnProperty(key)) {
                    if (priorKey !== undefined) {
                      execIteration(priorKey, i - 1);
                    }
                    priorKey = key;
                    i++;
                  }
                }
                if (priorKey !== undefined) {
                  execIteration(priorKey, i - 1, true);
                }
              }
            }
            if (i === 0) {
              ret = inverse(this);
            }
            return ret;
          });
        };
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        var _exception = __webpack_require__(6);
        var _exception2 = _interopRequireDefault(_exception);
        exports['default'] = function(instance) {
          instance.registerHelper('helperMissing', function() {
            if (arguments.length === 1) {
              return undefined;
            } else {
              throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
            }
          });
        };
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        var _utils = __webpack_require__(5);
        exports['default'] = function(instance) {
          instance.registerHelper('if', function(conditional, options) {
            if (_utils.isFunction(conditional)) {
              conditional = conditional.call(this);
            }
            if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
              return options.inverse(this);
            } else {
              return options.fn(this);
            }
          });
          instance.registerHelper('unless', function(conditional, options) {
            return instance.helpers['if'].call(this, conditional, {
              fn: options.inverse,
              inverse: options.fn,
              hash: options.hash
            });
          });
        };
        module.exports = exports['default'];
      }, function(module, exports) {
        'use strict';
        exports.__esModule = true;
        exports['default'] = function(instance) {
          instance.registerHelper('log', function() {
            var args = [undefined],
                options = arguments[arguments.length - 1];
            for (var i = 0; i < arguments.length - 1; i++) {
              args.push(arguments[i]);
            }
            var level = 1;
            if (options.hash.level != null) {
              level = options.hash.level;
            } else if (options.data && options.data.level != null) {
              level = options.data.level;
            }
            args[0] = level;
            instance.log.apply(instance, args);
          });
        };
        module.exports = exports['default'];
      }, function(module, exports) {
        'use strict';
        exports.__esModule = true;
        exports['default'] = function(instance) {
          instance.registerHelper('lookup', function(obj, field) {
            return obj && obj[field];
          });
        };
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        var _utils = __webpack_require__(5);
        exports['default'] = function(instance) {
          instance.registerHelper('with', function(context, options) {
            if (_utils.isFunction(context)) {
              context = context.call(this);
            }
            var fn = options.fn;
            if (!_utils.isEmpty(context)) {
              var data = options.data;
              if (options.data && options.ids) {
                data = _utils.createFrame(options.data);
                data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
              }
              return fn(context, {
                data: data,
                blockParams: _utils.blockParams([context], [data && data.contextPath])
              });
            } else {
              return options.inverse(this);
            }
          });
        };
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        exports.registerDefaultDecorators = registerDefaultDecorators;
        var _decoratorsInline = __webpack_require__(16);
        var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
        function registerDefaultDecorators(instance) {
          _decoratorsInline2['default'](instance);
        }
      }, function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        var _utils = __webpack_require__(5);
        exports['default'] = function(instance) {
          instance.registerDecorator('inline', function(fn, props, container, options) {
            var ret = fn;
            if (!props.partials) {
              props.partials = {};
              ret = function(context, options) {
                var original = container.partials;
                container.partials = _utils.extend({}, original, props.partials);
                var ret = fn(context, options);
                container.partials = original;
                return ret;
              };
            }
            props.partials[options.args[0]] = options.fn;
            return ret;
          });
        };
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        var _utils = __webpack_require__(5);
        var logger = {
          methodMap: ['debug', 'info', 'warn', 'error'],
          level: 'info',
          lookupLevel: function lookupLevel(level) {
            if (typeof level === 'string') {
              var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
              if (levelMap >= 0) {
                level = levelMap;
              } else {
                level = parseInt(level, 10);
              }
            }
            return level;
          },
          log: function log(level) {
            level = logger.lookupLevel(level);
            if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
              var method = logger.methodMap[level];
              if (!console[method]) {
                method = 'log';
              }
              for (var _len = arguments.length,
                  message = Array(_len > 1 ? _len - 1 : 0),
                  _key = 1; _key < _len; _key++) {
                message[_key - 1] = arguments[_key];
              }
              console[method].apply(console, message);
            }
          }
        };
        exports['default'] = logger;
        module.exports = exports['default'];
      }, function(module, exports) {
        'use strict';
        exports.__esModule = true;
        function SafeString(string) {
          this.string = string;
        }
        SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
          return '' + this.string;
        };
        exports['default'] = SafeString;
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireWildcard = __webpack_require__(3)['default'];
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        exports.checkRevision = checkRevision;
        exports.template = template;
        exports.wrapProgram = wrapProgram;
        exports.resolvePartial = resolvePartial;
        exports.invokePartial = invokePartial;
        exports.noop = noop;
        var _utils = __webpack_require__(5);
        var Utils = _interopRequireWildcard(_utils);
        var _exception = __webpack_require__(6);
        var _exception2 = _interopRequireDefault(_exception);
        var _base = __webpack_require__(4);
        function checkRevision(compilerInfo) {
          var compilerRevision = compilerInfo && compilerInfo[0] || 1,
              currentRevision = _base.COMPILER_REVISION;
          if (compilerRevision !== currentRevision) {
            if (compilerRevision < currentRevision) {
              var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
                  compilerVersions = _base.REVISION_CHANGES[compilerRevision];
              throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
            } else {
              throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
            }
          }
        }
        function template(templateSpec, env) {
          if (!env) {
            throw new _exception2['default']('No environment passed to template');
          }
          if (!templateSpec || !templateSpec.main) {
            throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
          }
          templateSpec.main.decorator = templateSpec.main_d;
          env.VM.checkRevision(templateSpec.compiler);
          function invokePartialWrapper(partial, context, options) {
            if (options.hash) {
              context = Utils.extend({}, context, options.hash);
              if (options.ids) {
                options.ids[0] = true;
              }
            }
            partial = env.VM.resolvePartial.call(this, partial, context, options);
            var result = env.VM.invokePartial.call(this, partial, context, options);
            if (result == null && env.compile) {
              options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
              result = options.partials[options.name](context, options);
            }
            if (result != null) {
              if (options.indent) {
                var lines = result.split('\n');
                for (var i = 0,
                    l = lines.length; i < l; i++) {
                  if (!lines[i] && i + 1 === l) {
                    break;
                  }
                  lines[i] = options.indent + lines[i];
                }
                result = lines.join('\n');
              }
              return result;
            } else {
              throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
            }
          }
          var container = {
            strict: function strict(obj, name) {
              if (!(name in obj)) {
                throw new _exception2['default']('"' + name + '" not defined in ' + obj);
              }
              return obj[name];
            },
            lookup: function lookup(depths, name) {
              var len = depths.length;
              for (var i = 0; i < len; i++) {
                if (depths[i] && depths[i][name] != null) {
                  return depths[i][name];
                }
              }
            },
            lambda: function lambda(current, context) {
              return typeof current === 'function' ? current.call(context) : current;
            },
            escapeExpression: Utils.escapeExpression,
            invokePartial: invokePartialWrapper,
            fn: function fn(i) {
              var ret = templateSpec[i];
              ret.decorator = templateSpec[i + '_d'];
              return ret;
            },
            programs: [],
            program: function program(i, data, declaredBlockParams, blockParams, depths) {
              var programWrapper = this.programs[i],
                  fn = this.fn(i);
              if (data || depths || blockParams || declaredBlockParams) {
                programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
              } else if (!programWrapper) {
                programWrapper = this.programs[i] = wrapProgram(this, i, fn);
              }
              return programWrapper;
            },
            data: function data(value, depth) {
              while (value && depth--) {
                value = value._parent;
              }
              return value;
            },
            merge: function merge(param, common) {
              var obj = param || common;
              if (param && common && param !== common) {
                obj = Utils.extend({}, common, param);
              }
              return obj;
            },
            noop: env.VM.noop,
            compilerInfo: templateSpec.compiler
          };
          function ret(context) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var data = options.data;
            ret._setup(options);
            if (!options.partial && templateSpec.useData) {
              data = initData(context, data);
            }
            var depths = undefined,
                blockParams = templateSpec.useBlockParams ? [] : undefined;
            if (templateSpec.useDepths) {
              if (options.depths) {
                depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
              } else {
                depths = [context];
              }
            }
            function main(context) {
              return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
            }
            main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
            return main(context, options);
          }
          ret.isTop = true;
          ret._setup = function(options) {
            if (!options.partial) {
              container.helpers = container.merge(options.helpers, env.helpers);
              if (templateSpec.usePartial) {
                container.partials = container.merge(options.partials, env.partials);
              }
              if (templateSpec.usePartial || templateSpec.useDecorators) {
                container.decorators = container.merge(options.decorators, env.decorators);
              }
            } else {
              container.helpers = options.helpers;
              container.partials = options.partials;
              container.decorators = options.decorators;
            }
          };
          ret._child = function(i, data, blockParams, depths) {
            if (templateSpec.useBlockParams && !blockParams) {
              throw new _exception2['default']('must pass block params');
            }
            if (templateSpec.useDepths && !depths) {
              throw new _exception2['default']('must pass parent depths');
            }
            return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
          };
          return ret;
        }
        function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
          function prog(context) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var currentDepths = depths;
            if (depths && context !== depths[0]) {
              currentDepths = [context].concat(depths);
            }
            return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
          }
          prog = executeDecorators(fn, prog, container, depths, data, blockParams);
          prog.program = i;
          prog.depth = depths ? depths.length : 0;
          prog.blockParams = declaredBlockParams || 0;
          return prog;
        }
        function resolvePartial(partial, context, options) {
          if (!partial) {
            if (options.name === '@partial-block') {
              partial = options.data['partial-block'];
            } else {
              partial = options.partials[options.name];
            }
          } else if (!partial.call && !options.name) {
            options.name = partial;
            partial = options.partials[partial];
          }
          return partial;
        }
        function invokePartial(partial, context, options) {
          options.partial = true;
          if (options.ids) {
            options.data.contextPath = options.ids[0] || options.data.contextPath;
          }
          var partialBlock = undefined;
          if (options.fn && options.fn !== noop) {
            options.data = _base.createFrame(options.data);
            partialBlock = options.data['partial-block'] = options.fn;
            if (partialBlock.partials) {
              options.partials = Utils.extend({}, options.partials, partialBlock.partials);
            }
          }
          if (partial === undefined && partialBlock) {
            partial = partialBlock;
          }
          if (partial === undefined) {
            throw new _exception2['default']('The partial ' + options.name + ' could not be found');
          } else if (partial instanceof Function) {
            return partial(context, options);
          }
        }
        function noop() {
          return '';
        }
        function initData(context, data) {
          if (!data || !('root' in data)) {
            data = data ? _base.createFrame(data) : {};
            data.root = context;
          }
          return data;
        }
        function executeDecorators(fn, prog, container, depths, data, blockParams) {
          if (fn.decorator) {
            var props = {};
            prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
            Utils.extend(prog, props);
          }
          return prog;
        }
      }, function(module, exports) {
        (function(global) {
          'use strict';
          exports.__esModule = true;
          exports['default'] = function(Handlebars) {
            var root = typeof global !== 'undefined' ? global : window,
                $Handlebars = root.Handlebars;
            Handlebars.noConflict = function() {
              if (root.Handlebars === Handlebars) {
                root.Handlebars = $Handlebars;
              }
              return Handlebars;
            };
          };
          module.exports = exports['default'];
        }.call(exports, (function() {
          return this;
        }())));
      }, function(module, exports) {
        'use strict';
        exports.__esModule = true;
        var AST = {helpers: {
            helperExpression: function helperExpression(node) {
              return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
            },
            scopedId: function scopedId(path) {
              return (/^\.|this\b/.test(path.original));
            },
            simpleId: function simpleId(path) {
              return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
            }
          }};
        exports['default'] = AST;
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        var _interopRequireWildcard = __webpack_require__(3)['default'];
        exports.__esModule = true;
        exports.parse = parse;
        var _parser = __webpack_require__(23);
        var _parser2 = _interopRequireDefault(_parser);
        var _whitespaceControl = __webpack_require__(24);
        var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
        var _helpers = __webpack_require__(26);
        var Helpers = _interopRequireWildcard(_helpers);
        var _utils = __webpack_require__(5);
        exports.parser = _parser2['default'];
        var yy = {};
        _utils.extend(yy, Helpers);
        function parse(input, options) {
          if (input.type === 'Program') {
            return input;
          }
          _parser2['default'].yy = yy;
          yy.locInfo = function(locInfo) {
            return new yy.SourceLocation(options && options.srcName, locInfo);
          };
          var strip = new _whitespaceControl2['default'](options);
          return strip.accept(_parser2['default'].parse(input));
        }
      }, function(module, exports) {
        "use strict";
        var handlebars = (function() {
          var parser = {
            trace: function trace() {},
            yy: {},
            symbols_: {
              "error": 2,
              "root": 3,
              "program": 4,
              "EOF": 5,
              "program_repetition0": 6,
              "statement": 7,
              "mustache": 8,
              "block": 9,
              "rawBlock": 10,
              "partial": 11,
              "partialBlock": 12,
              "content": 13,
              "COMMENT": 14,
              "CONTENT": 15,
              "openRawBlock": 16,
              "rawBlock_repetition_plus0": 17,
              "END_RAW_BLOCK": 18,
              "OPEN_RAW_BLOCK": 19,
              "helperName": 20,
              "openRawBlock_repetition0": 21,
              "openRawBlock_option0": 22,
              "CLOSE_RAW_BLOCK": 23,
              "openBlock": 24,
              "block_option0": 25,
              "closeBlock": 26,
              "openInverse": 27,
              "block_option1": 28,
              "OPEN_BLOCK": 29,
              "openBlock_repetition0": 30,
              "openBlock_option0": 31,
              "openBlock_option1": 32,
              "CLOSE": 33,
              "OPEN_INVERSE": 34,
              "openInverse_repetition0": 35,
              "openInverse_option0": 36,
              "openInverse_option1": 37,
              "openInverseChain": 38,
              "OPEN_INVERSE_CHAIN": 39,
              "openInverseChain_repetition0": 40,
              "openInverseChain_option0": 41,
              "openInverseChain_option1": 42,
              "inverseAndProgram": 43,
              "INVERSE": 44,
              "inverseChain": 45,
              "inverseChain_option0": 46,
              "OPEN_ENDBLOCK": 47,
              "OPEN": 48,
              "mustache_repetition0": 49,
              "mustache_option0": 50,
              "OPEN_UNESCAPED": 51,
              "mustache_repetition1": 52,
              "mustache_option1": 53,
              "CLOSE_UNESCAPED": 54,
              "OPEN_PARTIAL": 55,
              "partialName": 56,
              "partial_repetition0": 57,
              "partial_option0": 58,
              "openPartialBlock": 59,
              "OPEN_PARTIAL_BLOCK": 60,
              "openPartialBlock_repetition0": 61,
              "openPartialBlock_option0": 62,
              "param": 63,
              "sexpr": 64,
              "OPEN_SEXPR": 65,
              "sexpr_repetition0": 66,
              "sexpr_option0": 67,
              "CLOSE_SEXPR": 68,
              "hash": 69,
              "hash_repetition_plus0": 70,
              "hashSegment": 71,
              "ID": 72,
              "EQUALS": 73,
              "blockParams": 74,
              "OPEN_BLOCK_PARAMS": 75,
              "blockParams_repetition_plus0": 76,
              "CLOSE_BLOCK_PARAMS": 77,
              "path": 78,
              "dataName": 79,
              "STRING": 80,
              "NUMBER": 81,
              "BOOLEAN": 82,
              "UNDEFINED": 83,
              "NULL": 84,
              "DATA": 85,
              "pathSegments": 86,
              "SEP": 87,
              "$accept": 0,
              "$end": 1
            },
            terminals_: {
              2: "error",
              5: "EOF",
              14: "COMMENT",
              15: "CONTENT",
              18: "END_RAW_BLOCK",
              19: "OPEN_RAW_BLOCK",
              23: "CLOSE_RAW_BLOCK",
              29: "OPEN_BLOCK",
              33: "CLOSE",
              34: "OPEN_INVERSE",
              39: "OPEN_INVERSE_CHAIN",
              44: "INVERSE",
              47: "OPEN_ENDBLOCK",
              48: "OPEN",
              51: "OPEN_UNESCAPED",
              54: "CLOSE_UNESCAPED",
              55: "OPEN_PARTIAL",
              60: "OPEN_PARTIAL_BLOCK",
              65: "OPEN_SEXPR",
              68: "CLOSE_SEXPR",
              72: "ID",
              73: "EQUALS",
              75: "OPEN_BLOCK_PARAMS",
              77: "CLOSE_BLOCK_PARAMS",
              80: "STRING",
              81: "NUMBER",
              82: "BOOLEAN",
              83: "UNDEFINED",
              84: "NULL",
              85: "DATA",
              87: "SEP"
            },
            productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
              var $0 = $$.length - 1;
              switch (yystate) {
                case 1:
                  return $$[$0 - 1];
                  break;
                case 2:
                  this.$ = yy.prepareProgram($$[$0]);
                  break;
                case 3:
                  this.$ = $$[$0];
                  break;
                case 4:
                  this.$ = $$[$0];
                  break;
                case 5:
                  this.$ = $$[$0];
                  break;
                case 6:
                  this.$ = $$[$0];
                  break;
                case 7:
                  this.$ = $$[$0];
                  break;
                case 8:
                  this.$ = $$[$0];
                  break;
                case 9:
                  this.$ = {
                    type: 'CommentStatement',
                    value: yy.stripComment($$[$0]),
                    strip: yy.stripFlags($$[$0], $$[$0]),
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 10:
                  this.$ = {
                    type: 'ContentStatement',
                    original: $$[$0],
                    value: $$[$0],
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 11:
                  this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                  break;
                case 12:
                  this.$ = {
                    path: $$[$0 - 3],
                    params: $$[$0 - 2],
                    hash: $$[$0 - 1]
                  };
                  break;
                case 13:
                  this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                  break;
                case 14:
                  this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                  break;
                case 15:
                  this.$ = {
                    open: $$[$0 - 5],
                    path: $$[$0 - 4],
                    params: $$[$0 - 3],
                    hash: $$[$0 - 2],
                    blockParams: $$[$0 - 1],
                    strip: yy.stripFlags($$[$0 - 5], $$[$0])
                  };
                  break;
                case 16:
                  this.$ = {
                    path: $$[$0 - 4],
                    params: $$[$0 - 3],
                    hash: $$[$0 - 2],
                    blockParams: $$[$0 - 1],
                    strip: yy.stripFlags($$[$0 - 5], $$[$0])
                  };
                  break;
                case 17:
                  this.$ = {
                    path: $$[$0 - 4],
                    params: $$[$0 - 3],
                    hash: $$[$0 - 2],
                    blockParams: $$[$0 - 1],
                    strip: yy.stripFlags($$[$0 - 5], $$[$0])
                  };
                  break;
                case 18:
                  this.$ = {
                    strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]),
                    program: $$[$0]
                  };
                  break;
                case 19:
                  var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                      program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                  program.chained = true;
                  this.$ = {
                    strip: $$[$0 - 2].strip,
                    program: program,
                    chain: true
                  };
                  break;
                case 20:
                  this.$ = $$[$0];
                  break;
                case 21:
                  this.$ = {
                    path: $$[$0 - 1],
                    strip: yy.stripFlags($$[$0 - 2], $$[$0])
                  };
                  break;
                case 22:
                  this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                  break;
                case 23:
                  this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                  break;
                case 24:
                  this.$ = {
                    type: 'PartialStatement',
                    name: $$[$0 - 3],
                    params: $$[$0 - 2],
                    hash: $$[$0 - 1],
                    indent: '',
                    strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 25:
                  this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                  break;
                case 26:
                  this.$ = {
                    path: $$[$0 - 3],
                    params: $$[$0 - 2],
                    hash: $$[$0 - 1],
                    strip: yy.stripFlags($$[$0 - 4], $$[$0])
                  };
                  break;
                case 27:
                  this.$ = $$[$0];
                  break;
                case 28:
                  this.$ = $$[$0];
                  break;
                case 29:
                  this.$ = {
                    type: 'SubExpression',
                    path: $$[$0 - 3],
                    params: $$[$0 - 2],
                    hash: $$[$0 - 1],
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 30:
                  this.$ = {
                    type: 'Hash',
                    pairs: $$[$0],
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 31:
                  this.$ = {
                    type: 'HashPair',
                    key: yy.id($$[$0 - 2]),
                    value: $$[$0],
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 32:
                  this.$ = yy.id($$[$0 - 1]);
                  break;
                case 33:
                  this.$ = $$[$0];
                  break;
                case 34:
                  this.$ = $$[$0];
                  break;
                case 35:
                  this.$ = {
                    type: 'StringLiteral',
                    value: $$[$0],
                    original: $$[$0],
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 36:
                  this.$ = {
                    type: 'NumberLiteral',
                    value: Number($$[$0]),
                    original: Number($$[$0]),
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 37:
                  this.$ = {
                    type: 'BooleanLiteral',
                    value: $$[$0] === 'true',
                    original: $$[$0] === 'true',
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 38:
                  this.$ = {
                    type: 'UndefinedLiteral',
                    original: undefined,
                    value: undefined,
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 39:
                  this.$ = {
                    type: 'NullLiteral',
                    original: null,
                    value: null,
                    loc: yy.locInfo(this._$)
                  };
                  break;
                case 40:
                  this.$ = $$[$0];
                  break;
                case 41:
                  this.$ = $$[$0];
                  break;
                case 42:
                  this.$ = yy.preparePath(true, $$[$0], this._$);
                  break;
                case 43:
                  this.$ = yy.preparePath(false, $$[$0], this._$);
                  break;
                case 44:
                  $$[$0 - 2].push({
                    part: yy.id($$[$0]),
                    original: $$[$0],
                    separator: $$[$0 - 1]
                  });
                  this.$ = $$[$0 - 2];
                  break;
                case 45:
                  this.$ = [{
                    part: yy.id($$[$0]),
                    original: $$[$0]
                  }];
                  break;
                case 46:
                  this.$ = [];
                  break;
                case 47:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 48:
                  this.$ = [$$[$0]];
                  break;
                case 49:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 50:
                  this.$ = [];
                  break;
                case 51:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 58:
                  this.$ = [];
                  break;
                case 59:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 64:
                  this.$ = [];
                  break;
                case 65:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 70:
                  this.$ = [];
                  break;
                case 71:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 78:
                  this.$ = [];
                  break;
                case 79:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 82:
                  this.$ = [];
                  break;
                case 83:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 86:
                  this.$ = [];
                  break;
                case 87:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 90:
                  this.$ = [];
                  break;
                case 91:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 94:
                  this.$ = [];
                  break;
                case 95:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 98:
                  this.$ = [$$[$0]];
                  break;
                case 99:
                  $$[$0 - 1].push($$[$0]);
                  break;
                case 100:
                  this.$ = [$$[$0]];
                  break;
                case 101:
                  $$[$0 - 1].push($$[$0]);
                  break;
              }
            },
            table: [{
              3: 1,
              4: 2,
              5: [2, 46],
              6: 3,
              14: [2, 46],
              15: [2, 46],
              19: [2, 46],
              29: [2, 46],
              34: [2, 46],
              48: [2, 46],
              51: [2, 46],
              55: [2, 46],
              60: [2, 46]
            }, {1: [3]}, {5: [1, 4]}, {
              5: [2, 2],
              7: 5,
              8: 6,
              9: 7,
              10: 8,
              11: 9,
              12: 10,
              13: 11,
              14: [1, 12],
              15: [1, 20],
              16: 17,
              19: [1, 23],
              24: 15,
              27: 16,
              29: [1, 21],
              34: [1, 22],
              39: [2, 2],
              44: [2, 2],
              47: [2, 2],
              48: [1, 13],
              51: [1, 14],
              55: [1, 18],
              59: 19,
              60: [1, 24]
            }, {1: [2, 1]}, {
              5: [2, 47],
              14: [2, 47],
              15: [2, 47],
              19: [2, 47],
              29: [2, 47],
              34: [2, 47],
              39: [2, 47],
              44: [2, 47],
              47: [2, 47],
              48: [2, 47],
              51: [2, 47],
              55: [2, 47],
              60: [2, 47]
            }, {
              5: [2, 3],
              14: [2, 3],
              15: [2, 3],
              19: [2, 3],
              29: [2, 3],
              34: [2, 3],
              39: [2, 3],
              44: [2, 3],
              47: [2, 3],
              48: [2, 3],
              51: [2, 3],
              55: [2, 3],
              60: [2, 3]
            }, {
              5: [2, 4],
              14: [2, 4],
              15: [2, 4],
              19: [2, 4],
              29: [2, 4],
              34: [2, 4],
              39: [2, 4],
              44: [2, 4],
              47: [2, 4],
              48: [2, 4],
              51: [2, 4],
              55: [2, 4],
              60: [2, 4]
            }, {
              5: [2, 5],
              14: [2, 5],
              15: [2, 5],
              19: [2, 5],
              29: [2, 5],
              34: [2, 5],
              39: [2, 5],
              44: [2, 5],
              47: [2, 5],
              48: [2, 5],
              51: [2, 5],
              55: [2, 5],
              60: [2, 5]
            }, {
              5: [2, 6],
              14: [2, 6],
              15: [2, 6],
              19: [2, 6],
              29: [2, 6],
              34: [2, 6],
              39: [2, 6],
              44: [2, 6],
              47: [2, 6],
              48: [2, 6],
              51: [2, 6],
              55: [2, 6],
              60: [2, 6]
            }, {
              5: [2, 7],
              14: [2, 7],
              15: [2, 7],
              19: [2, 7],
              29: [2, 7],
              34: [2, 7],
              39: [2, 7],
              44: [2, 7],
              47: [2, 7],
              48: [2, 7],
              51: [2, 7],
              55: [2, 7],
              60: [2, 7]
            }, {
              5: [2, 8],
              14: [2, 8],
              15: [2, 8],
              19: [2, 8],
              29: [2, 8],
              34: [2, 8],
              39: [2, 8],
              44: [2, 8],
              47: [2, 8],
              48: [2, 8],
              51: [2, 8],
              55: [2, 8],
              60: [2, 8]
            }, {
              5: [2, 9],
              14: [2, 9],
              15: [2, 9],
              19: [2, 9],
              29: [2, 9],
              34: [2, 9],
              39: [2, 9],
              44: [2, 9],
              47: [2, 9],
              48: [2, 9],
              51: [2, 9],
              55: [2, 9],
              60: [2, 9]
            }, {
              20: 25,
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              20: 36,
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              4: 37,
              6: 3,
              14: [2, 46],
              15: [2, 46],
              19: [2, 46],
              29: [2, 46],
              34: [2, 46],
              39: [2, 46],
              44: [2, 46],
              47: [2, 46],
              48: [2, 46],
              51: [2, 46],
              55: [2, 46],
              60: [2, 46]
            }, {
              4: 38,
              6: 3,
              14: [2, 46],
              15: [2, 46],
              19: [2, 46],
              29: [2, 46],
              34: [2, 46],
              44: [2, 46],
              47: [2, 46],
              48: [2, 46],
              51: [2, 46],
              55: [2, 46],
              60: [2, 46]
            }, {
              13: 40,
              15: [1, 20],
              17: 39
            }, {
              20: 42,
              56: 41,
              64: 43,
              65: [1, 44],
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              4: 45,
              6: 3,
              14: [2, 46],
              15: [2, 46],
              19: [2, 46],
              29: [2, 46],
              34: [2, 46],
              47: [2, 46],
              48: [2, 46],
              51: [2, 46],
              55: [2, 46],
              60: [2, 46]
            }, {
              5: [2, 10],
              14: [2, 10],
              15: [2, 10],
              18: [2, 10],
              19: [2, 10],
              29: [2, 10],
              34: [2, 10],
              39: [2, 10],
              44: [2, 10],
              47: [2, 10],
              48: [2, 10],
              51: [2, 10],
              55: [2, 10],
              60: [2, 10]
            }, {
              20: 46,
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              20: 47,
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              20: 48,
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              20: 42,
              56: 49,
              64: 43,
              65: [1, 44],
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              33: [2, 78],
              49: 50,
              65: [2, 78],
              72: [2, 78],
              80: [2, 78],
              81: [2, 78],
              82: [2, 78],
              83: [2, 78],
              84: [2, 78],
              85: [2, 78]
            }, {
              23: [2, 33],
              33: [2, 33],
              54: [2, 33],
              65: [2, 33],
              68: [2, 33],
              72: [2, 33],
              75: [2, 33],
              80: [2, 33],
              81: [2, 33],
              82: [2, 33],
              83: [2, 33],
              84: [2, 33],
              85: [2, 33]
            }, {
              23: [2, 34],
              33: [2, 34],
              54: [2, 34],
              65: [2, 34],
              68: [2, 34],
              72: [2, 34],
              75: [2, 34],
              80: [2, 34],
              81: [2, 34],
              82: [2, 34],
              83: [2, 34],
              84: [2, 34],
              85: [2, 34]
            }, {
              23: [2, 35],
              33: [2, 35],
              54: [2, 35],
              65: [2, 35],
              68: [2, 35],
              72: [2, 35],
              75: [2, 35],
              80: [2, 35],
              81: [2, 35],
              82: [2, 35],
              83: [2, 35],
              84: [2, 35],
              85: [2, 35]
            }, {
              23: [2, 36],
              33: [2, 36],
              54: [2, 36],
              65: [2, 36],
              68: [2, 36],
              72: [2, 36],
              75: [2, 36],
              80: [2, 36],
              81: [2, 36],
              82: [2, 36],
              83: [2, 36],
              84: [2, 36],
              85: [2, 36]
            }, {
              23: [2, 37],
              33: [2, 37],
              54: [2, 37],
              65: [2, 37],
              68: [2, 37],
              72: [2, 37],
              75: [2, 37],
              80: [2, 37],
              81: [2, 37],
              82: [2, 37],
              83: [2, 37],
              84: [2, 37],
              85: [2, 37]
            }, {
              23: [2, 38],
              33: [2, 38],
              54: [2, 38],
              65: [2, 38],
              68: [2, 38],
              72: [2, 38],
              75: [2, 38],
              80: [2, 38],
              81: [2, 38],
              82: [2, 38],
              83: [2, 38],
              84: [2, 38],
              85: [2, 38]
            }, {
              23: [2, 39],
              33: [2, 39],
              54: [2, 39],
              65: [2, 39],
              68: [2, 39],
              72: [2, 39],
              75: [2, 39],
              80: [2, 39],
              81: [2, 39],
              82: [2, 39],
              83: [2, 39],
              84: [2, 39],
              85: [2, 39]
            }, {
              23: [2, 43],
              33: [2, 43],
              54: [2, 43],
              65: [2, 43],
              68: [2, 43],
              72: [2, 43],
              75: [2, 43],
              80: [2, 43],
              81: [2, 43],
              82: [2, 43],
              83: [2, 43],
              84: [2, 43],
              85: [2, 43],
              87: [1, 51]
            }, {
              72: [1, 35],
              86: 52
            }, {
              23: [2, 45],
              33: [2, 45],
              54: [2, 45],
              65: [2, 45],
              68: [2, 45],
              72: [2, 45],
              75: [2, 45],
              80: [2, 45],
              81: [2, 45],
              82: [2, 45],
              83: [2, 45],
              84: [2, 45],
              85: [2, 45],
              87: [2, 45]
            }, {
              52: 53,
              54: [2, 82],
              65: [2, 82],
              72: [2, 82],
              80: [2, 82],
              81: [2, 82],
              82: [2, 82],
              83: [2, 82],
              84: [2, 82],
              85: [2, 82]
            }, {
              25: 54,
              38: 56,
              39: [1, 58],
              43: 57,
              44: [1, 59],
              45: 55,
              47: [2, 54]
            }, {
              28: 60,
              43: 61,
              44: [1, 59],
              47: [2, 56]
            }, {
              13: 63,
              15: [1, 20],
              18: [1, 62]
            }, {
              15: [2, 48],
              18: [2, 48]
            }, {
              33: [2, 86],
              57: 64,
              65: [2, 86],
              72: [2, 86],
              80: [2, 86],
              81: [2, 86],
              82: [2, 86],
              83: [2, 86],
              84: [2, 86],
              85: [2, 86]
            }, {
              33: [2, 40],
              65: [2, 40],
              72: [2, 40],
              80: [2, 40],
              81: [2, 40],
              82: [2, 40],
              83: [2, 40],
              84: [2, 40],
              85: [2, 40]
            }, {
              33: [2, 41],
              65: [2, 41],
              72: [2, 41],
              80: [2, 41],
              81: [2, 41],
              82: [2, 41],
              83: [2, 41],
              84: [2, 41],
              85: [2, 41]
            }, {
              20: 65,
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              26: 66,
              47: [1, 67]
            }, {
              30: 68,
              33: [2, 58],
              65: [2, 58],
              72: [2, 58],
              75: [2, 58],
              80: [2, 58],
              81: [2, 58],
              82: [2, 58],
              83: [2, 58],
              84: [2, 58],
              85: [2, 58]
            }, {
              33: [2, 64],
              35: 69,
              65: [2, 64],
              72: [2, 64],
              75: [2, 64],
              80: [2, 64],
              81: [2, 64],
              82: [2, 64],
              83: [2, 64],
              84: [2, 64],
              85: [2, 64]
            }, {
              21: 70,
              23: [2, 50],
              65: [2, 50],
              72: [2, 50],
              80: [2, 50],
              81: [2, 50],
              82: [2, 50],
              83: [2, 50],
              84: [2, 50],
              85: [2, 50]
            }, {
              33: [2, 90],
              61: 71,
              65: [2, 90],
              72: [2, 90],
              80: [2, 90],
              81: [2, 90],
              82: [2, 90],
              83: [2, 90],
              84: [2, 90],
              85: [2, 90]
            }, {
              20: 75,
              33: [2, 80],
              50: 72,
              63: 73,
              64: 76,
              65: [1, 44],
              69: 74,
              70: 77,
              71: 78,
              72: [1, 79],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {72: [1, 80]}, {
              23: [2, 42],
              33: [2, 42],
              54: [2, 42],
              65: [2, 42],
              68: [2, 42],
              72: [2, 42],
              75: [2, 42],
              80: [2, 42],
              81: [2, 42],
              82: [2, 42],
              83: [2, 42],
              84: [2, 42],
              85: [2, 42],
              87: [1, 51]
            }, {
              20: 75,
              53: 81,
              54: [2, 84],
              63: 82,
              64: 76,
              65: [1, 44],
              69: 83,
              70: 77,
              71: 78,
              72: [1, 79],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              26: 84,
              47: [1, 67]
            }, {47: [2, 55]}, {
              4: 85,
              6: 3,
              14: [2, 46],
              15: [2, 46],
              19: [2, 46],
              29: [2, 46],
              34: [2, 46],
              39: [2, 46],
              44: [2, 46],
              47: [2, 46],
              48: [2, 46],
              51: [2, 46],
              55: [2, 46],
              60: [2, 46]
            }, {47: [2, 20]}, {
              20: 86,
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              4: 87,
              6: 3,
              14: [2, 46],
              15: [2, 46],
              19: [2, 46],
              29: [2, 46],
              34: [2, 46],
              47: [2, 46],
              48: [2, 46],
              51: [2, 46],
              55: [2, 46],
              60: [2, 46]
            }, {
              26: 88,
              47: [1, 67]
            }, {47: [2, 57]}, {
              5: [2, 11],
              14: [2, 11],
              15: [2, 11],
              19: [2, 11],
              29: [2, 11],
              34: [2, 11],
              39: [2, 11],
              44: [2, 11],
              47: [2, 11],
              48: [2, 11],
              51: [2, 11],
              55: [2, 11],
              60: [2, 11]
            }, {
              15: [2, 49],
              18: [2, 49]
            }, {
              20: 75,
              33: [2, 88],
              58: 89,
              63: 90,
              64: 76,
              65: [1, 44],
              69: 91,
              70: 77,
              71: 78,
              72: [1, 79],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              65: [2, 94],
              66: 92,
              68: [2, 94],
              72: [2, 94],
              80: [2, 94],
              81: [2, 94],
              82: [2, 94],
              83: [2, 94],
              84: [2, 94],
              85: [2, 94]
            }, {
              5: [2, 25],
              14: [2, 25],
              15: [2, 25],
              19: [2, 25],
              29: [2, 25],
              34: [2, 25],
              39: [2, 25],
              44: [2, 25],
              47: [2, 25],
              48: [2, 25],
              51: [2, 25],
              55: [2, 25],
              60: [2, 25]
            }, {
              20: 93,
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              20: 75,
              31: 94,
              33: [2, 60],
              63: 95,
              64: 76,
              65: [1, 44],
              69: 96,
              70: 77,
              71: 78,
              72: [1, 79],
              75: [2, 60],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              20: 75,
              33: [2, 66],
              36: 97,
              63: 98,
              64: 76,
              65: [1, 44],
              69: 99,
              70: 77,
              71: 78,
              72: [1, 79],
              75: [2, 66],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              20: 75,
              22: 100,
              23: [2, 52],
              63: 101,
              64: 76,
              65: [1, 44],
              69: 102,
              70: 77,
              71: 78,
              72: [1, 79],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              20: 75,
              33: [2, 92],
              62: 103,
              63: 104,
              64: 76,
              65: [1, 44],
              69: 105,
              70: 77,
              71: 78,
              72: [1, 79],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {33: [1, 106]}, {
              33: [2, 79],
              65: [2, 79],
              72: [2, 79],
              80: [2, 79],
              81: [2, 79],
              82: [2, 79],
              83: [2, 79],
              84: [2, 79],
              85: [2, 79]
            }, {33: [2, 81]}, {
              23: [2, 27],
              33: [2, 27],
              54: [2, 27],
              65: [2, 27],
              68: [2, 27],
              72: [2, 27],
              75: [2, 27],
              80: [2, 27],
              81: [2, 27],
              82: [2, 27],
              83: [2, 27],
              84: [2, 27],
              85: [2, 27]
            }, {
              23: [2, 28],
              33: [2, 28],
              54: [2, 28],
              65: [2, 28],
              68: [2, 28],
              72: [2, 28],
              75: [2, 28],
              80: [2, 28],
              81: [2, 28],
              82: [2, 28],
              83: [2, 28],
              84: [2, 28],
              85: [2, 28]
            }, {
              23: [2, 30],
              33: [2, 30],
              54: [2, 30],
              68: [2, 30],
              71: 107,
              72: [1, 108],
              75: [2, 30]
            }, {
              23: [2, 98],
              33: [2, 98],
              54: [2, 98],
              68: [2, 98],
              72: [2, 98],
              75: [2, 98]
            }, {
              23: [2, 45],
              33: [2, 45],
              54: [2, 45],
              65: [2, 45],
              68: [2, 45],
              72: [2, 45],
              73: [1, 109],
              75: [2, 45],
              80: [2, 45],
              81: [2, 45],
              82: [2, 45],
              83: [2, 45],
              84: [2, 45],
              85: [2, 45],
              87: [2, 45]
            }, {
              23: [2, 44],
              33: [2, 44],
              54: [2, 44],
              65: [2, 44],
              68: [2, 44],
              72: [2, 44],
              75: [2, 44],
              80: [2, 44],
              81: [2, 44],
              82: [2, 44],
              83: [2, 44],
              84: [2, 44],
              85: [2, 44],
              87: [2, 44]
            }, {54: [1, 110]}, {
              54: [2, 83],
              65: [2, 83],
              72: [2, 83],
              80: [2, 83],
              81: [2, 83],
              82: [2, 83],
              83: [2, 83],
              84: [2, 83],
              85: [2, 83]
            }, {54: [2, 85]}, {
              5: [2, 13],
              14: [2, 13],
              15: [2, 13],
              19: [2, 13],
              29: [2, 13],
              34: [2, 13],
              39: [2, 13],
              44: [2, 13],
              47: [2, 13],
              48: [2, 13],
              51: [2, 13],
              55: [2, 13],
              60: [2, 13]
            }, {
              38: 56,
              39: [1, 58],
              43: 57,
              44: [1, 59],
              45: 112,
              46: 111,
              47: [2, 76]
            }, {
              33: [2, 70],
              40: 113,
              65: [2, 70],
              72: [2, 70],
              75: [2, 70],
              80: [2, 70],
              81: [2, 70],
              82: [2, 70],
              83: [2, 70],
              84: [2, 70],
              85: [2, 70]
            }, {47: [2, 18]}, {
              5: [2, 14],
              14: [2, 14],
              15: [2, 14],
              19: [2, 14],
              29: [2, 14],
              34: [2, 14],
              39: [2, 14],
              44: [2, 14],
              47: [2, 14],
              48: [2, 14],
              51: [2, 14],
              55: [2, 14],
              60: [2, 14]
            }, {33: [1, 114]}, {
              33: [2, 87],
              65: [2, 87],
              72: [2, 87],
              80: [2, 87],
              81: [2, 87],
              82: [2, 87],
              83: [2, 87],
              84: [2, 87],
              85: [2, 87]
            }, {33: [2, 89]}, {
              20: 75,
              63: 116,
              64: 76,
              65: [1, 44],
              67: 115,
              68: [2, 96],
              69: 117,
              70: 77,
              71: 78,
              72: [1, 79],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {33: [1, 118]}, {
              32: 119,
              33: [2, 62],
              74: 120,
              75: [1, 121]
            }, {
              33: [2, 59],
              65: [2, 59],
              72: [2, 59],
              75: [2, 59],
              80: [2, 59],
              81: [2, 59],
              82: [2, 59],
              83: [2, 59],
              84: [2, 59],
              85: [2, 59]
            }, {
              33: [2, 61],
              75: [2, 61]
            }, {
              33: [2, 68],
              37: 122,
              74: 123,
              75: [1, 121]
            }, {
              33: [2, 65],
              65: [2, 65],
              72: [2, 65],
              75: [2, 65],
              80: [2, 65],
              81: [2, 65],
              82: [2, 65],
              83: [2, 65],
              84: [2, 65],
              85: [2, 65]
            }, {
              33: [2, 67],
              75: [2, 67]
            }, {23: [1, 124]}, {
              23: [2, 51],
              65: [2, 51],
              72: [2, 51],
              80: [2, 51],
              81: [2, 51],
              82: [2, 51],
              83: [2, 51],
              84: [2, 51],
              85: [2, 51]
            }, {23: [2, 53]}, {33: [1, 125]}, {
              33: [2, 91],
              65: [2, 91],
              72: [2, 91],
              80: [2, 91],
              81: [2, 91],
              82: [2, 91],
              83: [2, 91],
              84: [2, 91],
              85: [2, 91]
            }, {33: [2, 93]}, {
              5: [2, 22],
              14: [2, 22],
              15: [2, 22],
              19: [2, 22],
              29: [2, 22],
              34: [2, 22],
              39: [2, 22],
              44: [2, 22],
              47: [2, 22],
              48: [2, 22],
              51: [2, 22],
              55: [2, 22],
              60: [2, 22]
            }, {
              23: [2, 99],
              33: [2, 99],
              54: [2, 99],
              68: [2, 99],
              72: [2, 99],
              75: [2, 99]
            }, {73: [1, 109]}, {
              20: 75,
              63: 126,
              64: 76,
              65: [1, 44],
              72: [1, 35],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              5: [2, 23],
              14: [2, 23],
              15: [2, 23],
              19: [2, 23],
              29: [2, 23],
              34: [2, 23],
              39: [2, 23],
              44: [2, 23],
              47: [2, 23],
              48: [2, 23],
              51: [2, 23],
              55: [2, 23],
              60: [2, 23]
            }, {47: [2, 19]}, {47: [2, 77]}, {
              20: 75,
              33: [2, 72],
              41: 127,
              63: 128,
              64: 76,
              65: [1, 44],
              69: 129,
              70: 77,
              71: 78,
              72: [1, 79],
              75: [2, 72],
              78: 26,
              79: 27,
              80: [1, 28],
              81: [1, 29],
              82: [1, 30],
              83: [1, 31],
              84: [1, 32],
              85: [1, 34],
              86: 33
            }, {
              5: [2, 24],
              14: [2, 24],
              15: [2, 24],
              19: [2, 24],
              29: [2, 24],
              34: [2, 24],
              39: [2, 24],
              44: [2, 24],
              47: [2, 24],
              48: [2, 24],
              51: [2, 24],
              55: [2, 24],
              60: [2, 24]
            }, {68: [1, 130]}, {
              65: [2, 95],
              68: [2, 95],
              72: [2, 95],
              80: [2, 95],
              81: [2, 95],
              82: [2, 95],
              83: [2, 95],
              84: [2, 95],
              85: [2, 95]
            }, {68: [2, 97]}, {
              5: [2, 21],
              14: [2, 21],
              15: [2, 21],
              19: [2, 21],
              29: [2, 21],
              34: [2, 21],
              39: [2, 21],
              44: [2, 21],
              47: [2, 21],
              48: [2, 21],
              51: [2, 21],
              55: [2, 21],
              60: [2, 21]
            }, {33: [1, 131]}, {33: [2, 63]}, {
              72: [1, 133],
              76: 132
            }, {33: [1, 134]}, {33: [2, 69]}, {15: [2, 12]}, {
              14: [2, 26],
              15: [2, 26],
              19: [2, 26],
              29: [2, 26],
              34: [2, 26],
              47: [2, 26],
              48: [2, 26],
              51: [2, 26],
              55: [2, 26],
              60: [2, 26]
            }, {
              23: [2, 31],
              33: [2, 31],
              54: [2, 31],
              68: [2, 31],
              72: [2, 31],
              75: [2, 31]
            }, {
              33: [2, 74],
              42: 135,
              74: 136,
              75: [1, 121]
            }, {
              33: [2, 71],
              65: [2, 71],
              72: [2, 71],
              75: [2, 71],
              80: [2, 71],
              81: [2, 71],
              82: [2, 71],
              83: [2, 71],
              84: [2, 71],
              85: [2, 71]
            }, {
              33: [2, 73],
              75: [2, 73]
            }, {
              23: [2, 29],
              33: [2, 29],
              54: [2, 29],
              65: [2, 29],
              68: [2, 29],
              72: [2, 29],
              75: [2, 29],
              80: [2, 29],
              81: [2, 29],
              82: [2, 29],
              83: [2, 29],
              84: [2, 29],
              85: [2, 29]
            }, {
              14: [2, 15],
              15: [2, 15],
              19: [2, 15],
              29: [2, 15],
              34: [2, 15],
              39: [2, 15],
              44: [2, 15],
              47: [2, 15],
              48: [2, 15],
              51: [2, 15],
              55: [2, 15],
              60: [2, 15]
            }, {
              72: [1, 138],
              77: [1, 137]
            }, {
              72: [2, 100],
              77: [2, 100]
            }, {
              14: [2, 16],
              15: [2, 16],
              19: [2, 16],
              29: [2, 16],
              34: [2, 16],
              44: [2, 16],
              47: [2, 16],
              48: [2, 16],
              51: [2, 16],
              55: [2, 16],
              60: [2, 16]
            }, {33: [1, 139]}, {33: [2, 75]}, {33: [2, 32]}, {
              72: [2, 101],
              77: [2, 101]
            }, {
              14: [2, 17],
              15: [2, 17],
              19: [2, 17],
              29: [2, 17],
              34: [2, 17],
              39: [2, 17],
              44: [2, 17],
              47: [2, 17],
              48: [2, 17],
              51: [2, 17],
              55: [2, 17],
              60: [2, 17]
            }],
            defaultActions: {
              4: [2, 1],
              55: [2, 55],
              57: [2, 20],
              61: [2, 57],
              74: [2, 81],
              83: [2, 85],
              87: [2, 18],
              91: [2, 89],
              102: [2, 53],
              105: [2, 93],
              111: [2, 19],
              112: [2, 77],
              117: [2, 97],
              120: [2, 63],
              123: [2, 69],
              124: [2, 12],
              136: [2, 75],
              137: [2, 32]
            },
            parseError: function parseError(str, hash) {
              throw new Error(str);
            },
            parse: function parse(input) {
              var self = this,
                  stack = [0],
                  vstack = [null],
                  lstack = [],
                  table = this.table,
                  yytext = "",
                  yylineno = 0,
                  yyleng = 0,
                  recovering = 0,
                  TERROR = 2,
                  EOF = 1;
              this.lexer.setInput(input);
              this.lexer.yy = this.yy;
              this.yy.lexer = this.lexer;
              this.yy.parser = this;
              if (typeof this.lexer.yylloc == "undefined")
                this.lexer.yylloc = {};
              var yyloc = this.lexer.yylloc;
              lstack.push(yyloc);
              var ranges = this.lexer.options && this.lexer.options.ranges;
              if (typeof this.yy.parseError === "function")
                this.parseError = this.yy.parseError;
              function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
              }
              function lex() {
                var token;
                token = self.lexer.lex() || 1;
                if (typeof token !== "number") {
                  token = self.symbols_[token] || token;
                }
                return token;
              }
              var symbol,
                  preErrorSymbol,
                  state,
                  action,
                  a,
                  r,
                  yyval = {},
                  p,
                  len,
                  newState,
                  expected;
              while (true) {
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                  action = this.defaultActions[state];
                } else {
                  if (symbol === null || typeof symbol == "undefined") {
                    symbol = lex();
                  }
                  action = table[state] && table[state][symbol];
                }
                if (typeof action === "undefined" || !action.length || !action[0]) {
                  var errStr = "";
                  if (!recovering) {
                    expected = [];
                    for (p in table[state])
                      if (this.terminals_[p] && p > 2) {
                        expected.push("'" + this.terminals_[p] + "'");
                      }
                    if (this.lexer.showPosition) {
                      errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                    } else {
                      errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                    }
                    this.parseError(errStr, {
                      text: this.lexer.match,
                      token: this.terminals_[symbol] || symbol,
                      line: this.lexer.yylineno,
                      loc: yyloc,
                      expected: expected
                    });
                  }
                }
                if (action[0] instanceof Array && action.length > 1) {
                  throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                }
                switch (action[0]) {
                  case 1:
                    stack.push(symbol);
                    vstack.push(this.lexer.yytext);
                    lstack.push(this.lexer.yylloc);
                    stack.push(action[1]);
                    symbol = null;
                    if (!preErrorSymbol) {
                      yyleng = this.lexer.yyleng;
                      yytext = this.lexer.yytext;
                      yylineno = this.lexer.yylineno;
                      yyloc = this.lexer.yylloc;
                      if (recovering > 0)
                        recovering--;
                    } else {
                      symbol = preErrorSymbol;
                      preErrorSymbol = null;
                    }
                    break;
                  case 2:
                    len = this.productions_[action[1]][1];
                    yyval.$ = vstack[vstack.length - len];
                    yyval._$ = {
                      first_line: lstack[lstack.length - (len || 1)].first_line,
                      last_line: lstack[lstack.length - 1].last_line,
                      first_column: lstack[lstack.length - (len || 1)].first_column,
                      last_column: lstack[lstack.length - 1].last_column
                    };
                    if (ranges) {
                      yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                    }
                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                    if (typeof r !== "undefined") {
                      return r;
                    }
                    if (len) {
                      stack = stack.slice(0, -1 * len * 2);
                      vstack = vstack.slice(0, -1 * len);
                      lstack = lstack.slice(0, -1 * len);
                    }
                    stack.push(this.productions_[action[1]][0]);
                    vstack.push(yyval.$);
                    lstack.push(yyval._$);
                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                    stack.push(newState);
                    break;
                  case 3:
                    return true;
                }
              }
              return true;
            }
          };
          var lexer = (function() {
            var lexer = {
              EOF: 1,
              parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                  this.yy.parser.parseError(str, hash);
                } else {
                  throw new Error(str);
                }
              },
              setInput: function setInput(input) {
                this._input = input;
                this._more = this._less = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = {
                  first_line: 1,
                  first_column: 0,
                  last_line: 1,
                  last_column: 0
                };
                if (this.options.ranges)
                  this.yylloc.range = [0, 0];
                this.offset = 0;
                return this;
              },
              input: function input() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                  this.yylineno++;
                  this.yylloc.last_line++;
                } else {
                  this.yylloc.last_column++;
                }
                if (this.options.ranges)
                  this.yylloc.range[1]++;
                this._input = this._input.slice(1);
                return ch;
              },
              unput: function unput(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);
                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);
                if (lines.length - 1)
                  this.yylineno -= lines.length - 1;
                var r = this.yylloc.range;
                this.yylloc = {
                  first_line: this.yylloc.first_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.first_column,
                  last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };
                if (this.options.ranges) {
                  this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                return this;
              },
              more: function more() {
                this._more = true;
                return this;
              },
              less: function less(n) {
                this.unput(this.match.slice(n));
              },
              pastInput: function pastInput() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
              },
              upcomingInput: function upcomingInput() {
                var next = this.match;
                if (next.length < 20) {
                  next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
              },
              showPosition: function showPosition() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
              },
              next: function next() {
                if (this.done) {
                  return this.EOF;
                }
                if (!this._input)
                  this.done = true;
                var token,
                    match,
                    tempMatch,
                    index,
                    col,
                    lines;
                if (!this._more) {
                  this.yytext = '';
                  this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                  tempMatch = this._input.match(this.rules[rules[i]]);
                  if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                    match = tempMatch;
                    index = i;
                    if (!this.options.flex)
                      break;
                  }
                }
                if (match) {
                  lines = match[0].match(/(?:\r\n?|\n).*/g);
                  if (lines)
                    this.yylineno += lines.length;
                  this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                  };
                  this.yytext += match[0];
                  this.match += match[0];
                  this.matches = match;
                  this.yyleng = this.yytext.length;
                  if (this.options.ranges) {
                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
                  }
                  this._more = false;
                  this._input = this._input.slice(match[0].length);
                  this.matched += match[0];
                  token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                  if (this.done && this._input)
                    this.done = false;
                  if (token)
                    return token;
                  else
                    return;
                }
                if (this._input === "") {
                  return this.EOF;
                } else {
                  return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                }
              },
              lex: function lex() {
                var r = this.next();
                if (typeof r !== 'undefined') {
                  return r;
                } else {
                  return this.lex();
                }
              },
              begin: function begin(condition) {
                this.conditionStack.push(condition);
              },
              popState: function popState() {
                return this.conditionStack.pop();
              },
              _currentRules: function _currentRules() {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
              },
              topState: function topState() {
                return this.conditionStack[this.conditionStack.length - 2];
              },
              pushState: function begin(condition) {
                this.begin(condition);
              }
            };
            lexer.options = {};
            lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
              function strip(start, end) {
                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
              }
              var YYSTATE = YY_START;
              switch ($avoiding_name_collisions) {
                case 0:
                  if (yy_.yytext.slice(-2) === "\\\\") {
                    strip(0, 1);
                    this.begin("mu");
                  } else if (yy_.yytext.slice(-1) === "\\") {
                    strip(0, 1);
                    this.begin("emu");
                  } else {
                    this.begin("mu");
                  }
                  if (yy_.yytext)
                    return 15;
                  break;
                case 1:
                  return 15;
                  break;
                case 2:
                  this.popState();
                  return 15;
                  break;
                case 3:
                  this.begin('raw');
                  return 15;
                  break;
                case 4:
                  this.popState();
                  if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
                    return 15;
                  } else {
                    yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                    return 'END_RAW_BLOCK';
                  }
                  break;
                case 5:
                  return 15;
                  break;
                case 6:
                  this.popState();
                  return 14;
                  break;
                case 7:
                  return 65;
                  break;
                case 8:
                  return 68;
                  break;
                case 9:
                  return 19;
                  break;
                case 10:
                  this.popState();
                  this.begin('raw');
                  return 23;
                  break;
                case 11:
                  return 55;
                  break;
                case 12:
                  return 60;
                  break;
                case 13:
                  return 29;
                  break;
                case 14:
                  return 47;
                  break;
                case 15:
                  this.popState();
                  return 44;
                  break;
                case 16:
                  this.popState();
                  return 44;
                  break;
                case 17:
                  return 34;
                  break;
                case 18:
                  return 39;
                  break;
                case 19:
                  return 51;
                  break;
                case 20:
                  return 48;
                  break;
                case 21:
                  this.unput(yy_.yytext);
                  this.popState();
                  this.begin('com');
                  break;
                case 22:
                  this.popState();
                  return 14;
                  break;
                case 23:
                  return 48;
                  break;
                case 24:
                  return 73;
                  break;
                case 25:
                  return 72;
                  break;
                case 26:
                  return 72;
                  break;
                case 27:
                  return 87;
                  break;
                case 28:
                  break;
                case 29:
                  this.popState();
                  return 54;
                  break;
                case 30:
                  this.popState();
                  return 33;
                  break;
                case 31:
                  yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                  return 80;
                  break;
                case 32:
                  yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                  return 80;
                  break;
                case 33:
                  return 85;
                  break;
                case 34:
                  return 82;
                  break;
                case 35:
                  return 82;
                  break;
                case 36:
                  return 83;
                  break;
                case 37:
                  return 84;
                  break;
                case 38:
                  return 81;
                  break;
                case 39:
                  return 75;
                  break;
                case 40:
                  return 77;
                  break;
                case 41:
                  return 72;
                  break;
                case 42:
                  yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');
                  return 72;
                  break;
                case 43:
                  return 'INVALID';
                  break;
                case 44:
                  return 5;
                  break;
              }
            };
            lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
            lexer.conditions = {
              "mu": {
                "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
                "inclusive": false
              },
              "emu": {
                "rules": [2],
                "inclusive": false
              },
              "com": {
                "rules": [6],
                "inclusive": false
              },
              "raw": {
                "rules": [3, 4, 5],
                "inclusive": false
              },
              "INITIAL": {
                "rules": [0, 1, 44],
                "inclusive": true
              }
            };
            return lexer;
          })();
          parser.lexer = lexer;
          function Parser() {
            this.yy = {};
          }
          Parser.prototype = parser;
          parser.Parser = Parser;
          return new Parser();
        })();
        exports.__esModule = true;
        exports['default'] = handlebars;
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        var _visitor = __webpack_require__(25);
        var _visitor2 = _interopRequireDefault(_visitor);
        function WhitespaceControl() {
          var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
          this.options = options;
        }
        WhitespaceControl.prototype = new _visitor2['default']();
        WhitespaceControl.prototype.Program = function(program) {
          var doStandalone = !this.options.ignoreStandalone;
          var isRoot = !this.isRootSeen;
          this.isRootSeen = true;
          var body = program.body;
          for (var i = 0,
              l = body.length; i < l; i++) {
            var current = body[i],
                strip = this.accept(current);
            if (!strip) {
              continue;
            }
            var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
                _isNextWhitespace = isNextWhitespace(body, i, isRoot),
                openStandalone = strip.openStandalone && _isPrevWhitespace,
                closeStandalone = strip.closeStandalone && _isNextWhitespace,
                inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
            if (strip.close) {
              omitRight(body, i, true);
            }
            if (strip.open) {
              omitLeft(body, i, true);
            }
            if (doStandalone && inlineStandalone) {
              omitRight(body, i);
              if (omitLeft(body, i)) {
                if (current.type === 'PartialStatement') {
                  current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
                }
              }
            }
            if (doStandalone && openStandalone) {
              omitRight((current.program || current.inverse).body);
              omitLeft(body, i);
            }
            if (doStandalone && closeStandalone) {
              omitRight(body, i);
              omitLeft((current.inverse || current.program).body);
            }
          }
          return program;
        };
        WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
          this.accept(block.program);
          this.accept(block.inverse);
          var program = block.program || block.inverse,
              inverse = block.program && block.inverse,
              firstInverse = inverse,
              lastInverse = inverse;
          if (inverse && inverse.chained) {
            firstInverse = inverse.body[0].program;
            while (lastInverse.chained) {
              lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
            }
          }
          var strip = {
            open: block.openStrip.open,
            close: block.closeStrip.close,
            openStandalone: isNextWhitespace(program.body),
            closeStandalone: isPrevWhitespace((firstInverse || program).body)
          };
          if (block.openStrip.close) {
            omitRight(program.body, null, true);
          }
          if (inverse) {
            var inverseStrip = block.inverseStrip;
            if (inverseStrip.open) {
              omitLeft(program.body, null, true);
            }
            if (inverseStrip.close) {
              omitRight(firstInverse.body, null, true);
            }
            if (block.closeStrip.open) {
              omitLeft(lastInverse.body, null, true);
            }
            if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
              omitLeft(program.body);
              omitRight(firstInverse.body);
            }
          } else if (block.closeStrip.open) {
            omitLeft(program.body, null, true);
          }
          return strip;
        };
        WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
          return mustache.strip;
        };
        WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
          var strip = node.strip || {};
          return {
            inlineStandalone: true,
            open: strip.open,
            close: strip.close
          };
        };
        function isPrevWhitespace(body, i, isRoot) {
          if (i === undefined) {
            i = body.length;
          }
          var prev = body[i - 1],
              sibling = body[i - 2];
          if (!prev) {
            return isRoot;
          }
          if (prev.type === 'ContentStatement') {
            return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
          }
        }
        function isNextWhitespace(body, i, isRoot) {
          if (i === undefined) {
            i = -1;
          }
          var next = body[i + 1],
              sibling = body[i + 2];
          if (!next) {
            return isRoot;
          }
          if (next.type === 'ContentStatement') {
            return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
          }
        }
        function omitRight(body, i, multiple) {
          var current = body[i == null ? 0 : i + 1];
          if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
            return;
          }
          var original = current.value;
          current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
          current.rightStripped = current.value !== original;
        }
        function omitLeft(body, i, multiple) {
          var current = body[i == null ? body.length - 1 : i - 1];
          if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
            return;
          }
          var original = current.value;
          current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
          current.leftStripped = current.value !== original;
          return current.leftStripped;
        }
        exports['default'] = WhitespaceControl;
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        var _exception = __webpack_require__(6);
        var _exception2 = _interopRequireDefault(_exception);
        function Visitor() {
          this.parents = [];
        }
        Visitor.prototype = {
          constructor: Visitor,
          mutating: false,
          acceptKey: function acceptKey(node, name) {
            var value = this.accept(node[name]);
            if (this.mutating) {
              if (value && !Visitor.prototype[value.type]) {
                throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
              }
              node[name] = value;
            }
          },
          acceptRequired: function acceptRequired(node, name) {
            this.acceptKey(node, name);
            if (!node[name]) {
              throw new _exception2['default'](node.type + ' requires ' + name);
            }
          },
          acceptArray: function acceptArray(array) {
            for (var i = 0,
                l = array.length; i < l; i++) {
              this.acceptKey(array, i);
              if (!array[i]) {
                array.splice(i, 1);
                i--;
                l--;
              }
            }
          },
          accept: function accept(object) {
            if (!object) {
              return;
            }
            if (!this[object.type]) {
              throw new _exception2['default']('Unknown type: ' + object.type, object);
            }
            if (this.current) {
              this.parents.unshift(this.current);
            }
            this.current = object;
            var ret = this[object.type](object);
            this.current = this.parents.shift();
            if (!this.mutating || ret) {
              return ret;
            } else if (ret !== false) {
              return object;
            }
          },
          Program: function Program(program) {
            this.acceptArray(program.body);
          },
          MustacheStatement: visitSubExpression,
          Decorator: visitSubExpression,
          BlockStatement: visitBlock,
          DecoratorBlock: visitBlock,
          PartialStatement: visitPartial,
          PartialBlockStatement: function PartialBlockStatement(partial) {
            visitPartial.call(this, partial);
            this.acceptKey(partial, 'program');
          },
          ContentStatement: function ContentStatement() {},
          CommentStatement: function CommentStatement() {},
          SubExpression: visitSubExpression,
          PathExpression: function PathExpression() {},
          StringLiteral: function StringLiteral() {},
          NumberLiteral: function NumberLiteral() {},
          BooleanLiteral: function BooleanLiteral() {},
          UndefinedLiteral: function UndefinedLiteral() {},
          NullLiteral: function NullLiteral() {},
          Hash: function Hash(hash) {
            this.acceptArray(hash.pairs);
          },
          HashPair: function HashPair(pair) {
            this.acceptRequired(pair, 'value');
          }
        };
        function visitSubExpression(mustache) {
          this.acceptRequired(mustache, 'path');
          this.acceptArray(mustache.params);
          this.acceptKey(mustache, 'hash');
        }
        function visitBlock(block) {
          visitSubExpression.call(this, block);
          this.acceptKey(block, 'program');
          this.acceptKey(block, 'inverse');
        }
        function visitPartial(partial) {
          this.acceptRequired(partial, 'name');
          this.acceptArray(partial.params);
          this.acceptKey(partial, 'hash');
        }
        exports['default'] = Visitor;
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        exports.SourceLocation = SourceLocation;
        exports.id = id;
        exports.stripFlags = stripFlags;
        exports.stripComment = stripComment;
        exports.preparePath = preparePath;
        exports.prepareMustache = prepareMustache;
        exports.prepareRawBlock = prepareRawBlock;
        exports.prepareBlock = prepareBlock;
        exports.prepareProgram = prepareProgram;
        exports.preparePartialBlock = preparePartialBlock;
        var _exception = __webpack_require__(6);
        var _exception2 = _interopRequireDefault(_exception);
        function validateClose(open, close) {
          close = close.path ? close.path.original : close;
          if (open.path.original !== close) {
            var errorNode = {loc: open.path.loc};
            throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
          }
        }
        function SourceLocation(source, locInfo) {
          this.source = source;
          this.start = {
            line: locInfo.first_line,
            column: locInfo.first_column
          };
          this.end = {
            line: locInfo.last_line,
            column: locInfo.last_column
          };
        }
        function id(token) {
          if (/^\[.*\]$/.test(token)) {
            return token.substr(1, token.length - 2);
          } else {
            return token;
          }
        }
        function stripFlags(open, close) {
          return {
            open: open.charAt(2) === '~',
            close: close.charAt(close.length - 3) === '~'
          };
        }
        function stripComment(comment) {
          return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
        }
        function preparePath(data, parts, loc) {
          loc = this.locInfo(loc);
          var original = data ? '@' : '',
              dig = [],
              depth = 0,
              depthString = '';
          for (var i = 0,
              l = parts.length; i < l; i++) {
            var part = parts[i].part,
                isLiteral = parts[i].original !== part;
            original += (parts[i].separator || '') + part;
            if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
              if (dig.length > 0) {
                throw new _exception2['default']('Invalid path: ' + original, {loc: loc});
              } else if (part === '..') {
                depth++;
                depthString += '../';
              }
            } else {
              dig.push(part);
            }
          }
          return {
            type: 'PathExpression',
            data: data,
            depth: depth,
            parts: dig,
            original: original,
            loc: loc
          };
        }
        function prepareMustache(path, params, hash, open, strip, locInfo) {
          var escapeFlag = open.charAt(3) || open.charAt(2),
              escaped = escapeFlag !== '{' && escapeFlag !== '&';
          var decorator = /\*/.test(open);
          return {
            type: decorator ? 'Decorator' : 'MustacheStatement',
            path: path,
            params: params,
            hash: hash,
            escaped: escaped,
            strip: strip,
            loc: this.locInfo(locInfo)
          };
        }
        function prepareRawBlock(openRawBlock, contents, close, locInfo) {
          validateClose(openRawBlock, close);
          locInfo = this.locInfo(locInfo);
          var program = {
            type: 'Program',
            body: contents,
            strip: {},
            loc: locInfo
          };
          return {
            type: 'BlockStatement',
            path: openRawBlock.path,
            params: openRawBlock.params,
            hash: openRawBlock.hash,
            program: program,
            openStrip: {},
            inverseStrip: {},
            closeStrip: {},
            loc: locInfo
          };
        }
        function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
          if (close && close.path) {
            validateClose(openBlock, close);
          }
          var decorator = /\*/.test(openBlock.open);
          program.blockParams = openBlock.blockParams;
          var inverse = undefined,
              inverseStrip = undefined;
          if (inverseAndProgram) {
            if (decorator) {
              throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
            }
            if (inverseAndProgram.chain) {
              inverseAndProgram.program.body[0].closeStrip = close.strip;
            }
            inverseStrip = inverseAndProgram.strip;
            inverse = inverseAndProgram.program;
          }
          if (inverted) {
            inverted = inverse;
            inverse = program;
            program = inverted;
          }
          return {
            type: decorator ? 'DecoratorBlock' : 'BlockStatement',
            path: openBlock.path,
            params: openBlock.params,
            hash: openBlock.hash,
            program: program,
            inverse: inverse,
            openStrip: openBlock.strip,
            inverseStrip: inverseStrip,
            closeStrip: close && close.strip,
            loc: this.locInfo(locInfo)
          };
        }
        function prepareProgram(statements, loc) {
          if (!loc && statements.length) {
            var firstLoc = statements[0].loc,
                lastLoc = statements[statements.length - 1].loc;
            if (firstLoc && lastLoc) {
              loc = {
                source: firstLoc.source,
                start: {
                  line: firstLoc.start.line,
                  column: firstLoc.start.column
                },
                end: {
                  line: lastLoc.end.line,
                  column: lastLoc.end.column
                }
              };
            }
          }
          return {
            type: 'Program',
            body: statements,
            strip: {},
            loc: loc
          };
        }
        function preparePartialBlock(open, program, close, locInfo) {
          validateClose(open, close);
          return {
            type: 'PartialBlockStatement',
            name: open.path,
            params: open.params,
            hash: open.hash,
            program: program,
            openStrip: open.strip,
            closeStrip: close && close.strip,
            loc: this.locInfo(locInfo)
          };
        }
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        exports.Compiler = Compiler;
        exports.precompile = precompile;
        exports.compile = compile;
        var _exception = __webpack_require__(6);
        var _exception2 = _interopRequireDefault(_exception);
        var _utils = __webpack_require__(5);
        var _ast = __webpack_require__(21);
        var _ast2 = _interopRequireDefault(_ast);
        var slice = [].slice;
        function Compiler() {}
        Compiler.prototype = {
          compiler: Compiler,
          equals: function equals(other) {
            var len = this.opcodes.length;
            if (other.opcodes.length !== len) {
              return false;
            }
            for (var i = 0; i < len; i++) {
              var opcode = this.opcodes[i],
                  otherOpcode = other.opcodes[i];
              if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
                return false;
              }
            }
            len = this.children.length;
            for (var i = 0; i < len; i++) {
              if (!this.children[i].equals(other.children[i])) {
                return false;
              }
            }
            return true;
          },
          guid: 0,
          compile: function compile(program, options) {
            this.sourceNode = [];
            this.opcodes = [];
            this.children = [];
            this.options = options;
            this.stringParams = options.stringParams;
            this.trackIds = options.trackIds;
            options.blockParams = options.blockParams || [];
            var knownHelpers = options.knownHelpers;
            options.knownHelpers = {
              'helperMissing': true,
              'blockHelperMissing': true,
              'each': true,
              'if': true,
              'unless': true,
              'with': true,
              'log': true,
              'lookup': true
            };
            if (knownHelpers) {
              for (var _name in knownHelpers) {
                if (_name in knownHelpers) {
                  options.knownHelpers[_name] = knownHelpers[_name];
                }
              }
            }
            return this.accept(program);
          },
          compileProgram: function compileProgram(program) {
            var childCompiler = new this.compiler(),
                result = childCompiler.compile(program, this.options),
                guid = this.guid++;
            this.usePartial = this.usePartial || result.usePartial;
            this.children[guid] = result;
            this.useDepths = this.useDepths || result.useDepths;
            return guid;
          },
          accept: function accept(node) {
            if (!this[node.type]) {
              throw new _exception2['default']('Unknown type: ' + node.type, node);
            }
            this.sourceNode.unshift(node);
            var ret = this[node.type](node);
            this.sourceNode.shift();
            return ret;
          },
          Program: function Program(program) {
            this.options.blockParams.unshift(program.blockParams);
            var body = program.body,
                bodyLength = body.length;
            for (var i = 0; i < bodyLength; i++) {
              this.accept(body[i]);
            }
            this.options.blockParams.shift();
            this.isSimple = bodyLength === 1;
            this.blockParams = program.blockParams ? program.blockParams.length : 0;
            return this;
          },
          BlockStatement: function BlockStatement(block) {
            transformLiteralToPath(block);
            var program = block.program,
                inverse = block.inverse;
            program = program && this.compileProgram(program);
            inverse = inverse && this.compileProgram(inverse);
            var type = this.classifySexpr(block);
            if (type === 'helper') {
              this.helperSexpr(block, program, inverse);
            } else if (type === 'simple') {
              this.simpleSexpr(block);
              this.opcode('pushProgram', program);
              this.opcode('pushProgram', inverse);
              this.opcode('emptyHash');
              this.opcode('blockValue', block.path.original);
            } else {
              this.ambiguousSexpr(block, program, inverse);
              this.opcode('pushProgram', program);
              this.opcode('pushProgram', inverse);
              this.opcode('emptyHash');
              this.opcode('ambiguousBlockValue');
            }
            this.opcode('append');
          },
          DecoratorBlock: function DecoratorBlock(decorator) {
            var program = decorator.program && this.compileProgram(decorator.program);
            var params = this.setupFullMustacheParams(decorator, program, undefined),
                path = decorator.path;
            this.useDecorators = true;
            this.opcode('registerDecorator', params.length, path.original);
          },
          PartialStatement: function PartialStatement(partial) {
            this.usePartial = true;
            var program = partial.program;
            if (program) {
              program = this.compileProgram(partial.program);
            }
            var params = partial.params;
            if (params.length > 1) {
              throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
            } else if (!params.length) {
              if (this.options.explicitPartialContext) {
                this.opcode('pushLiteral', 'undefined');
              } else {
                params.push({
                  type: 'PathExpression',
                  parts: [],
                  depth: 0
                });
              }
            }
            var partialName = partial.name.original,
                isDynamic = partial.name.type === 'SubExpression';
            if (isDynamic) {
              this.accept(partial.name);
            }
            this.setupFullMustacheParams(partial, program, undefined, true);
            var indent = partial.indent || '';
            if (this.options.preventIndent && indent) {
              this.opcode('appendContent', indent);
              indent = '';
            }
            this.opcode('invokePartial', isDynamic, partialName, indent);
            this.opcode('append');
          },
          PartialBlockStatement: function PartialBlockStatement(partialBlock) {
            this.PartialStatement(partialBlock);
          },
          MustacheStatement: function MustacheStatement(mustache) {
            this.SubExpression(mustache);
            if (mustache.escaped && !this.options.noEscape) {
              this.opcode('appendEscaped');
            } else {
              this.opcode('append');
            }
          },
          Decorator: function Decorator(decorator) {
            this.DecoratorBlock(decorator);
          },
          ContentStatement: function ContentStatement(content) {
            if (content.value) {
              this.opcode('appendContent', content.value);
            }
          },
          CommentStatement: function CommentStatement() {},
          SubExpression: function SubExpression(sexpr) {
            transformLiteralToPath(sexpr);
            var type = this.classifySexpr(sexpr);
            if (type === 'simple') {
              this.simpleSexpr(sexpr);
            } else if (type === 'helper') {
              this.helperSexpr(sexpr);
            } else {
              this.ambiguousSexpr(sexpr);
            }
          },
          ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
            var path = sexpr.path,
                name = path.parts[0],
                isBlock = program != null || inverse != null;
            this.opcode('getContext', path.depth);
            this.opcode('pushProgram', program);
            this.opcode('pushProgram', inverse);
            path.strict = true;
            this.accept(path);
            this.opcode('invokeAmbiguous', name, isBlock);
          },
          simpleSexpr: function simpleSexpr(sexpr) {
            var path = sexpr.path;
            path.strict = true;
            this.accept(path);
            this.opcode('resolvePossibleLambda');
          },
          helperSexpr: function helperSexpr(sexpr, program, inverse) {
            var params = this.setupFullMustacheParams(sexpr, program, inverse),
                path = sexpr.path,
                name = path.parts[0];
            if (this.options.knownHelpers[name]) {
              this.opcode('invokeKnownHelper', params.length, name);
            } else if (this.options.knownHelpersOnly) {
              throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
            } else {
              path.strict = true;
              path.falsy = true;
              this.accept(path);
              this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
            }
          },
          PathExpression: function PathExpression(path) {
            this.addDepth(path.depth);
            this.opcode('getContext', path.depth);
            var name = path.parts[0],
                scoped = _ast2['default'].helpers.scopedId(path),
                blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
            if (blockParamId) {
              this.opcode('lookupBlockParam', blockParamId, path.parts);
            } else if (!name) {
              this.opcode('pushContext');
            } else if (path.data) {
              this.options.data = true;
              this.opcode('lookupData', path.depth, path.parts, path.strict);
            } else {
              this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
            }
          },
          StringLiteral: function StringLiteral(string) {
            this.opcode('pushString', string.value);
          },
          NumberLiteral: function NumberLiteral(number) {
            this.opcode('pushLiteral', number.value);
          },
          BooleanLiteral: function BooleanLiteral(bool) {
            this.opcode('pushLiteral', bool.value);
          },
          UndefinedLiteral: function UndefinedLiteral() {
            this.opcode('pushLiteral', 'undefined');
          },
          NullLiteral: function NullLiteral() {
            this.opcode('pushLiteral', 'null');
          },
          Hash: function Hash(hash) {
            var pairs = hash.pairs,
                i = 0,
                l = pairs.length;
            this.opcode('pushHash');
            for (; i < l; i++) {
              this.pushParam(pairs[i].value);
            }
            while (i--) {
              this.opcode('assignToHash', pairs[i].key);
            }
            this.opcode('popHash');
          },
          opcode: function opcode(name) {
            this.opcodes.push({
              opcode: name,
              args: slice.call(arguments, 1),
              loc: this.sourceNode[0].loc
            });
          },
          addDepth: function addDepth(depth) {
            if (!depth) {
              return;
            }
            this.useDepths = true;
          },
          classifySexpr: function classifySexpr(sexpr) {
            var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);
            var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
            var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);
            var isEligible = !isBlockParam && (isHelper || isSimple);
            if (isEligible && !isHelper) {
              var _name2 = sexpr.path.parts[0],
                  options = this.options;
              if (options.knownHelpers[_name2]) {
                isHelper = true;
              } else if (options.knownHelpersOnly) {
                isEligible = false;
              }
            }
            if (isHelper) {
              return 'helper';
            } else if (isEligible) {
              return 'ambiguous';
            } else {
              return 'simple';
            }
          },
          pushParams: function pushParams(params) {
            for (var i = 0,
                l = params.length; i < l; i++) {
              this.pushParam(params[i]);
            }
          },
          pushParam: function pushParam(val) {
            var value = val.value != null ? val.value : val.original || '';
            if (this.stringParams) {
              if (value.replace) {
                value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
              }
              if (val.depth) {
                this.addDepth(val.depth);
              }
              this.opcode('getContext', val.depth || 0);
              this.opcode('pushStringParam', value, val.type);
              if (val.type === 'SubExpression') {
                this.accept(val);
              }
            } else {
              if (this.trackIds) {
                var blockParamIndex = undefined;
                if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
                  blockParamIndex = this.blockParamIndex(val.parts[0]);
                }
                if (blockParamIndex) {
                  var blockParamChild = val.parts.slice(1).join('.');
                  this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
                } else {
                  value = val.original || value;
                  if (value.replace) {
                    value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
                  }
                  this.opcode('pushId', val.type, value);
                }
              }
              this.accept(val);
            }
          },
          setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
            var params = sexpr.params;
            this.pushParams(params);
            this.opcode('pushProgram', program);
            this.opcode('pushProgram', inverse);
            if (sexpr.hash) {
              this.accept(sexpr.hash);
            } else {
              this.opcode('emptyHash', omitEmpty);
            }
            return params;
          },
          blockParamIndex: function blockParamIndex(name) {
            for (var depth = 0,
                len = this.options.blockParams.length; depth < len; depth++) {
              var blockParams = this.options.blockParams[depth],
                  param = blockParams && _utils.indexOf(blockParams, name);
              if (blockParams && param >= 0) {
                return [depth, param];
              }
            }
          }
        };
        function precompile(input, options, env) {
          if (input == null || typeof input !== 'string' && input.type !== 'Program') {
            throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
          }
          options = options || {};
          if (!('data' in options)) {
            options.data = true;
          }
          if (options.compat) {
            options.useDepths = true;
          }
          var ast = env.parse(input, options),
              environment = new env.Compiler().compile(ast, options);
          return new env.JavaScriptCompiler().compile(environment, options);
        }
        function compile(input, options, env) {
          if (options === undefined)
            options = {};
          if (input == null || typeof input !== 'string' && input.type !== 'Program') {
            throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
          }
          if (!('data' in options)) {
            options.data = true;
          }
          if (options.compat) {
            options.useDepths = true;
          }
          var compiled = undefined;
          function compileInput() {
            var ast = env.parse(input, options),
                environment = new env.Compiler().compile(ast, options),
                templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
            return env.template(templateSpec);
          }
          function ret(context, execOptions) {
            if (!compiled) {
              compiled = compileInput();
            }
            return compiled.call(this, context, execOptions);
          }
          ret._setup = function(setupOptions) {
            if (!compiled) {
              compiled = compileInput();
            }
            return compiled._setup(setupOptions);
          };
          ret._child = function(i, data, blockParams, depths) {
            if (!compiled) {
              compiled = compileInput();
            }
            return compiled._child(i, data, blockParams, depths);
          };
          return ret;
        }
        function argEquals(a, b) {
          if (a === b) {
            return true;
          }
          if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
            for (var i = 0; i < a.length; i++) {
              if (!argEquals(a[i], b[i])) {
                return false;
              }
            }
            return true;
          }
        }
        function transformLiteralToPath(sexpr) {
          if (!sexpr.path.parts) {
            var literal = sexpr.path;
            sexpr.path = {
              type: 'PathExpression',
              data: false,
              depth: 0,
              parts: [literal.original + ''],
              original: literal.original + '',
              loc: literal.loc
            };
          }
        }
      }, function(module, exports, __webpack_require__) {
        'use strict';
        var _interopRequireDefault = __webpack_require__(1)['default'];
        exports.__esModule = true;
        var _base = __webpack_require__(4);
        var _exception = __webpack_require__(6);
        var _exception2 = _interopRequireDefault(_exception);
        var _utils = __webpack_require__(5);
        var _codeGen = __webpack_require__(29);
        var _codeGen2 = _interopRequireDefault(_codeGen);
        function Literal(value) {
          this.value = value;
        }
        function JavaScriptCompiler() {}
        JavaScriptCompiler.prototype = {
          nameLookup: function nameLookup(parent, name) {
            if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
              return [parent, '.', name];
            } else {
              return [parent, '[', JSON.stringify(name), ']'];
            }
          },
          depthedLookup: function depthedLookup(name) {
            return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
          },
          compilerInfo: function compilerInfo() {
            var revision = _base.COMPILER_REVISION,
                versions = _base.REVISION_CHANGES[revision];
            return [revision, versions];
          },
          appendToBuffer: function appendToBuffer(source, location, explicit) {
            if (!_utils.isArray(source)) {
              source = [source];
            }
            source = this.source.wrap(source, location);
            if (this.environment.isSimple) {
              return ['return ', source, ';'];
            } else if (explicit) {
              return ['buffer += ', source, ';'];
            } else {
              source.appendToBuffer = true;
              return source;
            }
          },
          initializeBuffer: function initializeBuffer() {
            return this.quotedString('');
          },
          compile: function compile(environment, options, context, asObject) {
            this.environment = environment;
            this.options = options;
            this.stringParams = this.options.stringParams;
            this.trackIds = this.options.trackIds;
            this.precompile = !asObject;
            this.name = this.environment.name;
            this.isChild = !!context;
            this.context = context || {
              decorators: [],
              programs: [],
              environments: []
            };
            this.preamble();
            this.stackSlot = 0;
            this.stackVars = [];
            this.aliases = {};
            this.registers = {list: []};
            this.hashes = [];
            this.compileStack = [];
            this.inlineStack = [];
            this.blockParams = [];
            this.compileChildren(environment, options);
            this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
            this.useBlockParams = this.useBlockParams || environment.useBlockParams;
            var opcodes = environment.opcodes,
                opcode = undefined,
                firstLoc = undefined,
                i = undefined,
                l = undefined;
            for (i = 0, l = opcodes.length; i < l; i++) {
              opcode = opcodes[i];
              this.source.currentLocation = opcode.loc;
              firstLoc = firstLoc || opcode.loc;
              this[opcode.opcode].apply(this, opcode.args);
            }
            this.source.currentLocation = firstLoc;
            this.pushSource('');
            if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
              throw new _exception2['default']('Compile completed with content left on stack');
            }
            if (!this.decorators.isEmpty()) {
              this.useDecorators = true;
              this.decorators.prepend('var decorators = container.decorators;\n');
              this.decorators.push('return fn;');
              if (asObject) {
                this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
              } else {
                this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
                this.decorators.push('}\n');
                this.decorators = this.decorators.merge();
              }
            } else {
              this.decorators = undefined;
            }
            var fn = this.createFunctionContext(asObject);
            if (!this.isChild) {
              var ret = {
                compiler: this.compilerInfo(),
                main: fn
              };
              if (this.decorators) {
                ret.main_d = this.decorators;
                ret.useDecorators = true;
              }
              var _context = this.context;
              var programs = _context.programs;
              var decorators = _context.decorators;
              for (i = 0, l = programs.length; i < l; i++) {
                if (programs[i]) {
                  ret[i] = programs[i];
                  if (decorators[i]) {
                    ret[i + '_d'] = decorators[i];
                    ret.useDecorators = true;
                  }
                }
              }
              if (this.environment.usePartial) {
                ret.usePartial = true;
              }
              if (this.options.data) {
                ret.useData = true;
              }
              if (this.useDepths) {
                ret.useDepths = true;
              }
              if (this.useBlockParams) {
                ret.useBlockParams = true;
              }
              if (this.options.compat) {
                ret.compat = true;
              }
              if (!asObject) {
                ret.compiler = JSON.stringify(ret.compiler);
                this.source.currentLocation = {start: {
                    line: 1,
                    column: 0
                  }};
                ret = this.objectLiteral(ret);
                if (options.srcName) {
                  ret = ret.toStringWithSourceMap({file: options.destName});
                  ret.map = ret.map && ret.map.toString();
                } else {
                  ret = ret.toString();
                }
              } else {
                ret.compilerOptions = this.options;
              }
              return ret;
            } else {
              return fn;
            }
          },
          preamble: function preamble() {
            this.lastContext = 0;
            this.source = new _codeGen2['default'](this.options.srcName);
            this.decorators = new _codeGen2['default'](this.options.srcName);
          },
          createFunctionContext: function createFunctionContext(asObject) {
            var varDeclarations = '';
            var locals = this.stackVars.concat(this.registers.list);
            if (locals.length > 0) {
              varDeclarations += ', ' + locals.join(', ');
            }
            var aliasCount = 0;
            for (var alias in this.aliases) {
              var node = this.aliases[alias];
              if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
                varDeclarations += ', alias' + ++aliasCount + '=' + alias;
                node.children[0] = 'alias' + aliasCount;
              }
            }
            var params = ['container', 'depth0', 'helpers', 'partials', 'data'];
            if (this.useBlockParams || this.useDepths) {
              params.push('blockParams');
            }
            if (this.useDepths) {
              params.push('depths');
            }
            var source = this.mergeSource(varDeclarations);
            if (asObject) {
              params.push(source);
              return Function.apply(this, params);
            } else {
              return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
            }
          },
          mergeSource: function mergeSource(varDeclarations) {
            var isSimple = this.environment.isSimple,
                appendOnly = !this.forceBuffer,
                appendFirst = undefined,
                sourceSeen = undefined,
                bufferStart = undefined,
                bufferEnd = undefined;
            this.source.each(function(line) {
              if (line.appendToBuffer) {
                if (bufferStart) {
                  line.prepend('  + ');
                } else {
                  bufferStart = line;
                }
                bufferEnd = line;
              } else {
                if (bufferStart) {
                  if (!sourceSeen) {
                    appendFirst = true;
                  } else {
                    bufferStart.prepend('buffer += ');
                  }
                  bufferEnd.add(';');
                  bufferStart = bufferEnd = undefined;
                }
                sourceSeen = true;
                if (!isSimple) {
                  appendOnly = false;
                }
              }
            });
            if (appendOnly) {
              if (bufferStart) {
                bufferStart.prepend('return ');
                bufferEnd.add(';');
              } else if (!sourceSeen) {
                this.source.push('return "";');
              }
            } else {
              varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());
              if (bufferStart) {
                bufferStart.prepend('return buffer + ');
                bufferEnd.add(';');
              } else {
                this.source.push('return buffer;');
              }
            }
            if (varDeclarations) {
              this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
            }
            return this.source.merge();
          },
          blockValue: function blockValue(name) {
            var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                params = [this.contextName(0)];
            this.setupHelperArgs(name, 0, params);
            var blockName = this.popStack();
            params.splice(1, 0, blockName);
            this.push(this.source.functionCall(blockHelperMissing, 'call', params));
          },
          ambiguousBlockValue: function ambiguousBlockValue() {
            var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                params = [this.contextName(0)];
            this.setupHelperArgs('', 0, params, true);
            this.flushInline();
            var current = this.topStack();
            params.splice(1, 0, current);
            this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
          },
          appendContent: function appendContent(content) {
            if (this.pendingContent) {
              content = this.pendingContent + content;
            } else {
              this.pendingLocation = this.source.currentLocation;
            }
            this.pendingContent = content;
          },
          append: function append() {
            if (this.isInline()) {
              this.replaceStack(function(current) {
                return [' != null ? ', current, ' : ""'];
              });
              this.pushSource(this.appendToBuffer(this.popStack()));
            } else {
              var local = this.popStack();
              this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
              if (this.environment.isSimple) {
                this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
              }
            }
          },
          appendEscaped: function appendEscaped() {
            this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
          },
          getContext: function getContext(depth) {
            this.lastContext = depth;
          },
          pushContext: function pushContext() {
            this.pushStackLiteral(this.contextName(this.lastContext));
          },
          lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
            var i = 0;
            if (!scoped && this.options.compat && !this.lastContext) {
              this.push(this.depthedLookup(parts[i++]));
            } else {
              this.pushContext();
            }
            this.resolvePath('context', parts, i, falsy, strict);
          },
          lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
            this.useBlockParams = true;
            this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
            this.resolvePath('context', parts, 1);
          },
          lookupData: function lookupData(depth, parts, strict) {
            if (!depth) {
              this.pushStackLiteral('data');
            } else {
              this.pushStackLiteral('container.data(data, ' + depth + ')');
            }
            this.resolvePath('data', parts, 0, true, strict);
          },
          resolvePath: function resolvePath(type, parts, i, falsy, strict) {
            var _this = this;
            if (this.options.strict || this.options.assumeObjects) {
              this.push(strictLookup(this.options.strict && strict, this, parts, type));
              return;
            }
            var len = parts.length;
            for (; i < len; i++) {
              this.replaceStack(function(current) {
                var lookup = _this.nameLookup(current, parts[i], type);
                if (!falsy) {
                  return [' != null ? ', lookup, ' : ', current];
                } else {
                  return [' && ', lookup];
                }
              });
            }
          },
          resolvePossibleLambda: function resolvePossibleLambda() {
            this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
          },
          pushStringParam: function pushStringParam(string, type) {
            this.pushContext();
            this.pushString(type);
            if (type !== 'SubExpression') {
              if (typeof string === 'string') {
                this.pushString(string);
              } else {
                this.pushStackLiteral(string);
              }
            }
          },
          emptyHash: function emptyHash(omitEmpty) {
            if (this.trackIds) {
              this.push('{}');
            }
            if (this.stringParams) {
              this.push('{}');
              this.push('{}');
            }
            this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
          },
          pushHash: function pushHash() {
            if (this.hash) {
              this.hashes.push(this.hash);
            }
            this.hash = {
              values: [],
              types: [],
              contexts: [],
              ids: []
            };
          },
          popHash: function popHash() {
            var hash = this.hash;
            this.hash = this.hashes.pop();
            if (this.trackIds) {
              this.push(this.objectLiteral(hash.ids));
            }
            if (this.stringParams) {
              this.push(this.objectLiteral(hash.contexts));
              this.push(this.objectLiteral(hash.types));
            }
            this.push(this.objectLiteral(hash.values));
          },
          pushString: function pushString(string) {
            this.pushStackLiteral(this.quotedString(string));
          },
          pushLiteral: function pushLiteral(value) {
            this.pushStackLiteral(value);
          },
          pushProgram: function pushProgram(guid) {
            if (guid != null) {
              this.pushStackLiteral(this.programExpression(guid));
            } else {
              this.pushStackLiteral(null);
            }
          },
          registerDecorator: function registerDecorator(paramSize, name) {
            var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
                options = this.setupHelperArgs(name, paramSize);
            this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
          },
          invokeHelper: function invokeHelper(paramSize, name, isSimple) {
            var nonHelper = this.popStack(),
                helper = this.setupHelper(paramSize, name),
                simple = isSimple ? [helper.name, ' || '] : '';
            var lookup = ['('].concat(simple, nonHelper);
            if (!this.options.strict) {
              lookup.push(' || ', this.aliasable('helpers.helperMissing'));
            }
            lookup.push(')');
            this.push(this.source.functionCall(lookup, 'call', helper.callParams));
          },
          invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
            var helper = this.setupHelper(paramSize, name);
            this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
          },
          invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
            this.useRegister('helper');
            var nonHelper = this.popStack();
            this.emptyHash();
            var helper = this.setupHelper(0, name, helperCall);
            var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
            var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
            if (!this.options.strict) {
              lookup[0] = '(helper = ';
              lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
            }
            this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
          },
          invokePartial: function invokePartial(isDynamic, name, indent) {
            var params = [],
                options = this.setupParams(name, 1, params);
            if (isDynamic) {
              name = this.popStack();
              delete options.name;
            }
            if (indent) {
              options.indent = JSON.stringify(indent);
            }
            options.helpers = 'helpers';
            options.partials = 'partials';
            options.decorators = 'container.decorators';
            if (!isDynamic) {
              params.unshift(this.nameLookup('partials', name, 'partial'));
            } else {
              params.unshift(name);
            }
            if (this.options.compat) {
              options.depths = 'depths';
            }
            options = this.objectLiteral(options);
            params.push(options);
            this.push(this.source.functionCall('container.invokePartial', '', params));
          },
          assignToHash: function assignToHash(key) {
            var value = this.popStack(),
                context = undefined,
                type = undefined,
                id = undefined;
            if (this.trackIds) {
              id = this.popStack();
            }
            if (this.stringParams) {
              type = this.popStack();
              context = this.popStack();
            }
            var hash = this.hash;
            if (context) {
              hash.contexts[key] = context;
            }
            if (type) {
              hash.types[key] = type;
            }
            if (id) {
              hash.ids[key] = id;
            }
            hash.values[key] = value;
          },
          pushId: function pushId(type, name, child) {
            if (type === 'BlockParam') {
              this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
            } else if (type === 'PathExpression') {
              this.pushString(name);
            } else if (type === 'SubExpression') {
              this.pushStackLiteral('true');
            } else {
              this.pushStackLiteral('null');
            }
          },
          compiler: JavaScriptCompiler,
          compileChildren: function compileChildren(environment, options) {
            var children = environment.children,
                child = undefined,
                compiler = undefined;
            for (var i = 0,
                l = children.length; i < l; i++) {
              child = children[i];
              compiler = new this.compiler();
              var index = this.matchExistingProgram(child);
              if (index == null) {
                this.context.programs.push('');
                index = this.context.programs.length;
                child.index = index;
                child.name = 'program' + index;
                this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
                this.context.decorators[index] = compiler.decorators;
                this.context.environments[index] = child;
                this.useDepths = this.useDepths || compiler.useDepths;
                this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
              } else {
                child.index = index;
                child.name = 'program' + index;
                this.useDepths = this.useDepths || child.useDepths;
                this.useBlockParams = this.useBlockParams || child.useBlockParams;
              }
            }
          },
          matchExistingProgram: function matchExistingProgram(child) {
            for (var i = 0,
                len = this.context.environments.length; i < len; i++) {
              var environment = this.context.environments[i];
              if (environment && environment.equals(child)) {
                return i;
              }
            }
          },
          programExpression: function programExpression(guid) {
            var child = this.environment.children[guid],
                programParams = [child.index, 'data', child.blockParams];
            if (this.useBlockParams || this.useDepths) {
              programParams.push('blockParams');
            }
            if (this.useDepths) {
              programParams.push('depths');
            }
            return 'container.program(' + programParams.join(', ') + ')';
          },
          useRegister: function useRegister(name) {
            if (!this.registers[name]) {
              this.registers[name] = true;
              this.registers.list.push(name);
            }
          },
          push: function push(expr) {
            if (!(expr instanceof Literal)) {
              expr = this.source.wrap(expr);
            }
            this.inlineStack.push(expr);
            return expr;
          },
          pushStackLiteral: function pushStackLiteral(item) {
            this.push(new Literal(item));
          },
          pushSource: function pushSource(source) {
            if (this.pendingContent) {
              this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
              this.pendingContent = undefined;
            }
            if (source) {
              this.source.push(source);
            }
          },
          replaceStack: function replaceStack(callback) {
            var prefix = ['('],
                stack = undefined,
                createdStack = undefined,
                usedLiteral = undefined;
            if (!this.isInline()) {
              throw new _exception2['default']('replaceStack on non-inline');
            }
            var top = this.popStack(true);
            if (top instanceof Literal) {
              stack = [top.value];
              prefix = ['(', stack];
              usedLiteral = true;
            } else {
              createdStack = true;
              var _name = this.incrStack();
              prefix = ['((', this.push(_name), ' = ', top, ')'];
              stack = this.topStack();
            }
            var item = callback.call(this, stack);
            if (!usedLiteral) {
              this.popStack();
            }
            if (createdStack) {
              this.stackSlot--;
            }
            this.push(prefix.concat(item, ')'));
          },
          incrStack: function incrStack() {
            this.stackSlot++;
            if (this.stackSlot > this.stackVars.length) {
              this.stackVars.push('stack' + this.stackSlot);
            }
            return this.topStackName();
          },
          topStackName: function topStackName() {
            return 'stack' + this.stackSlot;
          },
          flushInline: function flushInline() {
            var inlineStack = this.inlineStack;
            this.inlineStack = [];
            for (var i = 0,
                len = inlineStack.length; i < len; i++) {
              var entry = inlineStack[i];
              if (entry instanceof Literal) {
                this.compileStack.push(entry);
              } else {
                var stack = this.incrStack();
                this.pushSource([stack, ' = ', entry, ';']);
                this.compileStack.push(stack);
              }
            }
          },
          isInline: function isInline() {
            return this.inlineStack.length;
          },
          popStack: function popStack(wrapped) {
            var inline = this.isInline(),
                item = (inline ? this.inlineStack : this.compileStack).pop();
            if (!wrapped && item instanceof Literal) {
              return item.value;
            } else {
              if (!inline) {
                if (!this.stackSlot) {
                  throw new _exception2['default']('Invalid stack pop');
                }
                this.stackSlot--;
              }
              return item;
            }
          },
          topStack: function topStack() {
            var stack = this.isInline() ? this.inlineStack : this.compileStack,
                item = stack[stack.length - 1];
            if (item instanceof Literal) {
              return item.value;
            } else {
              return item;
            }
          },
          contextName: function contextName(context) {
            if (this.useDepths && context) {
              return 'depths[' + context + ']';
            } else {
              return 'depth' + context;
            }
          },
          quotedString: function quotedString(str) {
            return this.source.quotedString(str);
          },
          objectLiteral: function objectLiteral(obj) {
            return this.source.objectLiteral(obj);
          },
          aliasable: function aliasable(name) {
            var ret = this.aliases[name];
            if (ret) {
              ret.referenceCount++;
              return ret;
            }
            ret = this.aliases[name] = this.source.wrap(name);
            ret.aliasable = true;
            ret.referenceCount = 1;
            return ret;
          },
          setupHelper: function setupHelper(paramSize, name, blockHelper) {
            var params = [],
                paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
            var foundHelper = this.nameLookup('helpers', name, 'helper'),
                callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');
            return {
              params: params,
              paramsInit: paramsInit,
              name: foundHelper,
              callParams: [callContext].concat(params)
            };
          },
          setupParams: function setupParams(helper, paramSize, params) {
            var options = {},
                contexts = [],
                types = [],
                ids = [],
                objectArgs = !params,
                param = undefined;
            if (objectArgs) {
              params = [];
            }
            options.name = this.quotedString(helper);
            options.hash = this.popStack();
            if (this.trackIds) {
              options.hashIds = this.popStack();
            }
            if (this.stringParams) {
              options.hashTypes = this.popStack();
              options.hashContexts = this.popStack();
            }
            var inverse = this.popStack(),
                program = this.popStack();
            if (program || inverse) {
              options.fn = program || 'container.noop';
              options.inverse = inverse || 'container.noop';
            }
            var i = paramSize;
            while (i--) {
              param = this.popStack();
              params[i] = param;
              if (this.trackIds) {
                ids[i] = this.popStack();
              }
              if (this.stringParams) {
                types[i] = this.popStack();
                contexts[i] = this.popStack();
              }
            }
            if (objectArgs) {
              options.args = this.source.generateArray(params);
            }
            if (this.trackIds) {
              options.ids = this.source.generateArray(ids);
            }
            if (this.stringParams) {
              options.types = this.source.generateArray(types);
              options.contexts = this.source.generateArray(contexts);
            }
            if (this.options.data) {
              options.data = 'data';
            }
            if (this.useBlockParams) {
              options.blockParams = 'blockParams';
            }
            return options;
          },
          setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
            var options = this.setupParams(helper, paramSize, params);
            options = this.objectLiteral(options);
            if (useRegister) {
              this.useRegister('options');
              params.push('options');
              return ['options=', options];
            } else if (params) {
              params.push(options);
              return '';
            } else {
              return options;
            }
          }
        };
        (function() {
          var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
          var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
          for (var i = 0,
              l = reservedWords.length; i < l; i++) {
            compilerWords[reservedWords[i]] = true;
          }
        })();
        JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
          return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
        };
        function strictLookup(requireTerminal, compiler, parts, type) {
          var stack = compiler.popStack(),
              i = 0,
              len = parts.length;
          if (requireTerminal) {
            len--;
          }
          for (; i < len; i++) {
            stack = compiler.nameLookup(stack, parts[i], type);
          }
          if (requireTerminal) {
            return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
          } else {
            return stack;
          }
        }
        exports['default'] = JavaScriptCompiler;
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        var _utils = __webpack_require__(5);
        var SourceNode = undefined;
        try {
          if (false) {
            var SourceMap = require('source-map');
            SourceNode = SourceMap.SourceNode;
          }
        } catch (err) {}
        if (!SourceNode) {
          SourceNode = function(line, column, srcFile, chunks) {
            this.src = '';
            if (chunks) {
              this.add(chunks);
            }
          };
          SourceNode.prototype = {
            add: function add(chunks) {
              if (_utils.isArray(chunks)) {
                chunks = chunks.join('');
              }
              this.src += chunks;
            },
            prepend: function prepend(chunks) {
              if (_utils.isArray(chunks)) {
                chunks = chunks.join('');
              }
              this.src = chunks + this.src;
            },
            toStringWithSourceMap: function toStringWithSourceMap() {
              return {code: this.toString()};
            },
            toString: function toString() {
              return this.src;
            }
          };
        }
        function castChunk(chunk, codeGen, loc) {
          if (_utils.isArray(chunk)) {
            var ret = [];
            for (var i = 0,
                len = chunk.length; i < len; i++) {
              ret.push(codeGen.wrap(chunk[i], loc));
            }
            return ret;
          } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
            return chunk + '';
          }
          return chunk;
        }
        function CodeGen(srcFile) {
          this.srcFile = srcFile;
          this.source = [];
        }
        CodeGen.prototype = {
          isEmpty: function isEmpty() {
            return !this.source.length;
          },
          prepend: function prepend(source, loc) {
            this.source.unshift(this.wrap(source, loc));
          },
          push: function push(source, loc) {
            this.source.push(this.wrap(source, loc));
          },
          merge: function merge() {
            var source = this.empty();
            this.each(function(line) {
              source.add(['  ', line, '\n']);
            });
            return source;
          },
          each: function each(iter) {
            for (var i = 0,
                len = this.source.length; i < len; i++) {
              iter(this.source[i]);
            }
          },
          empty: function empty() {
            var loc = this.currentLocation || {start: {}};
            return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
          },
          wrap: function wrap(chunk) {
            var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || {start: {}} : arguments[1];
            if (chunk instanceof SourceNode) {
              return chunk;
            }
            chunk = castChunk(chunk, this, loc);
            return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
          },
          functionCall: function functionCall(fn, type, params) {
            params = this.generateList(params);
            return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
          },
          quotedString: function quotedString(str) {
            return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029') + '"';
          },
          objectLiteral: function objectLiteral(obj) {
            var pairs = [];
            for (var key in obj) {
              if (obj.hasOwnProperty(key)) {
                var value = castChunk(obj[key], this);
                if (value !== 'undefined') {
                  pairs.push([this.quotedString(key), ':', value]);
                }
              }
            }
            var ret = this.generateList(pairs);
            ret.prepend('{');
            ret.add('}');
            return ret;
          },
          generateList: function generateList(entries) {
            var ret = this.empty();
            for (var i = 0,
                len = entries.length; i < len; i++) {
              if (i) {
                ret.add(',');
              }
              ret.add(castChunk(entries[i], this));
            }
            return ret;
          },
          generateArray: function generateArray(entries) {
            var ret = this.generateList(entries);
            ret.prepend('[');
            ret.add(']');
            return ret;
          }
        };
        exports['default'] = CodeGen;
        module.exports = exports['default'];
      }]);
    });
    ;
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:components/handlebars.js@4.0.5.js", ["github:components/handlebars.js@4.0.5/handlebars.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:components/handlebars.js@4.0.5/handlebars.js');
  global.define = __define;
  return module.exports;
});

System.register('components/map/UIs/default/layout/templates.js', ['github:components/handlebars.js@4.0.5.js'], function (_export) {
  'use strict';

  var templates;
  return {
    setters: [function (_githubComponentsHandlebarsJs405Js) {}],
    execute: function () {
      templates = {
        multiSelection: Handlebars.compile('\n    <span style=\'font-size:200%;display:block;margin-bottom:20px;\'>\n      {{title}}\n    </span>\n    <ul>\n      {{#each objects}}\n      <li>\n        {{this.data.typeData.name}}\n      </li>\n      {{/each}}\n    </ul>'),
        singleSelection: Handlebars.compile('\n    <span style=\'font-size:200%;display:block;margin-bottom:20px;\'>\n      {{title}}\n    </span>\n    <ul>\n      <li>\n        {{object.name}}\n      </li>\n    </ul>')
      };

      _export('templates', templates);
    }
  };
});
System.register('components/map/UIs/default/layout/index.js', ['components/map/UIs/default/layout/CSSRules.js', 'components/map/UIs/default/layout/templates.js'], function (_export) {
  'use strict';

  /*
   * This should bundle layout files
   */

  return {
    setters: [function (_componentsMapUIsDefaultLayoutCSSRulesJs) {
      var _exportObj = {};

      for (var _key in _componentsMapUIsDefaultLayoutCSSRulesJs) {
        if (_key !== 'default') _exportObj[_key] = _componentsMapUIsDefaultLayoutCSSRulesJs[_key];
      }

      _export(_exportObj);
    }, function (_componentsMapUIsDefaultLayoutTemplatesJs) {
      var _exportObj2 = {};

      for (var _key2 in _componentsMapUIsDefaultLayoutTemplatesJs) {
        if (_key2 !== 'default') _exportObj2[_key2] = _componentsMapUIsDefaultLayoutTemplatesJs[_key2];
      }

      _export(_exportObj2);
    }],
    execute: function () {}
  };
});
System.register('components/map/UIs/default/utils/arrows.js', [], function (_export) {
  'use strict';

  var drawShapes;
  return {
    setters: [],
    execute: function () {
      drawShapes = (function () {
        return {
          normal: drawArrow,
          arced: drawArcedArrow
        };

        /* =============== Functions for drawing arrows ================ */

        // From the website: http://www.dbp-consulting.com/tutorials/canvas/CanvasArrow.html
        /*
          @param {int} x1,y1 - the line of the shaft starts here
          @param {int} x2,y2 - the line of the shaft ends here
          @param {int or function} style - type of head to draw
              0 - filled head with back a curve drawn with arcTo
                  n.b. some browsers have an arcTo bug that make this look bizarre
              1 - filled head with back a straight line
              2 - unfilled but stroked head
              3 - filled head with back a curve drawn with quadraticCurveTo
              4 - filled head with back a curve drawn with bezierCurveTo
                  function(ctx,x0,y0,x1,y1,x2,y2,style) - a function provided by the user to draw the head. Point (x1,y1) is the same as the end of the line, and (x0,y0) and (x2,y2) are the two back corners. The style argument is the this for the function. An example that just draws little circles at each corner of the arrow head is shown later in this document.
              default 3 (filled head with quadratic back)
          @param {int} which - which end(s) get the arrow
              0 - neither
              1 - x2,y2 end
              2 - x1,y1 end
              3 - (that's 1+2) both ends
              default 1 (destination end gets the arrow)
          @param {float} angle - the angle θ from shaft to one side of arrow head - default π/8 radians (22 1/2°, half of a 45°)
          @param {int} length - the distance d in pixels from arrow point back along the shaft to the back of the arrow head - default 10px
            Passing in a custom head drawing routine, ie:
          var headDrawer=function(ctx,x0,y0,x1,y1,x2,y2,style)
          {
              var radius=3;
              var twoPI=2*Math.PI;
              ctx.save();
              ctx.beginPath();
              ctx.arc(x0,y0,radius,0,twoPI,false);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(x1,y1,radius,0,twoPI,false);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(x2,y2,radius,0,twoPI,false);
              ctx.stroke();
              ctx.restore();
          }
            Modified to support easelJS (no context editing, instead graphics-object)
            */
        function drawArrow(shape, x1, y1, x2, y2, style, which, angle, d) {
          var graphics = shape.graphics,
              color = "#000",
              angle1,
              topx,
              topy,
              angle2,
              botx,
              boty;

          /* Ceason pointed to a problem when x1 or y1 were a string, and
              concatenation would happen instead of addition */
          if (typeof x1 === 'string') x1 = parseInt(x1, 10);
          if (typeof y1 == 'string') y1 = parseInt(y1, 10);
          if (typeof x2 == 'string') x2 = parseInt(x2, 10);
          if (typeof y2 == 'string') y2 = parseInt(y2, 10);
          style = typeof style != 'undefined' ? style : 3;
          which = typeof which != 'undefined' ? which : 1; // end point gets arrow
          angle = typeof angle != 'undefined' ? angle : Math.PI / 8;
          d = typeof d != 'undefined' ? d : 10;
          // default to using drawHead to draw the head, but if the style
          // argument is a function, use it instead
          var toDrawHead = typeof style != 'function' ? drawHead : style;

          /* For ends with arrow we actually want to stop before we get to the arrow
              so that wide lines won't put a flat end on the arrow. */
          var dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          var ratio = (dist - d / 3) / dist;
          var tox, toy, fromx, fromy;
          if (which & 1) {
            tox = Math.round(x1 + (x2 - x1) * ratio);
            toy = Math.round(y1 + (y2 - y1) * ratio);
          } else {
            tox = x2;
            toy = y2;
          }
          if (which & 2) {
            fromx = x1 + (x2 - x1) * (1 - ratio);
            fromy = y1 + (y2 - y1) * (1 - ratio);
          } else {
            fromx = x1;
            fromy = y1;
          }

          /* Original: Draw the shaft of the arrow
             ctx.beginPath();
             ctx.moveTo(fromx,fromy);
             ctx.lineTo(tox,toy);
             ctx.stroke(); */

          // Modified easelJS-version:
          graphics.beginStroke(color).moveTo(fromx, fromy).lineTo(tox, toy);

          // calculate the angle of the line
          var lineangle = Math.atan2(y2 - y1, x2 - x1);
          // h is the line length of a side of the arrow head
          var h = Math.abs(d / Math.cos(angle));

          if (which & 1) {
            // handle far end arrow head
            angle1 = lineangle + Math.PI + angle;
            topx = x2 + Math.cos(angle1) * h;
            topy = y2 + Math.sin(angle1) * h;
            angle2 = lineangle + Math.PI - angle;
            botx = x2 + Math.cos(angle2) * h;
            boty = y2 + Math.sin(angle2) * h;
            toDrawHead(graphics, topx, topy, x2, y2, botx, boty, style);
          }
          if (which & 2) {
            // handle near end arrow head
            angle1 = lineangle + angle;
            topx = x1 + Math.cos(angle1) * h;
            topy = y1 + Math.sin(angle1) * h;
            angle2 = lineangle - angle;
            botx = x1 + Math.cos(angle2) * h;
            boty = y1 + Math.sin(angle2) * h;
            toDrawHead(graphics, topx, topy, x1, y1, botx, boty, style);
          }

          return true;

          function drawHead(graphics, x0, y0, x1, y1, x2, y2, style) {
            var backdist;
            x0 = +x0, y0 = +y0, x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2;
            // all cases do this.
            graphics.beginStroke("#F00").moveTo(x0, y0).lineTo(x1, y1).lineTo(x2, y2);
            switch (style) {
              case 0:
                // curved filled, add the bottom as an arcTo curve and fill
                backdist = Math.sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0));
                graphics.arcTo(x1, y1, x0, y0, 0.55 * backdist);
                graphics.fill();
                break;
              case 1:
                // straight filled, add the bottom as a line and fill.
                graphics.beginStroke("#F00").moveTo(x0, y0).lineTo(x1, y1).lineTo(x2, y2).lineTo(x0, y0).fill();
                break;
              case 2:
                // unfilled head, just stroke.
                break;
              case 3:
                //filled head, add the bottom as a quadraticCurveTo curve and fill
                var cpx = (x0 + x1 + x2) / 3;
                var cpy = (y0 + y1 + y2) / 3;
                graphics.beginFill().quadraticCurveTo(cpx, cpy, x0, y0);
                break;
              case 4:
                //filled head, add the bottom as a bezierCurveTo curve and fill
                var cp1x, cp1y, cp2x, cp2y;
                var shiftamt = 5;
                if (x2 === x0) {
                  // Avoid a divide by zero if x2==x0
                  backdist = y2 - y0;
                  cp1x = (x1 + x0) / 2;
                  cp2x = (x1 + x0) / 2;
                  cp1y = y1 + backdist / shiftamt;
                  cp2y = y1 - backdist / shiftamt;
                } else {
                  backdist = Math.sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0));
                  var xback = (x0 + x2) / 2;
                  var yback = (y0 + y2) / 2;
                  var xmid = (xback + x1) / 2;
                  var ymid = (yback + y1) / 2;

                  var m = (y2 - y0) / (x2 - x0);
                  var dx = backdist / (2 * Math.sqrt(m * m + 1)) / shiftamt;
                  var dy = m * dx;
                  cp1x = xmid - dx;
                  cp1y = ymid - dy;
                  cp2x = xmid + dx;
                  cp2y = ymid + dy;
                }

                graphics.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x0, y0);
                graphics.fill();
                break;
            }
          }
        }
        function drawArcedArrow(graphics, x, y, r, startangle, endangle, anticlockwise, style, which, angle, d) {
          var sx, sy, lineangle, destx, desty;

          style = typeof style != 'undefined' ? style : 3;
          which = typeof which != 'undefined' ? which : 1; // end point gets arrow
          angle = typeof angle != 'undefined' ? angle : Math.PI / 8;
          d = typeof d != 'undefined' ? d : 10;
          // Old: ctx.save();
          graphics.beginPath();
          graphics.arc(x, y, r, startangle, endangle, anticlockwise);
          graphics.stroke();

          graphics.strokeStyle = 'rgba(0,0,0,0)'; // don't show the shaft
          if (which & 1) {
            // draw the destination end
            sx = Math.cos(startangle) * r + x;
            sy = Math.sin(startangle) * r + y;
            lineangle = Math.atan2(x - sx, sy - y);

            if (anticlockwise) {
              destx = sx + 10 * Math.cos(lineangle);
              desty = sy + 10 * Math.sin(lineangle);
            } else {
              destx = sx - 10 * Math.cos(lineangle);
              desty = sy - 10 * Math.sin(lineangle);
            }
            drawArrow(graphics, sx, sy, destx, desty, style, 2, angle, d);
          }
          if (which & 2) {
            // draw the origination end
            sx = Math.cos(endangle) * r + x;
            sy = Math.sin(endangle) * r + y;
            lineangle = Math.atan2(x - sx, sy - y);
            if (anticlockwise) {
              destx = sx - 10 * Math.cos(lineangle);
              desty = sy - 10 * Math.sin(lineangle);
            } else {
              destx = sx + 10 * Math.cos(lineangle);
              desty = sy + 10 * Math.sin(lineangle);
            }
            drawArrow(graphics, sx, sy, destx, desty, style, 2, angle, d);
          }
        }
        /* =============================== */
      })();

      _export('drawShapes', drawShapes);
    }
  };
});
System.register('components/preloading/preloading.js', ['npm:babel-runtime@5.8.24/helpers/create-class.js', 'npm:babel-runtime@5.8.24/helpers/class-call-check.js', 'npm:q@1.4.1.js'], function (_export) {
  var _createClass, _classCallCheck, Q, Preload;

  return {
    setters: [function (_npmBabelRuntime5824HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5824HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs['default'];
    }, function (_npmQ141Js) {
      Q = _npmQ141Js;
    }],
    execute: function () {
      /* global PIXI, Q */

      /*-----------------------
      ---------- API ----------
      -----------------------*/
      "use strict";

      /*-----------------------
      --------- IMPORT --------
      -----------------------*/

      Preload = (function () {
        /**
         * Preloads assets before initializing map.
         *
         * @class Preload
         * @constructor
         * @todo should you use PIXI here or just https://github.com/englercj/resource-loader straight?
         */

        function Preload(baseUrl) {
          var options = arguments.length <= 1 || arguments[1] === undefined ? { concurrency: 15, crossOrigin: false } : arguments[1];

          _classCallCheck(this, Preload);

          var concurrency = options.concurrency;

          this.preloaderClass = new PIXI.loaders.Loader(baseUrl, concurrency);
        }

        /**
         * @method resolveOnComplete
         * @return {Promise} Return promise object, that will be resolved when the preloading is finished
         **/

        _createClass(Preload, [{
          key: 'resolveOnComplete',
          value: function resolveOnComplete() {
            var promise = Q.defer();

            this.preloaderClass.load();

            this.preloaderClass.once('complete', function (loader, resources) {
              promise.resolve(loader, resources);
            });

            return promise.promise;
          }

          /**
           * @method addResource
           **/
        }, {
          key: 'addResource',
          value: function addResource(resource) {
            this.preloaderClass.add(resource);
          }

          /**
           * Preload assets
           *
           * @method loadManifest
           **/
        }, {
          key: 'loadManifest',
          value: function loadManifest() {
            return this;
          }

          /**
           * Error handler if something goes wrong when preloading
           *
           * @method setErrorHandler
           **/
        }, {
          key: 'setErrorHandler',
          value: function setErrorHandler(errorCB) {
            this.preloaderClass.on("error", errorCB);

            return this;
          }

          /**
           * Progress handler for loading. You should look easeljs docs for more information
           *
           * @method setProgressHandler
           **/
        }, {
          key: 'setProgressHandler',
          value: function setProgressHandler(progressCB) {
            this.preloaderClass.on("error", progressCB);

            return this;
          }

          /**
           * Activate sound preloading also
           *
           * @method activateSound
           **/
        }, {
          key: 'activateSound',
          value: function activateSound() {
            this.preloaderClass.installPlugin();
          }
        }]);

        return Preload;
      })();

      _export('Preload', Preload);
    }
  };
});
System.register('components/utilities/polyfills.js', ['npm:babel-runtime@5.8.24/core-js/object/assign.js'], function (_export) {
  var _Object$assign, polyfills;

  /*-----------------------
  -------- PUBLIC ---------
  -----------------------*/
  /**
   * Add polyfills for the map, as necessary. Easy to drop out.
   *
   * @class generalUtils.polyfills
   * @return {Object} arrayFind, objectAssign
   */
  function setupPolyfills() {
    return {
      arrayFind: arrayFind,
      objectAssign: objectAssign
    };

    /**
     * @static
     * @method arrayFind
     */
    function arrayFind() {
      if (!Array.prototype.find) {
        Array.prototype.find = function (predicate) {
          if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
          }
          if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
          }
          var list = Object(this);
          var length = list.length >>> 0;
          var thisArg = arguments[1];
          var value;

          for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
              return value;
            }
          }
          return undefined;
        };
      }
    }

    /**
     * Object.assign IE11 polyfill. Credits to Mozillas folk:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
     *
     * @method objectAssign
     * @static
     */
    function objectAssign() {
      if (typeof _Object$assign != 'function') {
        (function () {
          Object.assign = function (target) {
            if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        })();
      }
    }
  }
  /* jshint ignore:end */
  return {
    setters: [function (_npmBabelRuntime5824CoreJsObjectAssignJs) {
      _Object$assign = _npmBabelRuntime5824CoreJsObjectAssignJs['default'];
    }],
    execute: function () {
      /* jshint ignore:start */
      'use strict';

      /*-----------------------
      ---------- API ----------
      -----------------------*/
      polyfills = setupPolyfills();

      _export('polyfills', polyfills);
    }
  };
});
System.register('factories/horizontalHexaFactory.js', ['bundles/fullModuleBundle.js'], function (_export) {
  /* global PIXI */

  /*---------------------
  --------- API ---------
  ----------------------*/
  'use strict';

  /*---------------------
  ------- IMPORT --------
  ----------------------*/
  var UI_default, hexagonPlugin, Map, UI, utils;

  /*---------------------
  ------- PUBLIC --------
  ----------------------*/
  /**
   * This constructs a whole horizontally aligned hexagonal map. Some polyfills are needed and added for IE11 ( http://babeljs.io/docs/usage/polyfill/ ). These are found in utils
   *
   * @class factories.horizontalHexaFactory
   * @requires PIXI in global space
   * @param {HTMLElement} canvasContainerElement  HTML Element. Container which will hold the generated canvas element
   * @param {Object} datas                        Object with mapDatas to construct the map structure
   * @param {Object} datas.map                    Holds all the stage, layer and object data needed to construct a full map
   * @param {Object} datas.game                   More general game data (like turn number, map size etc.)
   * @param {Object} datas.type                   Type data such as different unit types and their graphics (tank, soldier etc.)
   * @param {Object} options                      Optional options
   * @param {Object} options.isHiddenByDefault    When we use mapMovement plugin, it is best to keep all the obejcts hidden at the beginnig.
   * @param {Function} options.trackFPSCB         Callback to track FPS
   **/
  function createHorizontalHexagonMap(canvasContainerElement, datas) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? { trackFPSCB: false, isHiddenByDefault: true, cache: false } : arguments[2];

    console.log("============== Horizontal hexagonal Map factory started =============");
    var pixelRatio = utils.environmentDetection.getPixelRatio();
    var DATA_MAP = typeof datas.map === "string" ? JSON.parse(datas.map) : datas.map;
    var DATA_TYPE = typeof datas.type === "string" ? JSON.parse(datas.type) : datas.type;
    var DATA_GAME = typeof datas.game === "string" ? JSON.parse(datas.game) : datas.game;
    var WINDOW_SIZE = utils.resize.getWindowSize();
    var MAP_SIZE = DATA_GAME.mapSize;
    var mapOptions = {
      refreshEventListeners: true
    };
    /*---------------------
    ------ VARIABLES ------
    ----------------------*/
    var functionsInObj = {
      ObjectTerrain: hexagonPlugin.ObjectHexaTerrain,
      ObjectUnit: hexagonPlugin.ObjectHexaUnit
    };
    var mapProperties = {
      bounds: {
        x: 0,
        y: 0,
        width: WINDOW_SIZE.x,
        height: WINDOW_SIZE.y
      },
      rendererOptions: {
        resolution: pixelRatio, // We might need this later on, when doing mobile optimizations, for different pizel density devices
        autoResize: true,
        transparent: true,
        antialias: false // TEST. Only should work in chrome atm.?
      },
      subcontainers: {
        width: 500,
        height: 500,
        maxDetectionOffset: 100,
        isHiddenByDefault: options.isHiddenByDefault
      },
      trackFPSCB: options.trackFPSCB,
      cache: options.cache
    };
    var map, dialog_selection, defaultUI;

    map = new Map(canvasContainerElement, mapProperties, mapOptions);
    dialog_selection = document.getElementById("selectionDialog");
    defaultUI = new UI_default(dialog_selection, map);

    /* Initialize UI as singleton */
    UI(defaultUI, map);

    DATA_MAP.layers.forEach(function (layerData) {
      if (typeof layerData !== "object") {
        console.log("Problem in horizontalHexaFactory, with layerData:", layerData);
        throw new Error("Problem in horizontalHexaFactory, with layerData:", layerData);
      }

      var layerGroup = layerData.group;
      var objManager = map.objectManager;
      var renderer = map.getRenderer();
      var layerOptions = {
        name: layerData.name,
        coord: layerData.coord,
        drawOutsideViewport: {
          x: renderer.width,
          y: renderer.height
        },
        selectable: layerData.name === "unitLayer" ? true : false
      };
      var thisLayer;

      try {
        thisLayer = map.addLayer(layerOptions);

        layerData.objectGroups.forEach(function (objectGroup) {
          var spritesheetType = objectGroup.typeImageData;

          if (!spritesheetType) {
            console.log("Error with spritesheetType-data");
            return;
          }

          objectGroup.objects.forEach(function (object) {
            var objTypeData, objData, objectOptions, currentFrame, newObject;

            try {
              objTypeData = DATA_TYPE.objectData[spritesheetType][object.objType];
              if (!objTypeData) {
                console.debug("Bad mapData for type:", spritesheetType, object.objType, object.name);
                throw new Error("Bad mapData for type:", spritesheetType, object.objType, object.name);
              }

              objData = {
                typeData: objTypeData,
                activeData: object.data
              };
              currentFrame = PIXI.Texture.fromFrame(objTypeData.image);
              objectOptions = {
                currentFrame: currentFrame,
                radius: DATA_GAME.hexagonRadius
              };

              newObject = new functionsInObj[objectGroup.type](object.coord, objData, objectOptions);

              thisLayer.addChild(newObject);
            } catch (e) {
              console.log(e);
            }
          });
        });
      } catch (e) {
        console.log("Problem:", layerData.type, e.stack);
      }
    });

    map.moveMap(DATA_MAP.startPoint);

    return map;
  }
  return {
    setters: [function (_bundlesFullModuleBundleJs) {
      UI_default = _bundlesFullModuleBundleJs.UI_default;
      hexagonPlugin = _bundlesFullModuleBundleJs.hexagonPlugin;
      Map = _bundlesFullModuleBundleJs.Map;
      UI = _bundlesFullModuleBundleJs.UI;
      utils = _bundlesFullModuleBundleJs.utils;
    }],
    execute: function () {
      _export('createHorizontalHexagonMap', createHorizontalHexagonMap);
    }
  };
});
System.register('factories/index.js', ['factories/horizontalHexaFactory.js'], function (_export) {
  'use strict';

  /* Bundle utils in utils-parent and export them */
  var createHorizontalHexagonMap, factories;
  return {
    setters: [function (_factoriesHorizontalHexaFactoryJs) {
      createHorizontalHexagonMap = _factoriesHorizontalHexaFactoryJs.createHorizontalHexagonMap;
    }],
    execute: function () {
      factories = {
        createHorizontalHexagonMap: createHorizontalHexagonMap
      };

      _export('factories', factories);
    }
  };
});
System.register('components/map/extensions/hexagons/utils/createHexagon.js', ['components/map/extensions/hexagons/utils/hexagonMath.js'], function (_export) {

  /*-----------------------
  ----------- API ---------
  -----------------------*/
  'use strict';

  /*-----------------------
  -------- IMPORTS --------
  -----------------------*/
  var getHexagonPoints;

  /*-----------------------
  --------- PUBLIC --------
  -----------------------*/
  /**
   * This manages some utility functionalities for creating hexagons
   *
   * @class hexagonPlugin.utils
   */
  /**
   * Credits belong to: https://github.com/alforno-productions/HexPixiJs/blob/master/lib/hexPixi.js
   * Creates a hex shaped polygon that is used for the hex's hit area.
   *
   * @private
   * @static
   * @method createHexagon
   * @param {Number} radius       Radius of the hexagon
   * @param {Object} options      Options, such as: isFlatTop (Boolean), is the heaxgon flat-topped
   * @return {PIXI.Polygon}       Hexagon shaped PIXI.Polygon object. That houses the hexagons corner points.
   */
  function createHexagon(radius) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? { isFlatTop: false } : arguments[1];

    var points = [];

    points = coordsToPixiPoints(radius);

    return new PIXI.Polygon(points);
  }
  /**
   * @private
   * @static
   * @method createVisibleHexagon
   * @param {Number} radius       Radius of the hexagon
   * @param {Object} options      Options, such as:
   *                              color: The fill color of the hexagon
   *                              isFlatTop (Boolean), is the heaxgon flat-topped
   * @return {PIXI.Graphics}      Graphics object that is shaped as hexagon, based on given radius and options.
   */
  function createVisibleHexagon(radius) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? { color: "#000000", isFlatTop: false } : arguments[1];

    var graphics = new PIXI.Graphics();
    var points = coordsToPixiPoints(radius);

    graphics.beginFill(options.color, 1);
    graphics.drawPolygon(points);
    graphics.endFill();

    return graphics;
  }

  /*-----------------------
  --------- PRIVATE -------
  -----------------------*/
  /**
   * Converts Array of x- and y-coordinates to new PIXI.Point coordinates
   *
   * @private
   * @static
   * @method coordsToPixiPoints
   * @param  {Number} radius        Hexagons radius
   * @return {Array}                Array of PIXI.Point coordinates
   */
  function coordsToPixiPoints(radius) {
    return getHexagonPoints(radius).map(function (point) {
      return new PIXI.Point(point.x, point.y);
    });
  }
  return {
    setters: [function (_componentsMapExtensionsHexagonsUtilsHexagonMathJs) {
      getHexagonPoints = _componentsMapExtensionsHexagonsUtilsHexagonMathJs.getHexagonPoints;
    }],
    execute: function () {
      _export('default', {
        createHexagon: createHexagon,
        createVisibleHexagon: createVisibleHexagon
      });

      _export('createHexagon', createHexagon);

      _export('createVisibleHexagon', createVisibleHexagon);
    }
  };
});
System.register("components/map/extensions/hexagons/utils/hexagonMath.js", [], function (_export) {
  'use strict';

  /*-----------------------
  ---------- API ----------
  -----------------------*/

  /**
   * Utility module, for making different calculations and tests when hexagon based grid map in use
   *
   * @class hexagonPlugin.utils
   */
  /*-----------------------
  --------- PUBLIC --------
  -----------------------*/
  /**
   * Calculates the hexagons:
   * innerDiameter
   * - Vertical / Flat hexagons height
   * - Horizontal / pointy hexagons width
   *
   * @method calcLongDiagonal
   * @static
   * @param {float} value - Usually the radius of the hexagon
   * @param {string} type - If you provide something else than radius, where the calculation is based from
   * @param {integer} precision - How many decimals to round
   */
  function calcShortDiagonal(value) {
    var type = arguments.length <= 1 || arguments[1] === undefined ? "radius" : arguments[1];
    var precision = arguments.length <= 2 || arguments[2] === undefined ? 3 : arguments[2];

    var answer;

    precision = Math.round(precision);

    if (type === "radius") {
      answer = value * Math.sqrt(3);
    }

    return Number(answer.toFixed(precision));
  }
  /** Calculates the hexagons:
   * outerDiameter
   * - Vertical / Flat hexagons width
   * - Horizontal / pointy hexagons height
   *
   * @method calcLongDiagonal
   * @static
   * @param {float} value					Usually the radius of the hexagon
   * @param {string} type					If you provide something else than radius, where the calculation is based from
   * @param {integer} precision 	How many decimals to round
   */
  function calcLongDiagonal(value) {
    var type = arguments.length <= 1 || arguments[1] === undefined ? "radius" : arguments[1];
    var precision = arguments.length <= 2 || arguments[2] === undefined ? 3 : arguments[2];

    var answer;

    if (type === "radius") {
      answer = value * 2;
    }

    return Number(answer.toFixed(precision));
  }
  /**
   * @method getHexagonPoints
   * @static
   * @param {Float} radius			radius of the hexagon
   * @param {object} options		extra options, like generating horizontal hexagon points and
   * how many decimals to round
  */
  function getHexagonPoints(radius) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? { isFlatTop: false, precision: 3 } : arguments[1];

    var OFFSET = options.isFlatTop ? 0 : 0.5;
    var CENTER = {
      x: radius,
      y: radius
    };
    var angle = 2 * Math.PI / 6 * OFFSET;
    var x = CENTER.x * Math.cos(angle);
    var y = CENTER.y * Math.sin(angle);
    var points = [];

    points.push({ x: x, y: y });

    for (var i = 1; i < 7; i++) {
      angle = 2 * Math.PI / 6 * (i + OFFSET);
      x = CENTER.x * Math.cos(angle);
      y = CENTER.y * Math.sin(angle);

      points.push({ x: x, y: y });
    }

    return points;
  }
  /**
   * Test do the given coordinates hit the hexagon, given by the points container / array
   *
   * @static
   * @method hexaHitTest
   * @param  {PIXI.Point[]} points             Array of PIXI.points
   * @param  {Object} hitCoords         The coordinates to test against
   * @param  {Integer} hitCoords.x      X coordinate
   * @param  {Integer} hitCoords.y      Y coordinate
   * @param  {Object} offsetCoords      offsetCoordinates that are added to the hitCoordinates. Separate because these are outside the given array.
   * @param  {Integer} offsetCoords.x   X coordinate
   * @param  {Integer} offsetCoords.y   Y coordinate
   * @return {Boolean}                  Is the coordinate inside the hexagon or not
   */

  function hexaHitTest(points) {
    var hitCoords = arguments.length <= 1 || arguments[1] === undefined ? { x: 0, y: 0 } : arguments[1];
    var offsetCoords = arguments.length <= 2 || arguments[2] === undefined ? { x: 0, y: 0 } : arguments[2];

    var realPolygonPoints;

    realPolygonPoints = points.map(function (point) {
      return {
        x: point.x + offsetCoords.x,
        y: point.y + offsetCoords.y
      };
    });

    return pointInPolygon(hitCoords, realPolygonPoints);
  }

  /*-----------------------
  --------- PRIVATE -------
  -----------------------*/
  /**
   * credits to: https://github.com/substack/point-in-polygon
   * Tests whether the given point / coordinate is inside the given points. Assuming the points form a polygon
   *
   * @static
   * @private
   * @method pointInPolygon
   * @param  {Object} point             The coordinates to test against
   * @param  {Integer} hitCoords.x      X coordinate
   * @param  {Integer} hitCoords.y      Y coordinate
   * @param  {Integer[]} vs             The points of the polygon to test [0] === x-point, [1] === y-point
   * @return {Boolean}                  Is the coordinate inside the hexagon or not
   */
  function pointInPolygon(point, vs) {
    var x = point.x;
    var y = point.y;
    var inside = false;
    var xi, xj, yi, yj, intersect;

    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
      xi = vs[i].x;
      yi = vs[i].y;
      xj = vs[j].x;
      yj = vs[j].y;
      intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;

      if (intersect) {
        inside = !inside;
      }
    }

    return inside;
  }
  return {
    setters: [],
    execute: function () {
      _export("default", {
        calcShortDiagonal: calcShortDiagonal,
        calcLongDiagonal: calcLongDiagonal,
        getHexagonPoints: getHexagonPoints,
        hexaHitTest: hexaHitTest
      });

      _export("calcShortDiagonal", calcShortDiagonal);

      _export("calcLongDiagonal", calcLongDiagonal);

      _export("getHexagonPoints", getHexagonPoints);

      _export("hexaHitTest", hexaHitTest);
    }
  };
});
System.register('components/map/extensions/hexagons/Objects.js', ['npm:babel-runtime@5.8.24/helpers/get.js', 'npm:babel-runtime@5.8.24/helpers/inherits.js', 'npm:babel-runtime@5.8.24/helpers/class-call-check.js', 'bundles/coreBundle.js', 'components/map/extensions/hexagons/utils/createHexagon.js', 'components/map/extensions/hexagons/utils/hexagonMath.js'], function (_export) {
  var _get, _inherits, _classCallCheck, ObjectSpriteTerrain, ObjectSpriteUnit, createHexagon, hexagonMath, shape, ObjectHexaTerrain, ObjectHexaUnit;

  /*-----------------------
  --------- PRIVATE -------
  -----------------------*/
  /**
   * @private
   * @static
   * @method calculateHexa
   * @param {Number} radius       Hexagon radius
   */
  function calculateHexa(radius) {
    if (!radius) {
      throw new Error("Need radius!");
    }

    var HEIGHT = Math.round(hexagonMath.calcLongDiagonal(radius));
    var WIDTH = Math.round(hexagonMath.calcShortDiagonal(radius));
    var SIDE = Math.round(radius.toFixed(3));

    this.anchor.set(0.5, 0.5);
    this.areaHeight = this.HEIGHT = HEIGHT;
    this.areaWidth = this.WIDTH = WIDTH;
    this.SIDE = SIDE;
    this.ROW_HEIGHT = Math.round(HEIGHT * 0.75);

    /* Draw hexagon to test the hits with hitArea */
    this.hitArea = setAndGetShape(radius);
    this.hitTest = function (coords, options) {
      this.updateTransform();
      //map.getMovableLayer().updateTransform();
      //coords = map.getMovableLayer().toLocal(coords);
      var isHit = options.hitDetector.processInteractive(new PIXI.Point(coords.x, coords.y), this, function () /*parent, hits*/{
        console.log("Shouldn't get here, the object should be non-interactive");
      }, true, true);

      return isHit;
    };
  }
  /**
   * @private
   * @static
   * @method setAndGetShape
   * @param {Number} radius       Hexagon radius
   */
  function setAndGetShape(radius) {
    if (!shape) {
      shape = createHexagon(radius);
    }

    return shape;
  }
  return {
    setters: [function (_npmBabelRuntime5824HelpersGetJs) {
      _get = _npmBabelRuntime5824HelpersGetJs['default'];
    }, function (_npmBabelRuntime5824HelpersInheritsJs) {
      _inherits = _npmBabelRuntime5824HelpersInheritsJs['default'];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs['default'];
    }, function (_bundlesCoreBundleJs) {
      ObjectSpriteTerrain = _bundlesCoreBundleJs.ObjectSpriteTerrain;
      ObjectSpriteUnit = _bundlesCoreBundleJs.ObjectSpriteUnit;
    }, function (_componentsMapExtensionsHexagonsUtilsCreateHexagonJs) {
      createHexagon = _componentsMapExtensionsHexagonsUtilsCreateHexagonJs.createHexagon;
    }, function (_componentsMapExtensionsHexagonsUtilsHexagonMathJs) {
      hexagonMath = _componentsMapExtensionsHexagonsUtilsHexagonMathJs['default'];
    }],
    execute: function () {

      /*-----------------------
      -------- VARIABLES ------
      -----------------------*/

      /*-----------------------
      --------- IMPORT --------
      -----------------------*/
      'use strict';

      /*-----------------------
      ---------- API ----------
      -----------------------*/

      _export('default', {
        ObjectHexaTerrain: ObjectHexaTerrain,
        ObjectHexaUnit: ObjectHexaUnit
      });

      ObjectHexaTerrain = (function (_ObjectSpriteTerrain) {
        _inherits(ObjectHexaTerrain, _ObjectSpriteTerrain);

        /**
         * Terrain tile like desert or mountain, non-movable and cacheable. Normally, but not necessarily, these are inherited, depending on the map type. For example you might want to add some click area for these
         *
         * @class hexagonPlugin.ObjectHexaTerrain
         * @constructor
         * @param  {Object} coords
         * @param  {Integer} coords.x         X coordinate
         * @param  {Integer} coords.y         Y coordinate
         * @param {object} data               This units custom data
         * @param {Object} options            options.radius REQUIRED.
         * @param {Number} options.radius     REQUIRED. This is the radius of the game maps hexagon.
         */

        function ObjectHexaTerrain(coords, data, options) {
          _classCallCheck(this, ObjectHexaTerrain);

          var radius = options.radius;

          _get(Object.getPrototypeOf(ObjectHexaTerrain.prototype), 'constructor', this).call(this, coords, data, options);

          this.name = "DefaultTerrainObject_hexa";
          calculateHexa.call(this, radius);
        }

        return ObjectHexaTerrain;
      })(ObjectSpriteTerrain);

      _export('ObjectHexaTerrain', ObjectHexaTerrain);

      ObjectHexaUnit = (function (_ObjectSpriteUnit) {
        _inherits(ObjectHexaUnit, _ObjectSpriteUnit);

        /**
         * Map unit like infantry or worker, usually something with actions or movable. Usually these are extended, depending on the map type. For example you might want to add some click area for these (e.g. hexagon)
         *
         * @class hexagonPlugin.ObjectHexaUnit
         * @constructor
         * @param {Object} coords            This units coordinates, relative to it's parent container
         * @param {Integer} coords.x         X coordinate
         * @param {Integer} coords.y         Y coordinate
         * @param {object} data               This units custom data
         * @param {Object} options            options.radius REQUIRED
         * @param {Object} options.radius     REQUIRED. This is the radius of the game maps hexagon
         */

        function ObjectHexaUnit(coords, data, options) {
          _classCallCheck(this, ObjectHexaUnit);

          var radius = options.radius;

          _get(Object.getPrototypeOf(ObjectHexaUnit.prototype), 'constructor', this).call(this, coords, data, options);

          this.name = "DefaultUnitObjects_hexa";

          calculateHexa.call(this, radius);
        }

        return ObjectHexaUnit;
      })(ObjectSpriteUnit);

      _export('ObjectHexaUnit', ObjectHexaUnit);
    }
  };
});
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function(f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define("assets/lib/pixi/pixi.js", [], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.PIXI = f();
  }
})(function() {
  var define,
      module,
      exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }
        var l = n[o] = {exports: {}};
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  })({
    1: [function(require, module, exports) {
      (function(global) {
        require('./polyfill');
        var core = module.exports = require('./core');
        core.extras = require('./extras');
        core.filters = require('./filters');
        core.interaction = require('./interaction');
        core.loaders = require('./loaders');
        core.mesh = require('./mesh');
        core.loader = new core.loaders.Loader();
        Object.assign(core, require('./deprecation'));
        global.PIXI = core;
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./core": 29,
      "./deprecation": 78,
      "./extras": 85,
      "./filters": 102,
      "./interaction": 117,
      "./loaders": 120,
      "./mesh": 126,
      "./polyfill": 130
    }],
    2: [function(require, module, exports) {
      (function(process) {
        (function() {
          var async = {};
          var root,
              previous_async;
          root = this;
          if (root != null) {
            previous_async = root.async;
          }
          async.noConflict = function() {
            root.async = previous_async;
            return async;
          };
          function only_once(fn) {
            var called = false;
            return function() {
              if (called)
                throw new Error("Callback was already called.");
              called = true;
              fn.apply(root, arguments);
            };
          }
          var _toString = Object.prototype.toString;
          var _isArray = Array.isArray || function(obj) {
            return _toString.call(obj) === '[object Array]';
          };
          var _each = function(arr, iterator) {
            if (arr.forEach) {
              return arr.forEach(iterator);
            }
            for (var i = 0; i < arr.length; i += 1) {
              iterator(arr[i], i, arr);
            }
          };
          var _map = function(arr, iterator) {
            if (arr.map) {
              return arr.map(iterator);
            }
            var results = [];
            _each(arr, function(x, i, a) {
              results.push(iterator(x, i, a));
            });
            return results;
          };
          var _reduce = function(arr, iterator, memo) {
            if (arr.reduce) {
              return arr.reduce(iterator, memo);
            }
            _each(arr, function(x, i, a) {
              memo = iterator(memo, x, i, a);
            });
            return memo;
          };
          var _keys = function(obj) {
            if (Object.keys) {
              return Object.keys(obj);
            }
            var keys = [];
            for (var k in obj) {
              if (obj.hasOwnProperty(k)) {
                keys.push(k);
              }
            }
            return keys;
          };
          if (typeof process === 'undefined' || !(process.nextTick)) {
            if (typeof setImmediate === 'function') {
              async.nextTick = function(fn) {
                setImmediate(fn);
              };
              async.setImmediate = async.nextTick;
            } else {
              async.nextTick = function(fn) {
                setTimeout(fn, 0);
              };
              async.setImmediate = async.nextTick;
            }
          } else {
            async.nextTick = process.nextTick;
            if (typeof setImmediate !== 'undefined') {
              async.setImmediate = function(fn) {
                setImmediate(fn);
              };
            } else {
              async.setImmediate = async.nextTick;
            }
          }
          async.each = function(arr, iterator, callback) {
            callback = callback || function() {};
            if (!arr.length) {
              return callback();
            }
            var completed = 0;
            _each(arr, function(x) {
              iterator(x, only_once(done));
            });
            function done(err) {
              if (err) {
                callback(err);
                callback = function() {};
              } else {
                completed += 1;
                if (completed >= arr.length) {
                  callback();
                }
              }
            }
          };
          async.forEach = async.each;
          async.eachSeries = function(arr, iterator, callback) {
            callback = callback || function() {};
            if (!arr.length) {
              return callback();
            }
            var completed = 0;
            var iterate = function() {
              iterator(arr[completed], function(err) {
                if (err) {
                  callback(err);
                  callback = function() {};
                } else {
                  completed += 1;
                  if (completed >= arr.length) {
                    callback();
                  } else {
                    iterate();
                  }
                }
              });
            };
            iterate();
          };
          async.forEachSeries = async.eachSeries;
          async.eachLimit = function(arr, limit, iterator, callback) {
            var fn = _eachLimit(limit);
            fn.apply(null, [arr, iterator, callback]);
          };
          async.forEachLimit = async.eachLimit;
          var _eachLimit = function(limit) {
            return function(arr, iterator, callback) {
              callback = callback || function() {};
              if (!arr.length || limit <= 0) {
                return callback();
              }
              var completed = 0;
              var started = 0;
              var running = 0;
              (function replenish() {
                if (completed >= arr.length) {
                  return callback();
                }
                while (running < limit && started < arr.length) {
                  started += 1;
                  running += 1;
                  iterator(arr[started - 1], function(err) {
                    if (err) {
                      callback(err);
                      callback = function() {};
                    } else {
                      completed += 1;
                      running -= 1;
                      if (completed >= arr.length) {
                        callback();
                      } else {
                        replenish();
                      }
                    }
                  });
                }
              })();
            };
          };
          var doParallel = function(fn) {
            return function() {
              var args = Array.prototype.slice.call(arguments);
              return fn.apply(null, [async.each].concat(args));
            };
          };
          var doParallelLimit = function(limit, fn) {
            return function() {
              var args = Array.prototype.slice.call(arguments);
              return fn.apply(null, [_eachLimit(limit)].concat(args));
            };
          };
          var doSeries = function(fn) {
            return function() {
              var args = Array.prototype.slice.call(arguments);
              return fn.apply(null, [async.eachSeries].concat(args));
            };
          };
          var _asyncMap = function(eachfn, arr, iterator, callback) {
            arr = _map(arr, function(x, i) {
              return {
                index: i,
                value: x
              };
            });
            if (!callback) {
              eachfn(arr, function(x, callback) {
                iterator(x.value, function(err) {
                  callback(err);
                });
              });
            } else {
              var results = [];
              eachfn(arr, function(x, callback) {
                iterator(x.value, function(err, v) {
                  results[x.index] = v;
                  callback(err);
                });
              }, function(err) {
                callback(err, results);
              });
            }
          };
          async.map = doParallel(_asyncMap);
          async.mapSeries = doSeries(_asyncMap);
          async.mapLimit = function(arr, limit, iterator, callback) {
            return _mapLimit(limit)(arr, iterator, callback);
          };
          var _mapLimit = function(limit) {
            return doParallelLimit(limit, _asyncMap);
          };
          async.reduce = function(arr, memo, iterator, callback) {
            async.eachSeries(arr, function(x, callback) {
              iterator(memo, x, function(err, v) {
                memo = v;
                callback(err);
              });
            }, function(err) {
              callback(err, memo);
            });
          };
          async.inject = async.reduce;
          async.foldl = async.reduce;
          async.reduceRight = function(arr, memo, iterator, callback) {
            var reversed = _map(arr, function(x) {
              return x;
            }).reverse();
            async.reduce(reversed, memo, iterator, callback);
          };
          async.foldr = async.reduceRight;
          var _filter = function(eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function(x, i) {
              return {
                index: i,
                value: x
              };
            });
            eachfn(arr, function(x, callback) {
              iterator(x.value, function(v) {
                if (v) {
                  results.push(x);
                }
                callback();
              });
            }, function(err) {
              callback(_map(results.sort(function(a, b) {
                return a.index - b.index;
              }), function(x) {
                return x.value;
              }));
            });
          };
          async.filter = doParallel(_filter);
          async.filterSeries = doSeries(_filter);
          async.select = async.filter;
          async.selectSeries = async.filterSeries;
          var _reject = function(eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function(x, i) {
              return {
                index: i,
                value: x
              };
            });
            eachfn(arr, function(x, callback) {
              iterator(x.value, function(v) {
                if (!v) {
                  results.push(x);
                }
                callback();
              });
            }, function(err) {
              callback(_map(results.sort(function(a, b) {
                return a.index - b.index;
              }), function(x) {
                return x.value;
              }));
            });
          };
          async.reject = doParallel(_reject);
          async.rejectSeries = doSeries(_reject);
          var _detect = function(eachfn, arr, iterator, main_callback) {
            eachfn(arr, function(x, callback) {
              iterator(x, function(result) {
                if (result) {
                  main_callback(x);
                  main_callback = function() {};
                } else {
                  callback();
                }
              });
            }, function(err) {
              main_callback();
            });
          };
          async.detect = doParallel(_detect);
          async.detectSeries = doSeries(_detect);
          async.some = function(arr, iterator, main_callback) {
            async.each(arr, function(x, callback) {
              iterator(x, function(v) {
                if (v) {
                  main_callback(true);
                  main_callback = function() {};
                }
                callback();
              });
            }, function(err) {
              main_callback(false);
            });
          };
          async.any = async.some;
          async.every = function(arr, iterator, main_callback) {
            async.each(arr, function(x, callback) {
              iterator(x, function(v) {
                if (!v) {
                  main_callback(false);
                  main_callback = function() {};
                }
                callback();
              });
            }, function(err) {
              main_callback(true);
            });
          };
          async.all = async.every;
          async.sortBy = function(arr, iterator, callback) {
            async.map(arr, function(x, callback) {
              iterator(x, function(err, criteria) {
                if (err) {
                  callback(err);
                } else {
                  callback(null, {
                    value: x,
                    criteria: criteria
                  });
                }
              });
            }, function(err, results) {
              if (err) {
                return callback(err);
              } else {
                var fn = function(left, right) {
                  var a = left.criteria,
                      b = right.criteria;
                  return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function(x) {
                  return x.value;
                }));
              }
            });
          };
          async.auto = function(tasks, callback) {
            callback = callback || function() {};
            var keys = _keys(tasks);
            var remainingTasks = keys.length;
            if (!remainingTasks) {
              return callback();
            }
            var results = {};
            var listeners = [];
            var addListener = function(fn) {
              listeners.unshift(fn);
            };
            var removeListener = function(fn) {
              for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                  listeners.splice(i, 1);
                  return;
                }
              }
            };
            var taskComplete = function() {
              remainingTasks--;
              _each(listeners.slice(0), function(fn) {
                fn();
              });
            };
            addListener(function() {
              if (!remainingTasks) {
                var theCallback = callback;
                callback = function() {};
                theCallback(null, results);
              }
            });
            _each(keys, function(k) {
              var task = _isArray(tasks[k]) ? tasks[k] : [tasks[k]];
              var taskCallback = function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                if (err) {
                  var safeResults = {};
                  _each(_keys(results), function(rkey) {
                    safeResults[rkey] = results[rkey];
                  });
                  safeResults[k] = args;
                  callback(err, safeResults);
                  callback = function() {};
                } else {
                  results[k] = args;
                  async.setImmediate(taskComplete);
                }
              };
              var requires = task.slice(0, Math.abs(task.length - 1)) || [];
              var ready = function() {
                return _reduce(requires, function(a, x) {
                  return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
              };
              if (ready()) {
                task[task.length - 1](taskCallback, results);
              } else {
                var listener = function() {
                  if (ready()) {
                    removeListener(listener);
                    task[task.length - 1](taskCallback, results);
                  }
                };
                addListener(listener);
              }
            });
          };
          async.retry = function(times, task, callback) {
            var DEFAULT_TIMES = 5;
            var attempts = [];
            if (typeof times === 'function') {
              callback = task;
              task = times;
              times = DEFAULT_TIMES;
            }
            times = parseInt(times, 10) || DEFAULT_TIMES;
            var wrappedTask = function(wrappedCallback, wrappedResults) {
              var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                  task(function(err, result) {
                    seriesCallback(!err || finalAttempt, {
                      err: err,
                      result: result
                    });
                  }, wrappedResults);
                };
              };
              while (times) {
                attempts.push(retryAttempt(task, !(times -= 1)));
              }
              async.series(attempts, function(done, data) {
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
              });
            };
            return callback ? wrappedTask() : wrappedTask;
          };
          async.waterfall = function(tasks, callback) {
            callback = callback || function() {};
            if (!_isArray(tasks)) {
              var err = new Error('First argument to waterfall must be an array of functions');
              return callback(err);
            }
            if (!tasks.length) {
              return callback();
            }
            var wrapIterator = function(iterator) {
              return function(err) {
                if (err) {
                  callback.apply(null, arguments);
                  callback = function() {};
                } else {
                  var args = Array.prototype.slice.call(arguments, 1);
                  var next = iterator.next();
                  if (next) {
                    args.push(wrapIterator(next));
                  } else {
                    args.push(callback);
                  }
                  async.setImmediate(function() {
                    iterator.apply(null, args);
                  });
                }
              };
            };
            wrapIterator(async.iterator(tasks))();
          };
          var _parallel = function(eachfn, tasks, callback) {
            callback = callback || function() {};
            if (_isArray(tasks)) {
              eachfn.map(tasks, function(fn, callback) {
                if (fn) {
                  fn(function(err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                      args = args[0];
                    }
                    callback.call(null, err, args);
                  });
                }
              }, callback);
            } else {
              var results = {};
              eachfn.each(_keys(tasks), function(k, callback) {
                tasks[k](function(err) {
                  var args = Array.prototype.slice.call(arguments, 1);
                  if (args.length <= 1) {
                    args = args[0];
                  }
                  results[k] = args;
                  callback(err);
                });
              }, function(err) {
                callback(err, results);
              });
            }
          };
          async.parallel = function(tasks, callback) {
            _parallel({
              map: async.map,
              each: async.each
            }, tasks, callback);
          };
          async.parallelLimit = function(tasks, limit, callback) {
            _parallel({
              map: _mapLimit(limit),
              each: _eachLimit(limit)
            }, tasks, callback);
          };
          async.series = function(tasks, callback) {
            callback = callback || function() {};
            if (_isArray(tasks)) {
              async.mapSeries(tasks, function(fn, callback) {
                if (fn) {
                  fn(function(err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                      args = args[0];
                    }
                    callback.call(null, err, args);
                  });
                }
              }, callback);
            } else {
              var results = {};
              async.eachSeries(_keys(tasks), function(k, callback) {
                tasks[k](function(err) {
                  var args = Array.prototype.slice.call(arguments, 1);
                  if (args.length <= 1) {
                    args = args[0];
                  }
                  results[k] = args;
                  callback(err);
                });
              }, function(err) {
                callback(err, results);
              });
            }
          };
          async.iterator = function(tasks) {
            var makeCallback = function(index) {
              var fn = function() {
                if (tasks.length) {
                  tasks[index].apply(null, arguments);
                }
                return fn.next();
              };
              fn.next = function() {
                return (index < tasks.length - 1) ? makeCallback(index + 1) : null;
              };
              return fn;
            };
            return makeCallback(0);
          };
          async.apply = function(fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            return function() {
              return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
            };
          };
          var _concat = function(eachfn, arr, fn, callback) {
            var r = [];
            eachfn(arr, function(x, cb) {
              fn(x, function(err, y) {
                r = r.concat(y || []);
                cb(err);
              });
            }, function(err) {
              callback(err, r);
            });
          };
          async.concat = doParallel(_concat);
          async.concatSeries = doSeries(_concat);
          async.whilst = function(test, iterator, callback) {
            if (test()) {
              iterator(function(err) {
                if (err) {
                  return callback(err);
                }
                async.whilst(test, iterator, callback);
              });
            } else {
              callback();
            }
          };
          async.doWhilst = function(iterator, test, callback) {
            iterator(function(err) {
              if (err) {
                return callback(err);
              }
              var args = Array.prototype.slice.call(arguments, 1);
              if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
              } else {
                callback();
              }
            });
          };
          async.until = function(test, iterator, callback) {
            if (!test()) {
              iterator(function(err) {
                if (err) {
                  return callback(err);
                }
                async.until(test, iterator, callback);
              });
            } else {
              callback();
            }
          };
          async.doUntil = function(iterator, test, callback) {
            iterator(function(err) {
              if (err) {
                return callback(err);
              }
              var args = Array.prototype.slice.call(arguments, 1);
              if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
              } else {
                callback();
              }
            });
          };
          async.queue = function(worker, concurrency) {
            if (concurrency === undefined) {
              concurrency = 1;
            }
            function _insert(q, data, pos, callback) {
              if (!q.started) {
                q.started = true;
              }
              if (!_isArray(data)) {
                data = [data];
              }
              if (data.length == 0) {
                return async.setImmediate(function() {
                  if (q.drain) {
                    q.drain();
                  }
                });
              }
              _each(data, function(task) {
                var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
                };
                if (pos) {
                  q.tasks.unshift(item);
                } else {
                  q.tasks.push(item);
                }
                if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
                }
                async.setImmediate(q.process);
              });
            }
            var workers = 0;
            var q = {
              tasks: [],
              concurrency: concurrency,
              saturated: null,
              empty: null,
              drain: null,
              started: false,
              paused: false,
              push: function(data, callback) {
                _insert(q, data, false, callback);
              },
              kill: function() {
                q.drain = null;
                q.tasks = [];
              },
              unshift: function(data, callback) {
                _insert(q, data, true, callback);
              },
              process: function() {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                  var task = q.tasks.shift();
                  if (q.empty && q.tasks.length === 0) {
                    q.empty();
                  }
                  workers += 1;
                  var next = function() {
                    workers -= 1;
                    if (task.callback) {
                      task.callback.apply(task, arguments);
                    }
                    if (q.drain && q.tasks.length + workers === 0) {
                      q.drain();
                    }
                    q.process();
                  };
                  var cb = only_once(next);
                  worker(task.data, cb);
                }
              },
              length: function() {
                return q.tasks.length;
              },
              running: function() {
                return workers;
              },
              idle: function() {
                return q.tasks.length + workers === 0;
              },
              pause: function() {
                if (q.paused === true) {
                  return;
                }
                q.paused = true;
                q.process();
              },
              resume: function() {
                if (q.paused === false) {
                  return;
                }
                q.paused = false;
                q.process();
              }
            };
            return q;
          };
          async.priorityQueue = function(worker, concurrency) {
            function _compareTasks(a, b) {
              return a.priority - b.priority;
            }
            ;
            function _binarySearch(sequence, item, compare) {
              var beg = -1,
                  end = sequence.length - 1;
              while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                  beg = mid;
                } else {
                  end = mid - 1;
                }
              }
              return beg;
            }
            function _insert(q, data, priority, callback) {
              if (!q.started) {
                q.started = true;
              }
              if (!_isArray(data)) {
                data = [data];
              }
              if (data.length == 0) {
                return async.setImmediate(function() {
                  if (q.drain) {
                    q.drain();
                  }
                });
              }
              _each(data, function(task) {
                var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
                };
                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
                if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
                }
                async.setImmediate(q.process);
              });
            }
            var q = async.queue(worker, concurrency);
            q.push = function(data, priority, callback) {
              _insert(q, data, priority, callback);
            };
            delete q.unshift;
            return q;
          };
          async.cargo = function(worker, payload) {
            var working = false,
                tasks = [];
            var cargo = {
              tasks: tasks,
              payload: payload,
              saturated: null,
              empty: null,
              drain: null,
              drained: true,
              push: function(data, callback) {
                if (!_isArray(data)) {
                  data = [data];
                }
                _each(data, function(task) {
                  tasks.push({
                    data: task,
                    callback: typeof callback === 'function' ? callback : null
                  });
                  cargo.drained = false;
                  if (cargo.saturated && tasks.length === payload) {
                    cargo.saturated();
                  }
                });
                async.setImmediate(cargo.process);
              },
              process: function process() {
                if (working)
                  return;
                if (tasks.length === 0) {
                  if (cargo.drain && !cargo.drained)
                    cargo.drain();
                  cargo.drained = true;
                  return;
                }
                var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0, tasks.length);
                var ds = _map(ts, function(task) {
                  return task.data;
                });
                if (cargo.empty)
                  cargo.empty();
                working = true;
                worker(ds, function() {
                  working = false;
                  var args = arguments;
                  _each(ts, function(data) {
                    if (data.callback) {
                      data.callback.apply(null, args);
                    }
                  });
                  process();
                });
              },
              length: function() {
                return tasks.length;
              },
              running: function() {
                return working;
              }
            };
            return cargo;
          };
          var _console_fn = function(name) {
            return function(fn) {
              var args = Array.prototype.slice.call(arguments, 1);
              fn.apply(null, args.concat([function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                  if (err) {
                    if (console.error) {
                      console.error(err);
                    }
                  } else if (console[name]) {
                    _each(args, function(x) {
                      console[name](x);
                    });
                  }
                }
              }]));
            };
          };
          async.log = _console_fn('log');
          async.dir = _console_fn('dir');
          async.memoize = function(fn, hasher) {
            var memo = {};
            var queues = {};
            hasher = hasher || function(x) {
              return x;
            };
            var memoized = function() {
              var args = Array.prototype.slice.call(arguments);
              var callback = args.pop();
              var key = hasher.apply(null, args);
              if (key in memo) {
                async.nextTick(function() {
                  callback.apply(null, memo[key]);
                });
              } else if (key in queues) {
                queues[key].push(callback);
              } else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function() {
                  memo[key] = arguments;
                  var q = queues[key];
                  delete queues[key];
                  for (var i = 0,
                      l = q.length; i < l; i++) {
                    q[i].apply(null, arguments);
                  }
                }]));
              }
            };
            memoized.memo = memo;
            memoized.unmemoized = fn;
            return memoized;
          };
          async.unmemoize = function(fn) {
            return function() {
              return (fn.unmemoized || fn).apply(null, arguments);
            };
          };
          async.times = function(count, iterator, callback) {
            var counter = [];
            for (var i = 0; i < count; i++) {
              counter.push(i);
            }
            return async.map(counter, iterator, callback);
          };
          async.timesSeries = function(count, iterator, callback) {
            var counter = [];
            for (var i = 0; i < count; i++) {
              counter.push(i);
            }
            return async.mapSeries(counter, iterator, callback);
          };
          async.seq = function() {
            var fns = arguments;
            return function() {
              var that = this;
              var args = Array.prototype.slice.call(arguments);
              var callback = args.pop();
              async.reduce(fns, args, function(newargs, fn, cb) {
                fn.apply(that, newargs.concat([function() {
                  var err = arguments[0];
                  var nextargs = Array.prototype.slice.call(arguments, 1);
                  cb(err, nextargs);
                }]));
              }, function(err, results) {
                callback.apply(that, [err].concat(results));
              });
            };
          };
          async.compose = function() {
            return async.seq.apply(null, Array.prototype.reverse.call(arguments));
          };
          var _applyEach = function(eachfn, fns) {
            var go = function() {
              var that = this;
              var args = Array.prototype.slice.call(arguments);
              var callback = args.pop();
              return eachfn(fns, function(fn, cb) {
                fn.apply(that, args.concat([cb]));
              }, callback);
            };
            if (arguments.length > 2) {
              var args = Array.prototype.slice.call(arguments, 2);
              return go.apply(this, args);
            } else {
              return go;
            }
          };
          async.applyEach = doParallel(_applyEach);
          async.applyEachSeries = doSeries(_applyEach);
          async.forever = function(fn, callback) {
            function next(err) {
              if (err) {
                if (callback) {
                  return callback(err);
                }
                throw err;
              }
              fn(next);
            }
            next();
          };
          if (typeof module !== 'undefined' && module.exports) {
            module.exports = async;
          } else if (typeof define !== 'undefined' && define.amd) {
            define([], function() {
              return async;
            });
          } else {
            root.async = async;
          }
        }());
      }).call(this, require('_process'));
    }, {_process: 4}],
    3: [function(require, module, exports) {
      (function(process) {
        function normalizeArray(parts, allowAboveRoot) {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === '.') {
              parts.splice(i, 1);
            } else if (last === '..') {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up--; up) {
              parts.unshift('..');
            }
          }
          return parts;
        }
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        var splitPath = function(filename) {
          return splitPathRe.exec(filename).slice(1);
        };
        exports.resolve = function() {
          var resolvedPath = '',
              resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = (i >= 0) ? arguments[i] : process.cwd();
            if (typeof path !== 'string') {
              throw new TypeError('Arguments to path.resolve must be strings');
            } else if (!path) {
              continue;
            }
            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charAt(0) === '/';
          }
          resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
            return !!p;
          }), !resolvedAbsolute).join('/');
          return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
        };
        exports.normalize = function(path) {
          var isAbsolute = exports.isAbsolute(path),
              trailingSlash = substr(path, -1) === '/';
          path = normalizeArray(filter(path.split('/'), function(p) {
            return !!p;
          }), !isAbsolute).join('/');
          if (!path && !isAbsolute) {
            path = '.';
          }
          if (path && trailingSlash) {
            path += '/';
          }
          return (isAbsolute ? '/' : '') + path;
        };
        exports.isAbsolute = function(path) {
          return path.charAt(0) === '/';
        };
        exports.join = function() {
          var paths = Array.prototype.slice.call(arguments, 0);
          return exports.normalize(filter(paths, function(p, index) {
            if (typeof p !== 'string') {
              throw new TypeError('Arguments to path.join must be strings');
            }
            return p;
          }).join('/'));
        };
        exports.relative = function(from, to) {
          from = exports.resolve(from).substr(1);
          to = exports.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== '')
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== '')
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from.split('/'));
          var toParts = trim(to.split('/'));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push('..');
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join('/');
        };
        exports.sep = '/';
        exports.delimiter = ':';
        exports.dirname = function(path) {
          var result = splitPath(path),
              root = result[0],
              dir = result[1];
          if (!root && !dir) {
            return '.';
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        };
        exports.basename = function(path, ext) {
          var f = splitPath(path)[2];
          if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
          }
          return f;
        };
        exports.extname = function(path) {
          return splitPath(path)[3];
        };
        function filter(xs, f) {
          if (xs.filter)
            return xs.filter(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs))
              res.push(xs[i]);
          }
          return res;
        }
        var substr = 'ab'.substr(-1) === 'b' ? function(str, start, len) {
          return str.substr(start, len);
        } : function(str, start, len) {
          if (start < 0)
            start = str.length + start;
          return str.substr(start, len);
        };
        ;
      }).call(this, require('_process'));
    }, {_process: 4}],
    4: [function(require, module, exports) {
      var process = module.exports = {};
      var queue = [];
      var draining = false;
      function drainQueue() {
        if (draining) {
          return;
        }
        draining = true;
        var currentQueue;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          var i = -1;
          while (++i < len) {
            currentQueue[i]();
          }
          len = queue.length;
        }
        draining = false;
      }
      process.nextTick = function(fun) {
        queue.push(fun);
        if (!draining) {
          setTimeout(drainQueue, 0);
        }
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = '';
      process.versions = {};
      function noop() {}
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.binding = function(name) {
        throw new Error('process.binding is not supported');
      };
      process.cwd = function() {
        return '/';
      };
      process.chdir = function(dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function() {
        return 0;
      };
    }, {}],
    5: [function(require, module, exports) {
      (function(global) {
        ;
        (function(root) {
          var freeExports = typeof exports == 'object' && exports;
          var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
          var freeGlobal = typeof global == 'object' && global;
          if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
            root = freeGlobal;
          }
          var punycode,
              maxInt = 2147483647,
              base = 36,
              tMin = 1,
              tMax = 26,
              skew = 38,
              damp = 700,
              initialBias = 72,
              initialN = 128,
              delimiter = '-',
              regexPunycode = /^xn--/,
              regexNonASCII = /[^ -~]/,
              regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g,
              errors = {
                overflow: 'Overflow: input needs wider integers to process',
                'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                'invalid-input': 'Invalid input'
              },
              baseMinusTMin = base - tMin,
              floor = Math.floor,
              stringFromCharCode = String.fromCharCode,
              key;
          function error(type) {
            throw RangeError(errors[type]);
          }
          function map(array, fn) {
            var length = array.length;
            while (length--) {
              array[length] = fn(array[length]);
            }
            return array;
          }
          function mapDomain(string, fn) {
            return map(string.split(regexSeparators), fn).join('.');
          }
          function ucs2decode(string) {
            var output = [],
                counter = 0,
                length = string.length,
                value,
                extra;
            while (counter < length) {
              value = string.charCodeAt(counter++);
              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) {
                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                  output.push(value);
                  counter--;
                }
              } else {
                output.push(value);
              }
            }
            return output;
          }
          function ucs2encode(array) {
            return map(array, function(value) {
              var output = '';
              if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
              }
              output += stringFromCharCode(value);
              return output;
            }).join('');
          }
          function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
              return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
              return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
              return codePoint - 97;
            }
            return base;
          }
          function digitToBasic(digit, flag) {
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
          }
          function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; delta > baseMinusTMin * tMax >> 1; k += base) {
              delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
          }
          function decode(input) {
            var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,
                baseMinusT;
            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
              basic = 0;
            }
            for (j = 0; j < basic; ++j) {
              if (input.charCodeAt(j) >= 0x80) {
                error('not-basic');
              }
              output.push(input.charCodeAt(j));
            }
            for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
              for (oldi = i, w = 1, k = base; ; k += base) {
                if (index >= inputLength) {
                  error('invalid-input');
                }
                digit = basicToDigit(input.charCodeAt(index++));
                if (digit >= base || digit > floor((maxInt - i) / w)) {
                  error('overflow');
                }
                i += digit * w;
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                if (digit < t) {
                  break;
                }
                baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                  error('overflow');
                }
                w *= baseMinusT;
              }
              out = output.length + 1;
              bias = adapt(i - oldi, out, oldi == 0);
              if (floor(i / out) > maxInt - n) {
                error('overflow');
              }
              n += floor(i / out);
              i %= out;
              output.splice(i++, 0, n);
            }
            return ucs2encode(output);
          }
          function encode(input) {
            var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],
                inputLength,
                handledCPCountPlusOne,
                baseMinusT,
                qMinusT;
            input = ucs2decode(input);
            inputLength = input.length;
            n = initialN;
            delta = 0;
            bias = initialBias;
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < 0x80) {
                output.push(stringFromCharCode(currentValue));
              }
            }
            handledCPCount = basicLength = output.length;
            if (basicLength) {
              output.push(delimiter);
            }
            while (handledCPCount < inputLength) {
              for (m = maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                  m = currentValue;
                }
              }
              handledCPCountPlusOne = handledCPCount + 1;
              if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error('overflow');
              }
              delta += (m - n) * handledCPCountPlusOne;
              n = m;
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < n && ++delta > maxInt) {
                  error('overflow');
                }
                if (currentValue == n) {
                  for (q = delta, k = base; ; k += base) {
                    t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                    if (q < t) {
                      break;
                    }
                    qMinusT = q - t;
                    baseMinusT = base - t;
                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = floor(qMinusT / baseMinusT);
                  }
                  output.push(stringFromCharCode(digitToBasic(q, 0)));
                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                  delta = 0;
                  ++handledCPCount;
                }
              }
              ++delta;
              ++n;
            }
            return output.join('');
          }
          function toUnicode(domain) {
            return mapDomain(domain, function(string) {
              return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
          }
          function toASCII(domain) {
            return mapDomain(domain, function(string) {
              return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
            });
          }
          punycode = {
            version: '1.2.4',
            ucs2: {
              decode: ucs2decode,
              encode: ucs2encode
            },
            decode: decode,
            encode: encode,
            toASCII: toASCII,
            toUnicode: toUnicode
          };
          if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
            define('punycode', function() {
              return punycode;
            });
          } else if (freeExports && !freeExports.nodeType) {
            if (freeModule) {
              freeModule.exports = punycode;
            } else {
              for (key in punycode) {
                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
              }
            }
          } else {
            root.punycode = punycode;
          }
        }(this));
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    6: [function(require, module, exports) {
      'use strict';
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      module.exports = function(qs, sep, eq, options) {
        sep = sep || '&';
        eq = eq || '=';
        var obj = {};
        if (typeof qs !== 'string' || qs.length === 0) {
          return obj;
        }
        var regexp = /\+/g;
        qs = qs.split(sep);
        var maxKeys = 1000;
        if (options && typeof options.maxKeys === 'number') {
          maxKeys = options.maxKeys;
        }
        var len = qs.length;
        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }
        for (var i = 0; i < len; ++i) {
          var x = qs[i].replace(regexp, '%20'),
              idx = x.indexOf(eq),
              kstr,
              vstr,
              k,
              v;
          if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
          } else {
            kstr = x;
            vstr = '';
          }
          k = decodeURIComponent(kstr);
          v = decodeURIComponent(vstr);
          if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
          } else if (isArray(obj[k])) {
            obj[k].push(v);
          } else {
            obj[k] = [obj[k], v];
          }
        }
        return obj;
      };
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };
    }, {}],
    7: [function(require, module, exports) {
      'use strict';
      var stringifyPrimitive = function(v) {
        switch (typeof v) {
          case 'string':
            return v;
          case 'boolean':
            return v ? 'true' : 'false';
          case 'number':
            return isFinite(v) ? v : '';
          default:
            return '';
        }
      };
      module.exports = function(obj, sep, eq, name) {
        sep = sep || '&';
        eq = eq || '=';
        if (obj === null) {
          obj = undefined;
        }
        if (typeof obj === 'object') {
          return map(objectKeys(obj), function(k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (isArray(obj[k])) {
              return map(obj[k], function(v) {
                return ks + encodeURIComponent(stringifyPrimitive(v));
              }).join(sep);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
          }).join(sep);
        }
        if (!name)
          return '';
        return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
      };
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };
      function map(xs, f) {
        if (xs.map)
          return xs.map(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          res.push(f(xs[i], i));
        }
        return res;
      }
      var objectKeys = Object.keys || function(obj) {
        var res = [];
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            res.push(key);
        }
        return res;
      };
    }, {}],
    8: [function(require, module, exports) {
      'use strict';
      exports.decode = exports.parse = require('./decode');
      exports.encode = exports.stringify = require('./encode');
    }, {
      "./decode": 6,
      "./encode": 7
    }],
    9: [function(require, module, exports) {
      var punycode = require('punycode');
      exports.parse = urlParse;
      exports.resolve = urlResolve;
      exports.resolveObject = urlResolveObject;
      exports.format = urlFormat;
      exports.Url = Url;
      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }
      var protocolPattern = /^([a-z0-9.+-]+:)/i,
          portPattern = /:[0-9]*$/,
          delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
          unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
          autoEscape = ['\''].concat(unwise),
          nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
          hostEndingChars = ['/', '?', '#'],
          hostnameMaxLen = 255,
          hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
          hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
          unsafeProtocol = {
            javascript: true,
            'javascript:': true
          },
          hostlessProtocol = {
            javascript: true,
            'javascript:': true
          },
          slashedProtocol = {
            http: true,
            https: true,
            ftp: true,
            gopher: true,
            file: true,
            'http:': true,
            'https:': true,
            'ftp:': true,
            'gopher:': true,
            'file:': true
          },
          querystring = require('querystring');
      function urlParse(url, parseQueryString, slashesDenoteHost) {
        if (url && isObject(url) && url instanceof Url)
          return url;
        var u = new Url;
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
      }
      Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
        if (!isString(url)) {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }
        var rest = url;
        rest = rest.trim();
        var proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var slashes = rest.substr(0, 2) === '//';
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }
        if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
          var hostEnd = -1;
          for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          var auth,
              atSign;
          if (hostEnd === -1) {
            atSign = rest.lastIndexOf('@');
          } else {
            atSign = rest.lastIndexOf('@', hostEnd);
          }
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
          }
          hostEnd = -1;
          for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          if (hostEnd === -1)
            hostEnd = rest.length;
          this.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);
          this.parseHost();
          this.hostname = this.hostname || '';
          var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
          if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0,
                l = hostparts.length; i < l; i++) {
              var part = hostparts[i];
              if (!part)
                continue;
              if (!part.match(hostnamePartPattern)) {
                var newpart = '';
                for (var j = 0,
                    k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    newpart += 'x';
                  } else {
                    newpart += part[j];
                  }
                }
                if (!newpart.match(hostnamePartPattern)) {
                  var validParts = hostparts.slice(0, i);
                  var notHost = hostparts.slice(i + 1);
                  var bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = '/' + notHost.join('.') + rest;
                  }
                  this.hostname = validParts.join('.');
                  break;
                }
              }
            }
          }
          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = '';
          } else {
            this.hostname = this.hostname.toLowerCase();
          }
          if (!ipv6Hostname) {
            var domainArray = this.hostname.split('.');
            var newOut = [];
            for (var i = 0; i < domainArray.length; ++i) {
              var s = domainArray[i];
              newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
            }
            this.hostname = newOut.join('.');
          }
          var p = this.port ? ':' + this.port : '';
          var h = this.hostname || '';
          this.host = h + p;
          this.href += this.host;
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== '/') {
              rest = '/' + rest;
            }
          }
        }
        if (!unsafeProtocol[lowerProto]) {
          for (var i = 0,
              l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }
        var hash = rest.indexOf('#');
        if (hash !== -1) {
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf('?');
        if (qm !== -1) {
          this.search = rest.substr(qm);
          this.query = rest.substr(qm + 1);
          if (parseQueryString) {
            this.query = querystring.parse(this.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          this.search = '';
          this.query = {};
        }
        if (rest)
          this.pathname = rest;
        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
          this.pathname = '/';
        }
        if (this.pathname || this.search) {
          var p = this.pathname || '';
          var s = this.search || '';
          this.path = p + s;
        }
        this.href = this.format();
        return this;
      };
      function urlFormat(obj) {
        if (isString(obj))
          obj = urlParse(obj);
        if (!(obj instanceof Url))
          return Url.prototype.format.call(obj);
        return obj.format();
      }
      Url.prototype.format = function() {
        var auth = this.auth || '';
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ':');
          auth += '@';
        }
        var protocol = this.protocol || '',
            pathname = this.pathname || '',
            hash = this.hash || '',
            host = false,
            query = '';
        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
          if (this.port) {
            host += ':' + this.port;
          }
        }
        if (this.query && isObject(this.query) && Object.keys(this.query).length) {
          query = querystring.stringify(this.query);
        }
        var search = this.search || (query && ('?' + query)) || '';
        if (protocol && protocol.substr(-1) !== ':')
          protocol += ':';
        if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
          host = '//' + (host || '');
          if (pathname && pathname.charAt(0) !== '/')
            pathname = '/' + pathname;
        } else if (!host) {
          host = '';
        }
        if (hash && hash.charAt(0) !== '#')
          hash = '#' + hash;
        if (search && search.charAt(0) !== '?')
          search = '?' + search;
        pathname = pathname.replace(/[?#]/g, function(match) {
          return encodeURIComponent(match);
        });
        search = search.replace('#', '%23');
        return protocol + host + pathname + search + hash;
      };
      function urlResolve(source, relative) {
        return urlParse(source, false, true).resolve(relative);
      }
      Url.prototype.resolve = function(relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      };
      function urlResolveObject(source, relative) {
        if (!source)
          return relative;
        return urlParse(source, false, true).resolveObject(relative);
      }
      Url.prototype.resolveObject = function(relative) {
        if (isString(relative)) {
          var rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }
        var result = new Url();
        Object.keys(this).forEach(function(k) {
          result[k] = this[k];
        }, this);
        result.hash = relative.hash;
        if (relative.href === '') {
          result.href = result.format();
          return result;
        }
        if (relative.slashes && !relative.protocol) {
          Object.keys(relative).forEach(function(k) {
            if (k !== 'protocol')
              result[k] = relative[k];
          });
          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = '/';
          }
          result.href = result.format();
          return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
          if (!slashedProtocol[relative.protocol]) {
            Object.keys(relative).forEach(function(k) {
              result[k] = relative[k];
            });
            result.href = result.format();
            return result;
          }
          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || '').split('/');
            while (relPath.length && !(relative.host = relPath.shift()))
              ;
            if (!relative.host)
              relative.host = '';
            if (!relative.hostname)
              relative.hostname = '';
            if (relPath[0] !== '')
              relPath.unshift('');
            if (relPath.length < 2)
              relPath.unshift('');
            result.pathname = relPath.join('/');
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || '';
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          if (result.pathname || result.search) {
            var p = result.pathname || '';
            var s = result.search || '';
            result.path = p + s;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }
        var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
            isRelAbs = (relative.host || relative.pathname && relative.pathname.charAt(0) === '/'),
            mustEndAbs = (isRelAbs || isSourceAbs || (result.host && relative.pathname)),
            removeAllDots = mustEndAbs,
            srcPath = result.pathname && result.pathname.split('/') || [],
            relPath = relative.pathname && relative.pathname.split('/') || [],
            psychotic = result.protocol && !slashedProtocol[result.protocol];
        if (psychotic) {
          result.hostname = '';
          result.port = null;
          if (result.host) {
            if (srcPath[0] === '')
              srcPath[0] = result.host;
            else
              srcPath.unshift(result.host);
          }
          result.host = '';
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === '')
                relPath[0] = relative.host;
              else
                relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
        }
        if (isRelAbs) {
          result.host = (relative.host || relative.host === '') ? relative.host : result.host;
          result.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath)
            srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (!isNullOrUndefined(relative.search)) {
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          if (!isNull(result.pathname) || !isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
          }
          result.href = result.format();
          return result;
        }
        if (!srcPath.length) {
          result.pathname = null;
          if (result.search) {
            result.path = '/' + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = ((result.host || relative.host) && (last === '.' || last === '..') || last === '');
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
          last = srcPath[i];
          if (last == '.') {
            srcPath.splice(i, 1);
          } else if (last === '..') {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift('..');
          }
        }
        if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
          srcPath.unshift('');
        }
        if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
          srcPath.push('');
        }
        var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');
        if (psychotic) {
          result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        mustEndAbs = mustEndAbs || (result.host && srcPath.length);
        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift('');
        }
        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join('/');
        }
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };
      Url.prototype.parseHost = function() {
        var host = this.host;
        var port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ':') {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host)
          this.hostname = host;
      };
      function isString(arg) {
        return typeof arg === "string";
      }
      function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
      }
      function isNull(arg) {
        return arg === null;
      }
      function isNullOrUndefined(arg) {
        return arg == null;
      }
    }, {
      punycode: 5,
      querystring: 8
    }],
    10: [function(require, module, exports) {
      'use strict';
      module.exports = earcut;
      function earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = filterPoints(data, linkedList(data, 0, outerLen, dim, true)),
            triangles = [];
        if (!outerNode)
          return triangles;
        var minX,
            minY,
            maxX,
            maxY,
            x,
            y,
            size;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
          }
          size = Math.max(maxX - minX, maxY - minY);
        }
        earcutLinked(data, outerNode, triangles, dim, minX, minY, size);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var sum = 0,
            i,
            j,
            last;
        for (i = start, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        if (clockwise === (sum > 0)) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, last);
        }
        return last;
      }
      function filterPoints(data, start, end) {
        if (!end)
          end = start;
        var node = start,
            again;
        do {
          again = false;
          if (equals(data, node.i, node.next.i) || orient(data, node.prev.i, node.i, node.next.i) === 0) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
            if (node.prevZ)
              node.prevZ.nextZ = node.nextZ;
            if (node.nextZ)
              node.nextZ.prevZ = node.prevZ;
            node = end = node.prev;
            if (node === node.next)
              return null;
            again = true;
          } else {
            node = node.next;
          }
        } while (again || node !== end);
        return end;
      }
      function earcutLinked(data, ear, triangles, dim, minX, minY, size, pass) {
        if (!ear)
          return;
        if (!pass && minX !== undefined)
          indexCurve(data, ear, minX, minY, size);
        var stop = ear,
            prev,
            next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (isEar(data, ear, minX, minY, size)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            next.prev = prev;
            prev.next = next;
            if (ear.prevZ)
              ear.prevZ.nextZ = ear.nextZ;
            if (ear.nextZ)
              ear.nextZ.prevZ = ear.prevZ;
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(data, filterPoints(data, ear), triangles, dim, minX, minY, size, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(data, ear, triangles, dim);
              earcutLinked(data, ear, triangles, dim, minX, minY, size, 2);
            } else if (pass === 2) {
              splitEarcut(data, ear, triangles, dim, minX, minY, size);
            }
            break;
          }
        }
      }
      function isEar(data, ear, minX, minY, size) {
        var a = ear.prev.i,
            b = ear.i,
            c = ear.next.i,
            ax = data[a],
            ay = data[a + 1],
            bx = data[b],
            by = data[b + 1],
            cx = data[c],
            cy = data[c + 1],
            abd = ax * by - ay * bx,
            acd = ax * cy - ay * cx,
            cbd = cx * by - cy * bx,
            A = abd - acd - cbd;
        if (A <= 0)
          return false;
        var cay = cy - ay,
            acx = ax - cx,
            aby = ay - by,
            bax = bx - ax,
            i,
            px,
            py,
            s,
            t,
            k,
            node;
        if (minX !== undefined) {
          var minTX = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
              minTY = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
              maxTX = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
              maxTY = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy),
              minZ = zOrder(minTX, minTY, minX, minY, size),
              maxZ = zOrder(maxTX, maxTY, minX, minY, size);
          node = ear.nextZ;
          while (node && node.z <= maxZ) {
            i = node.i;
            node = node.nextZ;
            if (i === a || i === c)
              continue;
            px = data[i];
            py = data[i + 1];
            s = cay * px + acx * py - acd;
            if (s >= 0) {
              t = aby * px + bax * py + abd;
              if (t >= 0) {
                k = A - s - t;
                if ((k >= 0) && ((s && t) || (s && k) || (t && k)))
                  return false;
              }
            }
          }
          node = ear.prevZ;
          while (node && node.z >= minZ) {
            i = node.i;
            node = node.prevZ;
            if (i === a || i === c)
              continue;
            px = data[i];
            py = data[i + 1];
            s = cay * px + acx * py - acd;
            if (s >= 0) {
              t = aby * px + bax * py + abd;
              if (t >= 0) {
                k = A - s - t;
                if ((k >= 0) && ((s && t) || (s && k) || (t && k)))
                  return false;
              }
            }
          }
        } else {
          node = ear.next.next;
          while (node !== ear.prev) {
            i = node.i;
            node = node.next;
            px = data[i];
            py = data[i + 1];
            s = cay * px + acx * py - acd;
            if (s >= 0) {
              t = aby * px + bax * py + abd;
              if (t >= 0) {
                k = A - s - t;
                if ((k >= 0) && ((s && t) || (s && k) || (t && k)))
                  return false;
              }
            }
          }
        }
        return true;
      }
      function cureLocalIntersections(data, start, triangles, dim) {
        var node = start;
        do {
          var a = node.prev,
              b = node.next.next;
          if (a.i !== b.i && intersects(data, a.i, node.i, node.next.i, b.i) && locallyInside(data, a, b) && locallyInside(data, b, a)) {
            triangles.push(a.i / dim);
            triangles.push(node.i / dim);
            triangles.push(b.i / dim);
            a.next = b;
            b.prev = a;
            var az = node.prevZ,
                bz = node.nextZ && node.nextZ.nextZ;
            if (az)
              az.nextZ = bz;
            if (bz)
              bz.prevZ = az;
            node = start = b;
          }
          node = node.next;
        } while (node !== start);
        return node;
      }
      function splitEarcut(data, start, triangles, dim, minX, minY, size) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(data, a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(data, a, a.next);
              c = filterPoints(data, c, c.next);
              earcutLinked(data, a, triangles, dim, minX, minY, size);
              earcutLinked(data, c, triangles, dim, minX, minY, size);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i,
            len,
            start,
            end,
            list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = filterPoints(data, linkedList(data, start, end, dim, false));
          if (list)
            queue.push(getLeftmost(data, list));
        }
        queue.sort(function(a, b) {
          return data[a.i] - data[b.i];
        });
        for (i = 0; i < queue.length; i++) {
          eliminateHole(data, queue[i], outerNode);
          outerNode = filterPoints(data, outerNode, outerNode.next);
        }
        return outerNode;
      }
      function eliminateHole(data, holeNode, outerNode) {
        outerNode = findHoleBridge(data, holeNode, outerNode);
        if (outerNode) {
          var b = splitPolygon(outerNode, holeNode);
          filterPoints(data, b, b.next);
        }
      }
      function findHoleBridge(data, holeNode, outerNode) {
        var node = outerNode,
            i = holeNode.i,
            px = data[i],
            py = data[i + 1],
            qMax = -Infinity,
            mNode,
            a,
            b;
        do {
          a = node.i;
          b = node.next.i;
          if (py <= data[a + 1] && py >= data[b + 1]) {
            var qx = data[a] + (py - data[a + 1]) * (data[b] - data[a]) / (data[b + 1] - data[a + 1]);
            if (qx <= px && qx > qMax) {
              qMax = qx;
              mNode = data[a] < data[b] ? node : node.next;
            }
          }
          node = node.next;
        } while (node !== outerNode);
        if (!mNode)
          return null;
        var bx = data[mNode.i],
            by = data[mNode.i + 1],
            pbd = px * by - py * bx,
            pcd = px * py - py * qMax,
            cpy = py - py,
            pcx = px - qMax,
            pby = py - by,
            bpx = bx - px,
            A = pbd - pcd - (qMax * by - py * bx),
            sign = A <= 0 ? -1 : 1,
            stop = mNode,
            tanMin = Infinity,
            mx,
            my,
            amx,
            s,
            t,
            tan;
        node = mNode.next;
        while (node !== stop) {
          mx = data[node.i];
          my = data[node.i + 1];
          amx = px - mx;
          if (amx >= 0 && mx >= bx) {
            s = (cpy * mx + pcx * my - pcd) * sign;
            if (s >= 0) {
              t = (pby * mx + bpx * my + pbd) * sign;
              if (t >= 0 && A * sign - s - t >= 0) {
                tan = Math.abs(py - my) / amx;
                if (tan < tanMin && locallyInside(data, node, holeNode)) {
                  mNode = node;
                  tanMin = tan;
                }
              }
            }
          }
          node = node.next;
        }
        return mNode;
      }
      function indexCurve(data, start, minX, minY, size) {
        var node = start;
        do {
          if (node.z === null)
            node.z = zOrder(data[node.i], data[node.i + 1], minX, minY, size);
          node.prevZ = node.prev;
          node.nextZ = node.next;
          node = node.next;
        } while (node !== start);
        node.prevZ.nextZ = null;
        node.prevZ = null;
        sortLinked(node);
      }
      function sortLinked(list) {
        var i,
            p,
            q,
            e,
            tail,
            numMerges,
            pSize,
            qSize,
            inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || (qSize > 0 && q)) {
              if (pSize === 0) {
                e = q;
                q = q.nextZ;
                qSize--;
              } else if (qSize === 0 || !q) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else if (p.z <= q.z) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, size) {
        x = 1000 * (x - minX) / size;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = 1000 * (y - minY) / size;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
      }
      function getLeftmost(data, start) {
        var node = start,
            leftmost = start;
        do {
          if (data[node.i] < data[leftmost.i])
            leftmost = node;
          node = node.next;
        } while (node !== start);
        return leftmost;
      }
      function isValidDiagonal(data, a, b) {
        return !intersectsPolygon(data, a, a.i, b.i) && locallyInside(data, a, b) && locallyInside(data, b, a) && middleInside(data, a, a.i, b.i);
      }
      function orient(data, p, q, r) {
        var o = (data[q + 1] - data[p + 1]) * (data[r] - data[q]) - (data[q] - data[p]) * (data[r + 1] - data[q + 1]);
        return o > 0 ? 1 : o < 0 ? -1 : 0;
      }
      function equals(data, p1, p2) {
        return data[p1] === data[p2] && data[p1 + 1] === data[p2 + 1];
      }
      function intersects(data, p1, q1, p2, q2) {
        return orient(data, p1, q1, p2) !== orient(data, p1, q1, q2) && orient(data, p2, q2, p1) !== orient(data, p2, q2, q1);
      }
      function intersectsPolygon(data, start, a, b) {
        var node = start;
        do {
          var p1 = node.i,
              p2 = node.next.i;
          if (p1 !== a && p2 !== a && p1 !== b && p2 !== b && intersects(data, p1, p2, a, b))
            return true;
          node = node.next;
        } while (node !== start);
        return false;
      }
      function locallyInside(data, a, b) {
        return orient(data, a.prev.i, a.i, a.next.i) === -1 ? orient(data, a.i, b.i, a.next.i) !== -1 && orient(data, a.i, a.prev.i, b.i) !== -1 : orient(data, a.i, b.i, a.prev.i) === -1 || orient(data, a.i, a.next.i, b.i) === -1;
      }
      function middleInside(data, start, a, b) {
        var node = start,
            inside = false,
            px = (data[a] + data[b]) / 2,
            py = (data[a + 1] + data[b + 1]) / 2;
        do {
          var p1 = node.i,
              p2 = node.next.i;
          if (((data[p1 + 1] > py) !== (data[p2 + 1] > py)) && (px < (data[p2] - data[p1]) * (py - data[p1 + 1]) / (data[p2 + 1] - data[p1 + 1]) + data[p1]))
            inside = !inside;
          node = node.next;
        } while (node !== start);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node(a.i),
            b2 = new Node(b.i),
            an = a.next,
            bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, last) {
        var node = new Node(i);
        if (!last) {
          node.prev = node;
          node.next = node;
        } else {
          node.next = last.next;
          node.prev = last;
          last.next.prev = node;
          last.next = node;
        }
        return node;
      }
      function Node(i) {
        this.i = i;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
      }
    }, {}],
    11: [function(require, module, exports) {
      'use strict';
      var prefix = typeof Object.create !== 'function' ? '~' : false;
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function EventEmitter() {}
      EventEmitter.prototype._events = undefined;
      EventEmitter.prototype.listeners = function listeners(event, exists) {
        var evt = prefix ? prefix + event : event,
            available = this._events && this._events[evt];
        if (exists)
          return !!available;
        if (!available)
          return [];
        if (this._events[evt].fn)
          return [this._events[evt].fn];
        for (var i = 0,
            l = this._events[evt].length,
            ee = new Array(l); i < l; i++) {
          ee[i] = this._events[evt][i].fn;
        }
        return ee;
      };
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events || !this._events[evt])
          return false;
        var listeners = this._events[evt],
            len = arguments.length,
            args,
            i;
        if ('function' === typeof listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, undefined, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length,
              j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, undefined, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter.prototype.on = function on(event, fn, context) {
        var listener = new EE(fn, context || this),
            evt = prefix ? prefix + event : event;
        if (!this._events)
          this._events = prefix ? {} : Object.create(null);
        if (!this._events[evt])
          this._events[evt] = listener;
        else {
          if (!this._events[evt].fn)
            this._events[evt].push(listener);
          else
            this._events[evt] = [this._events[evt], listener];
        }
        return this;
      };
      EventEmitter.prototype.once = function once(event, fn, context) {
        var listener = new EE(fn, context || this, true),
            evt = prefix ? prefix + event : event;
        if (!this._events)
          this._events = prefix ? {} : Object.create(null);
        if (!this._events[evt])
          this._events[evt] = listener;
        else {
          if (!this._events[evt].fn)
            this._events[evt].push(listener);
          else
            this._events[evt] = [this._events[evt], listener];
        }
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events || !this._events[evt])
          return this;
        var listeners = this._events[evt],
            events = [];
        if (fn) {
          if (listeners.fn) {
            if (listeners.fn !== fn || (once && !listeners.once) || (context && listeners.context !== context)) {
              events.push(listeners);
            }
          } else {
            for (var i = 0,
                length = listeners.length; i < length; i++) {
              if (listeners[i].fn !== fn || (once && !listeners[i].once) || (context && listeners[i].context !== context)) {
                events.push(listeners[i]);
              }
            }
          }
        }
        if (events.length) {
          this._events[evt] = events.length === 1 ? events[0] : events;
        } else {
          delete this._events[evt];
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        if (!this._events)
          return this;
        if (event)
          delete this._events[prefix ? prefix + event : event];
        else
          this._events = prefix ? {} : Object.create(null);
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
        return this;
      };
      EventEmitter.prefixed = prefix;
      module.exports = EventEmitter;
    }, {}],
    12: [function(require, module, exports) {
      'use strict';
      function ToObject(val) {
        if (val == null) {
          throw new TypeError('Object.assign cannot be called with null or undefined');
        }
        return Object(val);
      }
      module.exports = Object.assign || function(target, source) {
        var from;
        var keys;
        var to = ToObject(target);
        for (var s = 1; s < arguments.length; s++) {
          from = arguments[s];
          keys = Object.keys(Object(from));
          for (var i = 0; i < keys.length; i++) {
            to[keys[i]] = from[keys[i]];
          }
        }
        return to;
      };
    }, {}],
    13: [function(require, module, exports) {
      (function(process) {
        (function() {
          var async = {};
          var root,
              previous_async;
          root = this;
          if (root != null) {
            previous_async = root.async;
          }
          async.noConflict = function() {
            root.async = previous_async;
            return async;
          };
          function only_once(fn) {
            var called = false;
            return function() {
              if (called)
                throw new Error("Callback was already called.");
              called = true;
              fn.apply(root, arguments);
            };
          }
          var _toString = Object.prototype.toString;
          var _isArray = Array.isArray || function(obj) {
            return _toString.call(obj) === '[object Array]';
          };
          var _each = function(arr, iterator) {
            if (arr.forEach) {
              return arr.forEach(iterator);
            }
            for (var i = 0; i < arr.length; i += 1) {
              iterator(arr[i], i, arr);
            }
          };
          var _map = function(arr, iterator) {
            if (arr.map) {
              return arr.map(iterator);
            }
            var results = [];
            _each(arr, function(x, i, a) {
              results.push(iterator(x, i, a));
            });
            return results;
          };
          var _reduce = function(arr, iterator, memo) {
            if (arr.reduce) {
              return arr.reduce(iterator, memo);
            }
            _each(arr, function(x, i, a) {
              memo = iterator(memo, x, i, a);
            });
            return memo;
          };
          var _keys = function(obj) {
            if (Object.keys) {
              return Object.keys(obj);
            }
            var keys = [];
            for (var k in obj) {
              if (obj.hasOwnProperty(k)) {
                keys.push(k);
              }
            }
            return keys;
          };
          if (typeof process === 'undefined' || !(process.nextTick)) {
            if (typeof setImmediate === 'function') {
              async.nextTick = function(fn) {
                setImmediate(fn);
              };
              async.setImmediate = async.nextTick;
            } else {
              async.nextTick = function(fn) {
                setTimeout(fn, 0);
              };
              async.setImmediate = async.nextTick;
            }
          } else {
            async.nextTick = process.nextTick;
            if (typeof setImmediate !== 'undefined') {
              async.setImmediate = function(fn) {
                setImmediate(fn);
              };
            } else {
              async.setImmediate = async.nextTick;
            }
          }
          async.each = function(arr, iterator, callback) {
            callback = callback || function() {};
            if (!arr.length) {
              return callback();
            }
            var completed = 0;
            _each(arr, function(x) {
              iterator(x, only_once(done));
            });
            function done(err) {
              if (err) {
                callback(err);
                callback = function() {};
              } else {
                completed += 1;
                if (completed >= arr.length) {
                  callback();
                }
              }
            }
          };
          async.forEach = async.each;
          async.eachSeries = function(arr, iterator, callback) {
            callback = callback || function() {};
            if (!arr.length) {
              return callback();
            }
            var completed = 0;
            var iterate = function() {
              iterator(arr[completed], function(err) {
                if (err) {
                  callback(err);
                  callback = function() {};
                } else {
                  completed += 1;
                  if (completed >= arr.length) {
                    callback();
                  } else {
                    iterate();
                  }
                }
              });
            };
            iterate();
          };
          async.forEachSeries = async.eachSeries;
          async.eachLimit = function(arr, limit, iterator, callback) {
            var fn = _eachLimit(limit);
            fn.apply(null, [arr, iterator, callback]);
          };
          async.forEachLimit = async.eachLimit;
          var _eachLimit = function(limit) {
            return function(arr, iterator, callback) {
              callback = callback || function() {};
              if (!arr.length || limit <= 0) {
                return callback();
              }
              var completed = 0;
              var started = 0;
              var running = 0;
              (function replenish() {
                if (completed >= arr.length) {
                  return callback();
                }
                while (running < limit && started < arr.length) {
                  started += 1;
                  running += 1;
                  iterator(arr[started - 1], function(err) {
                    if (err) {
                      callback(err);
                      callback = function() {};
                    } else {
                      completed += 1;
                      running -= 1;
                      if (completed >= arr.length) {
                        callback();
                      } else {
                        replenish();
                      }
                    }
                  });
                }
              })();
            };
          };
          var doParallel = function(fn) {
            return function() {
              var args = Array.prototype.slice.call(arguments);
              return fn.apply(null, [async.each].concat(args));
            };
          };
          var doParallelLimit = function(limit, fn) {
            return function() {
              var args = Array.prototype.slice.call(arguments);
              return fn.apply(null, [_eachLimit(limit)].concat(args));
            };
          };
          var doSeries = function(fn) {
            return function() {
              var args = Array.prototype.slice.call(arguments);
              return fn.apply(null, [async.eachSeries].concat(args));
            };
          };
          var _asyncMap = function(eachfn, arr, iterator, callback) {
            arr = _map(arr, function(x, i) {
              return {
                index: i,
                value: x
              };
            });
            if (!callback) {
              eachfn(arr, function(x, callback) {
                iterator(x.value, function(err) {
                  callback(err);
                });
              });
            } else {
              var results = [];
              eachfn(arr, function(x, callback) {
                iterator(x.value, function(err, v) {
                  results[x.index] = v;
                  callback(err);
                });
              }, function(err) {
                callback(err, results);
              });
            }
          };
          async.map = doParallel(_asyncMap);
          async.mapSeries = doSeries(_asyncMap);
          async.mapLimit = function(arr, limit, iterator, callback) {
            return _mapLimit(limit)(arr, iterator, callback);
          };
          var _mapLimit = function(limit) {
            return doParallelLimit(limit, _asyncMap);
          };
          async.reduce = function(arr, memo, iterator, callback) {
            async.eachSeries(arr, function(x, callback) {
              iterator(memo, x, function(err, v) {
                memo = v;
                callback(err);
              });
            }, function(err) {
              callback(err, memo);
            });
          };
          async.inject = async.reduce;
          async.foldl = async.reduce;
          async.reduceRight = function(arr, memo, iterator, callback) {
            var reversed = _map(arr, function(x) {
              return x;
            }).reverse();
            async.reduce(reversed, memo, iterator, callback);
          };
          async.foldr = async.reduceRight;
          var _filter = function(eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function(x, i) {
              return {
                index: i,
                value: x
              };
            });
            eachfn(arr, function(x, callback) {
              iterator(x.value, function(v) {
                if (v) {
                  results.push(x);
                }
                callback();
              });
            }, function(err) {
              callback(_map(results.sort(function(a, b) {
                return a.index - b.index;
              }), function(x) {
                return x.value;
              }));
            });
          };
          async.filter = doParallel(_filter);
          async.filterSeries = doSeries(_filter);
          async.select = async.filter;
          async.selectSeries = async.filterSeries;
          var _reject = function(eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function(x, i) {
              return {
                index: i,
                value: x
              };
            });
            eachfn(arr, function(x, callback) {
              iterator(x.value, function(v) {
                if (!v) {
                  results.push(x);
                }
                callback();
              });
            }, function(err) {
              callback(_map(results.sort(function(a, b) {
                return a.index - b.index;
              }), function(x) {
                return x.value;
              }));
            });
          };
          async.reject = doParallel(_reject);
          async.rejectSeries = doSeries(_reject);
          var _detect = function(eachfn, arr, iterator, main_callback) {
            eachfn(arr, function(x, callback) {
              iterator(x, function(result) {
                if (result) {
                  main_callback(x);
                  main_callback = function() {};
                } else {
                  callback();
                }
              });
            }, function(err) {
              main_callback();
            });
          };
          async.detect = doParallel(_detect);
          async.detectSeries = doSeries(_detect);
          async.some = function(arr, iterator, main_callback) {
            async.each(arr, function(x, callback) {
              iterator(x, function(v) {
                if (v) {
                  main_callback(true);
                  main_callback = function() {};
                }
                callback();
              });
            }, function(err) {
              main_callback(false);
            });
          };
          async.any = async.some;
          async.every = function(arr, iterator, main_callback) {
            async.each(arr, function(x, callback) {
              iterator(x, function(v) {
                if (!v) {
                  main_callback(false);
                  main_callback = function() {};
                }
                callback();
              });
            }, function(err) {
              main_callback(true);
            });
          };
          async.all = async.every;
          async.sortBy = function(arr, iterator, callback) {
            async.map(arr, function(x, callback) {
              iterator(x, function(err, criteria) {
                if (err) {
                  callback(err);
                } else {
                  callback(null, {
                    value: x,
                    criteria: criteria
                  });
                }
              });
            }, function(err, results) {
              if (err) {
                return callback(err);
              } else {
                var fn = function(left, right) {
                  var a = left.criteria,
                      b = right.criteria;
                  return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function(x) {
                  return x.value;
                }));
              }
            });
          };
          async.auto = function(tasks, callback) {
            callback = callback || function() {};
            var keys = _keys(tasks);
            var remainingTasks = keys.length;
            if (!remainingTasks) {
              return callback();
            }
            var results = {};
            var listeners = [];
            var addListener = function(fn) {
              listeners.unshift(fn);
            };
            var removeListener = function(fn) {
              for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                  listeners.splice(i, 1);
                  return;
                }
              }
            };
            var taskComplete = function() {
              remainingTasks--;
              _each(listeners.slice(0), function(fn) {
                fn();
              });
            };
            addListener(function() {
              if (!remainingTasks) {
                var theCallback = callback;
                callback = function() {};
                theCallback(null, results);
              }
            });
            _each(keys, function(k) {
              var task = _isArray(tasks[k]) ? tasks[k] : [tasks[k]];
              var taskCallback = function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                if (err) {
                  var safeResults = {};
                  _each(_keys(results), function(rkey) {
                    safeResults[rkey] = results[rkey];
                  });
                  safeResults[k] = args;
                  callback(err, safeResults);
                  callback = function() {};
                } else {
                  results[k] = args;
                  async.setImmediate(taskComplete);
                }
              };
              var requires = task.slice(0, Math.abs(task.length - 1)) || [];
              var ready = function() {
                return _reduce(requires, function(a, x) {
                  return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
              };
              if (ready()) {
                task[task.length - 1](taskCallback, results);
              } else {
                var listener = function() {
                  if (ready()) {
                    removeListener(listener);
                    task[task.length - 1](taskCallback, results);
                  }
                };
                addListener(listener);
              }
            });
          };
          async.retry = function(times, task, callback) {
            var DEFAULT_TIMES = 5;
            var attempts = [];
            if (typeof times === 'function') {
              callback = task;
              task = times;
              times = DEFAULT_TIMES;
            }
            times = parseInt(times, 10) || DEFAULT_TIMES;
            var wrappedTask = function(wrappedCallback, wrappedResults) {
              var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                  task(function(err, result) {
                    seriesCallback(!err || finalAttempt, {
                      err: err,
                      result: result
                    });
                  }, wrappedResults);
                };
              };
              while (times) {
                attempts.push(retryAttempt(task, !(times -= 1)));
              }
              async.series(attempts, function(done, data) {
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
              });
            };
            return callback ? wrappedTask() : wrappedTask;
          };
          async.waterfall = function(tasks, callback) {
            callback = callback || function() {};
            if (!_isArray(tasks)) {
              var err = new Error('First argument to waterfall must be an array of functions');
              return callback(err);
            }
            if (!tasks.length) {
              return callback();
            }
            var wrapIterator = function(iterator) {
              return function(err) {
                if (err) {
                  callback.apply(null, arguments);
                  callback = function() {};
                } else {
                  var args = Array.prototype.slice.call(arguments, 1);
                  var next = iterator.next();
                  if (next) {
                    args.push(wrapIterator(next));
                  } else {
                    args.push(callback);
                  }
                  async.setImmediate(function() {
                    iterator.apply(null, args);
                  });
                }
              };
            };
            wrapIterator(async.iterator(tasks))();
          };
          var _parallel = function(eachfn, tasks, callback) {
            callback = callback || function() {};
            if (_isArray(tasks)) {
              eachfn.map(tasks, function(fn, callback) {
                if (fn) {
                  fn(function(err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                      args = args[0];
                    }
                    callback.call(null, err, args);
                  });
                }
              }, callback);
            } else {
              var results = {};
              eachfn.each(_keys(tasks), function(k, callback) {
                tasks[k](function(err) {
                  var args = Array.prototype.slice.call(arguments, 1);
                  if (args.length <= 1) {
                    args = args[0];
                  }
                  results[k] = args;
                  callback(err);
                });
              }, function(err) {
                callback(err, results);
              });
            }
          };
          async.parallel = function(tasks, callback) {
            _parallel({
              map: async.map,
              each: async.each
            }, tasks, callback);
          };
          async.parallelLimit = function(tasks, limit, callback) {
            _parallel({
              map: _mapLimit(limit),
              each: _eachLimit(limit)
            }, tasks, callback);
          };
          async.series = function(tasks, callback) {
            callback = callback || function() {};
            if (_isArray(tasks)) {
              async.mapSeries(tasks, function(fn, callback) {
                if (fn) {
                  fn(function(err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                      args = args[0];
                    }
                    callback.call(null, err, args);
                  });
                }
              }, callback);
            } else {
              var results = {};
              async.eachSeries(_keys(tasks), function(k, callback) {
                tasks[k](function(err) {
                  var args = Array.prototype.slice.call(arguments, 1);
                  if (args.length <= 1) {
                    args = args[0];
                  }
                  results[k] = args;
                  callback(err);
                });
              }, function(err) {
                callback(err, results);
              });
            }
          };
          async.iterator = function(tasks) {
            var makeCallback = function(index) {
              var fn = function() {
                if (tasks.length) {
                  tasks[index].apply(null, arguments);
                }
                return fn.next();
              };
              fn.next = function() {
                return (index < tasks.length - 1) ? makeCallback(index + 1) : null;
              };
              return fn;
            };
            return makeCallback(0);
          };
          async.apply = function(fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            return function() {
              return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
            };
          };
          var _concat = function(eachfn, arr, fn, callback) {
            var r = [];
            eachfn(arr, function(x, cb) {
              fn(x, function(err, y) {
                r = r.concat(y || []);
                cb(err);
              });
            }, function(err) {
              callback(err, r);
            });
          };
          async.concat = doParallel(_concat);
          async.concatSeries = doSeries(_concat);
          async.whilst = function(test, iterator, callback) {
            if (test()) {
              iterator(function(err) {
                if (err) {
                  return callback(err);
                }
                async.whilst(test, iterator, callback);
              });
            } else {
              callback();
            }
          };
          async.doWhilst = function(iterator, test, callback) {
            iterator(function(err) {
              if (err) {
                return callback(err);
              }
              var args = Array.prototype.slice.call(arguments, 1);
              if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
              } else {
                callback();
              }
            });
          };
          async.until = function(test, iterator, callback) {
            if (!test()) {
              iterator(function(err) {
                if (err) {
                  return callback(err);
                }
                async.until(test, iterator, callback);
              });
            } else {
              callback();
            }
          };
          async.doUntil = function(iterator, test, callback) {
            iterator(function(err) {
              if (err) {
                return callback(err);
              }
              var args = Array.prototype.slice.call(arguments, 1);
              if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
              } else {
                callback();
              }
            });
          };
          async.queue = function(worker, concurrency) {
            if (concurrency === undefined) {
              concurrency = 1;
            }
            function _insert(q, data, pos, callback) {
              if (!q.started) {
                q.started = true;
              }
              if (!_isArray(data)) {
                data = [data];
              }
              if (data.length == 0) {
                return async.setImmediate(function() {
                  if (q.drain) {
                    q.drain();
                  }
                });
              }
              _each(data, function(task) {
                var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
                };
                if (pos) {
                  q.tasks.unshift(item);
                } else {
                  q.tasks.push(item);
                }
                if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
                }
                async.setImmediate(q.process);
              });
            }
            var workers = 0;
            var q = {
              tasks: [],
              concurrency: concurrency,
              saturated: null,
              empty: null,
              drain: null,
              started: false,
              paused: false,
              push: function(data, callback) {
                _insert(q, data, false, callback);
              },
              kill: function() {
                q.drain = null;
                q.tasks = [];
              },
              unshift: function(data, callback) {
                _insert(q, data, true, callback);
              },
              process: function() {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                  var task = q.tasks.shift();
                  if (q.empty && q.tasks.length === 0) {
                    q.empty();
                  }
                  workers += 1;
                  var next = function() {
                    workers -= 1;
                    if (task.callback) {
                      task.callback.apply(task, arguments);
                    }
                    if (q.drain && q.tasks.length + workers === 0) {
                      q.drain();
                    }
                    q.process();
                  };
                  var cb = only_once(next);
                  worker(task.data, cb);
                }
              },
              length: function() {
                return q.tasks.length;
              },
              running: function() {
                return workers;
              },
              idle: function() {
                return q.tasks.length + workers === 0;
              },
              pause: function() {
                if (q.paused === true) {
                  return;
                }
                q.paused = true;
                q.process();
              },
              resume: function() {
                if (q.paused === false) {
                  return;
                }
                q.paused = false;
                q.process();
              }
            };
            return q;
          };
          async.priorityQueue = function(worker, concurrency) {
            function _compareTasks(a, b) {
              return a.priority - b.priority;
            }
            ;
            function _binarySearch(sequence, item, compare) {
              var beg = -1,
                  end = sequence.length - 1;
              while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                  beg = mid;
                } else {
                  end = mid - 1;
                }
              }
              return beg;
            }
            function _insert(q, data, priority, callback) {
              if (!q.started) {
                q.started = true;
              }
              if (!_isArray(data)) {
                data = [data];
              }
              if (data.length == 0) {
                return async.setImmediate(function() {
                  if (q.drain) {
                    q.drain();
                  }
                });
              }
              _each(data, function(task) {
                var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
                };
                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
                if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
                }
                async.setImmediate(q.process);
              });
            }
            var q = async.queue(worker, concurrency);
            q.push = function(data, priority, callback) {
              _insert(q, data, priority, callback);
            };
            delete q.unshift;
            return q;
          };
          async.cargo = function(worker, payload) {
            var working = false,
                tasks = [];
            var cargo = {
              tasks: tasks,
              payload: payload,
              saturated: null,
              empty: null,
              drain: null,
              drained: true,
              push: function(data, callback) {
                if (!_isArray(data)) {
                  data = [data];
                }
                _each(data, function(task) {
                  tasks.push({
                    data: task,
                    callback: typeof callback === 'function' ? callback : null
                  });
                  cargo.drained = false;
                  if (cargo.saturated && tasks.length === payload) {
                    cargo.saturated();
                  }
                });
                async.setImmediate(cargo.process);
              },
              process: function process() {
                if (working)
                  return;
                if (tasks.length === 0) {
                  if (cargo.drain && !cargo.drained)
                    cargo.drain();
                  cargo.drained = true;
                  return;
                }
                var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0, tasks.length);
                var ds = _map(ts, function(task) {
                  return task.data;
                });
                if (cargo.empty)
                  cargo.empty();
                working = true;
                worker(ds, function() {
                  working = false;
                  var args = arguments;
                  _each(ts, function(data) {
                    if (data.callback) {
                      data.callback.apply(null, args);
                    }
                  });
                  process();
                });
              },
              length: function() {
                return tasks.length;
              },
              running: function() {
                return working;
              }
            };
            return cargo;
          };
          var _console_fn = function(name) {
            return function(fn) {
              var args = Array.prototype.slice.call(arguments, 1);
              fn.apply(null, args.concat([function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                  if (err) {
                    if (console.error) {
                      console.error(err);
                    }
                  } else if (console[name]) {
                    _each(args, function(x) {
                      console[name](x);
                    });
                  }
                }
              }]));
            };
          };
          async.log = _console_fn('log');
          async.dir = _console_fn('dir');
          async.memoize = function(fn, hasher) {
            var memo = {};
            var queues = {};
            hasher = hasher || function(x) {
              return x;
            };
            var memoized = function() {
              var args = Array.prototype.slice.call(arguments);
              var callback = args.pop();
              var key = hasher.apply(null, args);
              if (key in memo) {
                async.nextTick(function() {
                  callback.apply(null, memo[key]);
                });
              } else if (key in queues) {
                queues[key].push(callback);
              } else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function() {
                  memo[key] = arguments;
                  var q = queues[key];
                  delete queues[key];
                  for (var i = 0,
                      l = q.length; i < l; i++) {
                    q[i].apply(null, arguments);
                  }
                }]));
              }
            };
            memoized.memo = memo;
            memoized.unmemoized = fn;
            return memoized;
          };
          async.unmemoize = function(fn) {
            return function() {
              return (fn.unmemoized || fn).apply(null, arguments);
            };
          };
          async.times = function(count, iterator, callback) {
            var counter = [];
            for (var i = 0; i < count; i++) {
              counter.push(i);
            }
            return async.map(counter, iterator, callback);
          };
          async.timesSeries = function(count, iterator, callback) {
            var counter = [];
            for (var i = 0; i < count; i++) {
              counter.push(i);
            }
            return async.mapSeries(counter, iterator, callback);
          };
          async.seq = function() {
            var fns = arguments;
            return function() {
              var that = this;
              var args = Array.prototype.slice.call(arguments);
              var callback = args.pop();
              async.reduce(fns, args, function(newargs, fn, cb) {
                fn.apply(that, newargs.concat([function() {
                  var err = arguments[0];
                  var nextargs = Array.prototype.slice.call(arguments, 1);
                  cb(err, nextargs);
                }]));
              }, function(err, results) {
                callback.apply(that, [err].concat(results));
              });
            };
          };
          async.compose = function() {
            return async.seq.apply(null, Array.prototype.reverse.call(arguments));
          };
          var _applyEach = function(eachfn, fns) {
            var go = function() {
              var that = this;
              var args = Array.prototype.slice.call(arguments);
              var callback = args.pop();
              return eachfn(fns, function(fn, cb) {
                fn.apply(that, args.concat([cb]));
              }, callback);
            };
            if (arguments.length > 2) {
              var args = Array.prototype.slice.call(arguments, 2);
              return go.apply(this, args);
            } else {
              return go;
            }
          };
          async.applyEach = doParallel(_applyEach);
          async.applyEachSeries = doSeries(_applyEach);
          async.forever = function(fn, callback) {
            function next(err) {
              if (err) {
                if (callback) {
                  return callback(err);
                }
                throw err;
              }
              fn(next);
            }
            next();
          };
          if (typeof module !== 'undefined' && module.exports) {
            module.exports = async;
          } else if (typeof define !== 'undefined' && define.amd) {
            define([], function() {
              return async;
            });
          } else {
            root.async = async;
          }
        }());
      }).call(this, require('_process'));
    }, {_process: 4}],
    14: [function(require, module, exports) {
      arguments[4][11][0].apply(exports, arguments);
    }, {dup: 11}],
    15: [function(require, module, exports) {
      var async = require('async'),
          urlParser = require('url'),
          Resource = require('./Resource'),
          EventEmitter = require('eventemitter3');
      function Loader(baseUrl, concurrency) {
        EventEmitter.call(this);
        concurrency = concurrency || 10;
        this.baseUrl = baseUrl || '';
        this.progress = 0;
        this.loading = false;
        this._progressChunk = 0;
        this._beforeMiddleware = [];
        this._afterMiddleware = [];
        this._boundLoadResource = this._loadResource.bind(this);
        this._boundOnLoad = this._onLoad.bind(this);
        this._buffer = [];
        this._numToLoad = 0;
        this._queue = async.queue(this._boundLoadResource, concurrency);
        this.resources = {};
      }
      Loader.prototype = Object.create(EventEmitter.prototype);
      Loader.prototype.constructor = Loader;
      module.exports = Loader;
      Loader.prototype.add = Loader.prototype.enqueue = function(name, url, options, cb) {
        if (Array.isArray(name)) {
          for (var i = 0; i < name.length; ++i) {
            this.add(name[i]);
          }
          return this;
        }
        if (typeof name === 'object') {
          cb = url || name.callback || name.onComplete;
          options = name;
          url = name.url;
          name = name.name || name.key || name.url;
        }
        if (typeof url !== 'string') {
          cb = options;
          options = url;
          url = name;
        }
        if (typeof url !== 'string') {
          throw new Error('No url passed to add resource to loader.');
        }
        if (typeof options === 'function') {
          cb = options;
          options = null;
        }
        if (this.resources[name]) {
          throw new Error('Resource with name "' + name + '" already exists.');
        }
        url = this._handleBaseUrl(url);
        this.resources[name] = new Resource(name, url, options);
        if (typeof cb === 'function') {
          this.resources[name].once('afterMiddleware', cb);
        }
        this._numToLoad++;
        if (this._queue.started) {
          this._queue.push(this.resources[name]);
          this._progressChunk = (100 - this.progress) / (this._queue.length() + this._queue.running());
        } else {
          this._buffer.push(this.resources[name]);
          this._progressChunk = 100 / this._buffer.length;
        }
        return this;
      };
      Loader.prototype._handleBaseUrl = function(url) {
        var parsedUrl = urlParser.parse(url);
        if (parsedUrl.protocol || parsedUrl.pathname.indexOf('//') === 0) {
          return url;
        }
        if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.lastIndexOf('/') !== url.length - 1) {
          return this.baseUrl + '/' + url;
        } else {
          return this.baseUrl + url;
        }
      };
      Loader.prototype.before = Loader.prototype.pre = function(fn) {
        this._beforeMiddleware.push(fn);
        return this;
      };
      Loader.prototype.after = Loader.prototype.use = function(fn) {
        this._afterMiddleware.push(fn);
        return this;
      };
      Loader.prototype.reset = function() {
        this.progress = 0;
        this.loading = false;
        this._progressChunk = 0;
        this._buffer.length = 0;
        this._numToLoad = 0;
        this._queue.kill();
        this._queue.started = false;
        this.resources = {};
      };
      Loader.prototype.load = function(cb) {
        if (typeof cb === 'function') {
          this.once('complete', cb);
        }
        if (this._queue.started) {
          return this;
        }
        this.emit('start', this);
        for (var i = 0; i < this._buffer.length; ++i) {
          this._queue.push(this._buffer[i]);
        }
        this._buffer.length = 0;
        return this;
      };
      Loader.prototype._loadResource = function(resource, dequeue) {
        var self = this;
        resource._dequeue = dequeue;
        this._runMiddleware(resource, this._beforeMiddleware, function() {
          resource.load(self._boundOnLoad);
        });
      };
      Loader.prototype._onComplete = function() {
        this.emit('complete', this, this.resources);
      };
      Loader.prototype._onLoad = function(resource) {
        this.progress += this._progressChunk;
        this.emit('progress', this, resource);
        if (resource.error) {
          this.emit('error', resource.error, this, resource);
        } else {
          this.emit('load', this, resource);
        }
        this._runMiddleware(resource, this._afterMiddleware, function() {
          resource.emit('afterMiddleware', resource);
          this._numToLoad--;
          if (this._numToLoad === 0) {
            this._onComplete();
          }
        });
        resource._dequeue();
      };
      Loader.prototype._runMiddleware = function(resource, fns, cb) {
        var self = this;
        async.eachSeries(fns, function(fn, next) {
          fn.call(self, resource, next);
        }, cb.bind(this, resource));
      };
      Loader.LOAD_TYPE = Resource.LOAD_TYPE;
      Loader.XHR_READY_STATE = Resource.XHR_READY_STATE;
      Loader.XHR_RESPONSE_TYPE = Resource.XHR_RESPONSE_TYPE;
    }, {
      "./Resource": 16,
      async: 13,
      eventemitter3: 14,
      url: 9
    }],
    16: [function(require, module, exports) {
      var EventEmitter = require('eventemitter3'),
          _url = require('url'),
          useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest()))),
          tempAnchor = null;
      function Resource(name, url, options) {
        EventEmitter.call(this);
        options = options || {};
        if (typeof name !== 'string' || typeof url !== 'string') {
          throw new Error('Both name and url are required for constructing a resource.');
        }
        this.name = name;
        this.url = url;
        this.isDataUrl = this.url.indexOf('data:') === 0;
        this.data = null;
        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : null;
        this.loadType = options.loadType || this._determineLoadType();
        this.xhrType = options.xhrType;
        this.error = null;
        this.xhr = null;
        this.isJson = false;
        this.isXml = false;
        this.isImage = false;
        this.isAudio = false;
        this.isVideo = false;
        this._dequeue = null;
        this._boundComplete = this.complete.bind(this);
        this._boundOnError = this._onError.bind(this);
        this._boundOnProgress = this._onProgress.bind(this);
        this._boundXhrOnError = this._xhrOnError.bind(this);
        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
        this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);
      }
      Resource.prototype = Object.create(EventEmitter.prototype);
      Resource.prototype.constructor = Resource;
      module.exports = Resource;
      Resource.prototype.complete = function() {
        if (this.data && this.data.removeEventListener) {
          this.data.removeEventListener('error', this._boundOnError);
          this.data.removeEventListener('load', this._boundComplete);
          this.data.removeEventListener('progress', this._boundOnProgress);
          this.data.removeEventListener('canplaythrough', this._boundComplete);
        }
        if (this.xhr) {
          if (this.xhr.removeEventListener) {
            this.xhr.removeEventListener('error', this._boundXhrOnError);
            this.xhr.removeEventListener('abort', this._boundXhrOnAbort);
            this.xhr.removeEventListener('progress', this._boundOnProgress);
            this.xhr.removeEventListener('load', this._boundXhrOnLoad);
          } else {
            this.xhr.onerror = null;
            this.xhr.ontimeout = null;
            this.xhr.onprogress = null;
            this.xhr.onload = null;
          }
        }
        this.emit('complete', this);
      };
      Resource.prototype.load = function(cb) {
        this.emit('start', this);
        if (cb) {
          this.once('complete', cb);
        }
        if (typeof this.crossOrigin !== 'string') {
          this.crossOrigin = this._determineCrossOrigin(this.url);
        }
        switch (this.loadType) {
          case Resource.LOAD_TYPE.IMAGE:
            this._loadImage();
            break;
          case Resource.LOAD_TYPE.AUDIO:
            this._loadElement('audio');
            break;
          case Resource.LOAD_TYPE.VIDEO:
            this._loadElement('video');
            break;
          case Resource.LOAD_TYPE.XHR:
          default:
            if (useXdr && this.crossOrigin) {
              this._loadXdr();
            } else {
              this._loadXhr();
            }
            break;
        }
      };
      Resource.prototype._loadImage = function() {
        this.data = new Image();
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        this.data.src = this.url;
        this.isImage = true;
        this.data.addEventListener('error', this._boundOnError, false);
        this.data.addEventListener('load', this._boundComplete, false);
        this.data.addEventListener('progress', this._boundOnProgress, false);
      };
      Resource.prototype._loadElement = function(type) {
        this.data = document.createElement(type);
        if (Array.isArray(this.url)) {
          for (var i = 0; i < this.url.length; ++i) {
            this.data.appendChild(this._createSource(type, this.url[i]));
          }
        } else {
          this.data.appendChild(this._createSource(type, this.url));
        }
        this['is' + type[0].toUpperCase() + type.substring(1)] = true;
        this.data.addEventListener('error', this._boundOnError, false);
        this.data.addEventListener('load', this._boundComplete, false);
        this.data.addEventListener('progress', this._boundOnProgress, false);
        this.data.addEventListener('canplaythrough', this._boundComplete, false);
        this.data.load();
      };
      Resource.prototype._loadXhr = function() {
        if (typeof this.xhrType !== 'string') {
          this.xhrType = this._determineXhrType();
        }
        var xhr = this.xhr = new XMLHttpRequest();
        xhr.open('GET', this.url, true);
        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
          xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
        } else {
          xhr.responseType = this.xhrType;
        }
        xhr.addEventListener('error', this._boundXhrOnError, false);
        xhr.addEventListener('abort', this._boundXhrOnAbort, false);
        xhr.addEventListener('progress', this._boundOnProgress, false);
        xhr.addEventListener('load', this._boundXhrOnLoad, false);
        xhr.send();
      };
      Resource.prototype._loadXdr = function() {
        if (typeof this.xhrType !== 'string') {
          this.xhrType = this._determineXhrType();
        }
        var xdr = this.xhr = new XDomainRequest();
        xdr.timeout = 5000;
        xdr.onerror = this._boundXhrOnError;
        xdr.ontimeout = this._boundXdrOnTimeout;
        xdr.onprogress = this._boundOnProgress;
        xdr.onload = this._boundXhrOnLoad;
        xdr.open('GET', this.url, true);
        setTimeout(function() {
          xdr.send();
        }, 0);
      };
      Resource.prototype._createSource = function(type, url, mime) {
        if (!mime) {
          mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);
        }
        var source = document.createElement('source');
        source.src = url;
        source.type = mime;
        return source;
      };
      Resource.prototype._onError = function(event) {
        this.error = new Error('Failed to load element using ' + event.target.nodeName);
        this.complete();
      };
      Resource.prototype._onProgress = function(event) {
        if (event && event.lengthComputable) {
          this.emit('progress', this, event.loaded / event.total);
        }
      };
      Resource.prototype._xhrOnError = function() {
        this.error = new Error(reqType(this.xhr) + ' Request failed. ' + 'Status: ' + this.xhr.status + ', text: "' + this.xhr.statusText + '"');
        this.complete();
      };
      Resource.prototype._xhrOnAbort = function() {
        this.error = new Error(reqType(this.xhr) + ' Request was aborted by the user.');
        this.complete();
      };
      Resource.prototype._xdrOnTimeout = function() {
        this.error = new Error(reqType(this.xhr) + ' Request timed out.');
        this.complete();
      };
      Resource.prototype._xhrOnLoad = function() {
        var xhr = this.xhr,
            status = xhr.status !== undefined ? xhr.status : 200;
        if (status === 200 || status === 204 || (status === 0 && xhr.responseText.length > 0)) {
          if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
            this.data = xhr.responseText;
          } else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
            try {
              this.data = JSON.parse(xhr.responseText);
              this.isJson = true;
            } catch (e) {
              this.error = new Error('Error trying to parse loaded json:', e);
            }
          } else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
            try {
              if (window.DOMParser) {
                var domparser = new DOMParser();
                this.data = domparser.parseFromString(xhr.responseText, 'text/xml');
              } else {
                var div = document.createElement('div');
                div.innerHTML = xhr.responseText;
                this.data = div;
              }
              this.isXml = true;
            } catch (e) {
              this.error = new Error('Error trying to parse loaded xml:', e);
            }
          } else {
            this.data = xhr.response || xhr.responseText;
          }
        } else {
          this.error = new Error('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);
        }
        this.complete();
      };
      function reqType(xhr) {
        return xhr.toString().replace('object ', '');
      }
      Resource.prototype._determineCrossOrigin = function(url, loc) {
        if (url.indexOf('data:') === 0) {
          return '';
        }
        loc = loc || window.location;
        if (!tempAnchor) {
          tempAnchor = document.createElement('a');
        }
        tempAnchor.href = url;
        url = _url.parse(tempAnchor.href);
        var samePort = (!url.port && loc.port === '') || (url.port === loc.port);
        if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {
          return 'anonymous';
        }
        return '';
      };
      Resource.prototype._determineXhrType = function() {
        return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;
      };
      Resource.prototype._determineLoadType = function() {
        return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;
      };
      Resource.prototype._getExtension = function() {
        var url = this.url,
            ext;
        if (this.isDataUrl) {
          var slashIndex = url.indexOf('/');
          ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
        } else {
          var queryStart = url.indexOf('?');
          if (queryStart !== -1) {
            url = url.substring(0, queryStart);
          }
          ext = url.substring(url.lastIndexOf('.') + 1);
        }
        return ext;
      };
      Resource.prototype._getMimeFromXhrType = function(type) {
        switch (type) {
          case Resource.XHR_RESPONSE_TYPE.BUFFER:
            return 'application/octet-binary';
          case Resource.XHR_RESPONSE_TYPE.BLOB:
            return 'application/blob';
          case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
            return 'application/xml';
          case Resource.XHR_RESPONSE_TYPE.JSON:
            return 'application/json';
          case Resource.XHR_RESPONSE_TYPE.DEFAULT:
          case Resource.XHR_RESPONSE_TYPE.TEXT:
          default:
            return 'text/plain';
        }
      };
      Resource.LOAD_TYPE = {
        XHR: 1,
        IMAGE: 2,
        AUDIO: 3,
        VIDEO: 4
      };
      Resource.XHR_READY_STATE = {
        UNSENT: 0,
        OPENED: 1,
        HEADERS_RECEIVED: 2,
        LOADING: 3,
        DONE: 4
      };
      Resource.XHR_RESPONSE_TYPE = {
        DEFAULT: 'text',
        BUFFER: 'arraybuffer',
        BLOB: 'blob',
        DOCUMENT: 'document',
        JSON: 'json',
        TEXT: 'text'
      };
      Resource._loadTypeMap = {
        gif: Resource.LOAD_TYPE.IMAGE,
        png: Resource.LOAD_TYPE.IMAGE,
        bmp: Resource.LOAD_TYPE.IMAGE,
        jpg: Resource.LOAD_TYPE.IMAGE,
        jpeg: Resource.LOAD_TYPE.IMAGE,
        tif: Resource.LOAD_TYPE.IMAGE,
        tiff: Resource.LOAD_TYPE.IMAGE,
        webp: Resource.LOAD_TYPE.IMAGE,
        tga: Resource.LOAD_TYPE.IMAGE
      };
      Resource._xhrTypeMap = {
        xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        gif: Resource.XHR_RESPONSE_TYPE.BLOB,
        png: Resource.XHR_RESPONSE_TYPE.BLOB,
        bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
        jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
        jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
        tif: Resource.XHR_RESPONSE_TYPE.BLOB,
        tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
        webp: Resource.XHR_RESPONSE_TYPE.BLOB,
        tga: Resource.XHR_RESPONSE_TYPE.BLOB,
        json: Resource.XHR_RESPONSE_TYPE.JSON,
        text: Resource.XHR_RESPONSE_TYPE.TEXT,
        txt: Resource.XHR_RESPONSE_TYPE.TEXT
      };
      Resource.setExtensionLoadType = function(extname, loadType) {
        setExtMap(Resource._loadTypeMap, extname, loadType);
      };
      Resource.setExtensionXhrType = function(extname, xhrType) {
        setExtMap(Resource._xhrTypeMap, extname, xhrType);
      };
      function setExtMap(map, extname, val) {
        if (extname && extname.indexOf('.') === 0) {
          extname = extname.substring(1);
        }
        if (!extname) {
          return;
        }
        map[extname] = val;
      }
    }, {
      eventemitter3: 14,
      url: 9
    }],
    17: [function(require, module, exports) {
      module.exports = {
        _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        encodeBinary: function(input) {
          var output = "";
          var bytebuffer;
          var encodedCharIndexes = new Array(4);
          var inx = 0;
          var jnx = 0;
          var paddingBytes = 0;
          while (inx < input.length) {
            bytebuffer = new Array(3);
            for (jnx = 0; jnx < bytebuffer.length; jnx++) {
              if (inx < input.length) {
                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
              } else {
                bytebuffer[jnx] = 0;
              }
            }
            encodedCharIndexes[0] = bytebuffer[0] >> 2;
            encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);
            encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);
            encodedCharIndexes[3] = bytebuffer[2] & 0x3f;
            paddingBytes = inx - (input.length - 1);
            switch (paddingBytes) {
              case 2:
                encodedCharIndexes[3] = 64;
                encodedCharIndexes[2] = 64;
                break;
              case 1:
                encodedCharIndexes[3] = 64;
                break;
              default:
                break;
            }
            for (jnx = 0; jnx < encodedCharIndexes.length; jnx++) {
              output += this._keyStr.charAt(encodedCharIndexes[jnx]);
            }
          }
          return output;
        }
      };
    }, {}],
    18: [function(require, module, exports) {
      module.exports = require('./Loader');
      module.exports.Resource = require('./Resource');
      module.exports.middleware = {
        caching: {memory: require('./middlewares/caching/memory')},
        parsing: {blob: require('./middlewares/parsing/blob')}
      };
    }, {
      "./Loader": 15,
      "./Resource": 16,
      "./middlewares/caching/memory": 19,
      "./middlewares/parsing/blob": 20
    }],
    19: [function(require, module, exports) {
      var cache = {};
      module.exports = function() {
        return function(resource, next) {
          if (cache[resource.url]) {
            resource.data = cache[resource.url];
            resource.complete();
          } else {
            resource.once('complete', function() {
              cache[this.url] = this.data;
            });
            next();
          }
        };
      };
    }, {}],
    20: [function(require, module, exports) {
      var Resource = require('../../Resource'),
          b64 = require('../../b64');
      window.URL = window.URL || window.webkitURL;
      module.exports = function() {
        return function(resource, next) {
          if (!resource.data) {
            return next();
          }
          if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
            if (!window.Blob || typeof resource.data === 'string') {
              var type = resource.xhr.getResponseHeader('content-type');
              if (type && type.indexOf('image') === 0) {
                resource.data = new Image();
                resource.data.src = 'data:' + type + ';base64,' + b64.encodeBinary(resource.xhr.responseText);
                resource.isImage = true;
                resource.data.onload = function() {
                  resource.data.onload = null;
                  next();
                };
              }
            } else if (resource.data.type.indexOf('image') === 0) {
              var src = URL.createObjectURL(resource.data);
              resource.blob = resource.data;
              resource.data = new Image();
              resource.data.src = src;
              resource.isImage = true;
              resource.data.onload = function() {
                URL.revokeObjectURL(src);
                resource.data.onload = null;
                next();
              };
            }
          } else {
            next();
          }
        };
      };
    }, {
      "../../Resource": 16,
      "../../b64": 17
    }],
    21: [function(require, module, exports) {
      module.exports = {
        name: "pixi.js",
        version: "3.0.7",
        description: "Pixi.js is a fast lightweight 2D library that works across all devices.",
        author: "Mat Groves",
        contributors: ["Chad Engler <chad@pantherdev.com>", "Richard Davey <rdavey@gmail.com>"],
        main: "./src/index.js",
        homepage: "http://goodboydigital.com/",
        bugs: "https://github.com/GoodBoyDigital/pixi.js/issues",
        license: "MIT",
        repository: {
          type: "git",
          url: "https://github.com/GoodBoyDigital/pixi.js.git"
        },
        scripts: {
          start: "gulp && gulp watch",
          test: "gulp && testem ci",
          build: "gulp",
          docs: "jsdoc -c ./gulp/util/jsdoc.conf.json -R README.md"
        },
        files: ["bin/", "src/"],
        dependencies: {
          async: "^0.9.0",
          brfs: "^1.4.0",
          earcut: "^2.0.1",
          eventemitter3: "^1.1.0",
          "object-assign": "^2.0.0",
          "resource-loader": "^1.6.1"
        },
        devDependencies: {
          browserify: "^10.2.3",
          chai: "^3.0.0",
          del: "^1.2.0",
          gulp: "^3.9.0",
          "gulp-cached": "^1.1.0",
          "gulp-concat": "^2.5.2",
          "gulp-debug": "^2.0.1",
          "gulp-jshint": "^1.11.0",
          "gulp-mirror": "^0.4.0",
          "gulp-plumber": "^1.0.1",
          "gulp-rename": "^1.2.2",
          "gulp-sourcemaps": "^1.5.2",
          "gulp-uglify": "^1.2.0",
          "gulp-util": "^3.0.5",
          "jaguarjs-jsdoc": "git+https://github.com/davidshimjs/jaguarjs-jsdoc.git",
          jsdoc: "^3.3.0",
          "jshint-summary": "^0.4.0",
          minimist: "^1.1.1",
          mocha: "^2.2.5",
          "require-dir": "^0.3.0",
          "run-sequence": "^1.1.0",
          testem: "^0.8.3",
          "vinyl-buffer": "^1.0.0",
          "vinyl-source-stream": "^1.1.0",
          watchify: "^3.2.1"
        },
        browserify: {transform: ["brfs"]}
      };
    }, {}],
    22: [function(require, module, exports) {
      var CONST = {
        VERSION: require('../../package.json').version,
        PI_2: Math.PI * 2,
        RAD_TO_DEG: 180 / Math.PI,
        DEG_TO_RAD: Math.PI / 180,
        TARGET_FPMS: 0.06,
        RENDERER_TYPE: {
          UNKNOWN: 0,
          WEBGL: 1,
          CANVAS: 2
        },
        BLEND_MODES: {
          NORMAL: 0,
          ADD: 1,
          MULTIPLY: 2,
          SCREEN: 3,
          OVERLAY: 4,
          DARKEN: 5,
          LIGHTEN: 6,
          COLOR_DODGE: 7,
          COLOR_BURN: 8,
          HARD_LIGHT: 9,
          SOFT_LIGHT: 10,
          DIFFERENCE: 11,
          EXCLUSION: 12,
          HUE: 13,
          SATURATION: 14,
          COLOR: 15,
          LUMINOSITY: 16
        },
        DRAW_MODES: {
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6
        },
        SCALE_MODES: {
          DEFAULT: 0,
          LINEAR: 0,
          NEAREST: 1
        },
        RETINA_PREFIX: /@(.+)x/,
        RESOLUTION: 1,
        FILTER_RESOLUTION: 1,
        DEFAULT_RENDER_OPTIONS: {
          view: null,
          resolution: 1,
          antialias: false,
          forceFXAA: false,
          autoResize: false,
          transparent: false,
          backgroundColor: 0x000000,
          clearBeforeRender: true,
          preserveDrawingBuffer: false
        },
        SHAPES: {
          POLY: 0,
          RECT: 1,
          CIRC: 2,
          ELIP: 3,
          RREC: 4
        },
        SPRITE_BATCH_SIZE: 2000
      };
      module.exports = CONST;
    }, {"../../package.json": 21}],
    23: [function(require, module, exports) {
      var math = require('../math'),
          DisplayObject = require('./DisplayObject'),
          RenderTexture = require('../textures/RenderTexture'),
          _tempMatrix = new math.Matrix();
      function Container() {
        DisplayObject.call(this);
        this.children = [];
      }
      Container.prototype = Object.create(DisplayObject.prototype);
      Container.prototype.constructor = Container;
      module.exports = Container;
      Object.defineProperties(Container.prototype, {
        width: {
          get: function() {
            return this.scale.x * this.getLocalBounds().width;
          },
          set: function(value) {
            var width = this.getLocalBounds().width;
            if (width !== 0) {
              this.scale.x = value / width;
            } else {
              this.scale.x = 1;
            }
            this._width = value;
          }
        },
        height: {
          get: function() {
            return this.scale.y * this.getLocalBounds().height;
          },
          set: function(value) {
            var height = this.getLocalBounds().height;
            if (height !== 0) {
              this.scale.y = value / height;
            } else {
              this.scale.y = 1;
            }
            this._height = value;
          }
        }
      });
      Container.prototype.addChild = function(child) {
        return this.addChildAt(child, this.children.length);
      };
      Container.prototype.addChildAt = function(child, index) {
        if (child === this) {
          return child;
        }
        if (index >= 0 && index <= this.children.length) {
          if (child.parent) {
            child.parent.removeChild(child);
          }
          child.parent = this;
          this.children.splice(index, 0, child);
          child.emit('added', this);
          return child;
        } else {
          throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);
        }
      };
      Container.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
          return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        if (index1 < 0 || index2 < 0) {
          throw new Error('swapChildren: Both the supplied DisplayObjects must be children of the caller.');
        }
        this.children[index1] = child2;
        this.children[index2] = child;
      };
      Container.prototype.getChildIndex = function(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error('The supplied DisplayObject must be a child of the caller');
        }
        return index;
      };
      Container.prototype.setChildIndex = function(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error('The supplied index is out of bounds');
        }
        var currentIndex = this.getChildIndex(child);
        this.children.splice(currentIndex, 1);
        this.children.splice(index, 0, child);
      };
      Container.prototype.getChildAt = function(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error('getChildAt: Supplied index ' + index + ' does not exist in the child list, or the supplied DisplayObject is not a child of the caller');
        }
        return this.children[index];
      };
      Container.prototype.removeChild = function(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
          return;
        }
        return this.removeChildAt(index);
      };
      Container.prototype.removeChildAt = function(index) {
        var child = this.getChildAt(index);
        child.parent = null;
        this.children.splice(index, 1);
        child.emit('removed', this);
        return child;
      };
      Container.prototype.removeChildren = function(beginIndex, endIndex) {
        var begin = beginIndex || 0;
        var end = typeof endIndex === 'number' ? endIndex : this.children.length;
        var range = end - begin;
        if (range > 0 && range <= end) {
          var removed = this.children.splice(begin, range);
          for (var i = 0; i < removed.length; ++i) {
            removed[i].parent = null;
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return [];
        } else {
          throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
        }
      };
      Container.prototype.generateTexture = function(renderer, resolution, scaleMode) {
        var bounds = this.getLocalBounds();
        var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);
        _tempMatrix.tx = -bounds.x;
        _tempMatrix.ty = -bounds.y;
        renderTexture.render(this, _tempMatrix);
        return renderTexture;
      };
      Container.prototype.updateTransform = function() {
        if (!this.visible) {
          return;
        }
        this.displayObjectUpdateTransform();
        for (var i = 0,
            j = this.children.length; i < j; ++i) {
          this.children[i].updateTransform();
        }
      };
      Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
      Container.prototype.getBounds = function() {
        if (!this._currentBounds) {
          if (this.children.length === 0) {
            return math.Rectangle.EMPTY;
          }
          var minX = Infinity;
          var minY = Infinity;
          var maxX = -Infinity;
          var maxY = -Infinity;
          var childBounds;
          var childMaxX;
          var childMaxY;
          var childVisible = false;
          for (var i = 0,
              j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            if (!child.visible) {
              continue;
            }
            childVisible = true;
            childBounds = this.children[i].getBounds();
            minX = minX < childBounds.x ? minX : childBounds.x;
            minY = minY < childBounds.y ? minY : childBounds.y;
            childMaxX = childBounds.width + childBounds.x;
            childMaxY = childBounds.height + childBounds.y;
            maxX = maxX > childMaxX ? maxX : childMaxX;
            maxY = maxY > childMaxY ? maxY : childMaxY;
          }
          if (!childVisible) {
            return math.Rectangle.EMPTY;
          }
          var bounds = this._bounds;
          bounds.x = minX;
          bounds.y = minY;
          bounds.width = maxX - minX;
          bounds.height = maxY - minY;
          this._currentBounds = bounds;
        }
        return this._currentBounds;
      };
      Container.prototype.containerGetBounds = Container.prototype.getBounds;
      Container.prototype.getLocalBounds = function() {
        var matrixCache = this.worldTransform;
        this.worldTransform = math.Matrix.IDENTITY;
        for (var i = 0,
            j = this.children.length; i < j; ++i) {
          this.children[i].updateTransform();
        }
        this.worldTransform = matrixCache;
        this._currentBounds = null;
        return this.getBounds(math.Matrix.IDENTITY);
      };
      Container.prototype.renderWebGL = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
          return;
        }
        var i,
            j;
        if (this._mask || this._filters) {
          renderer.currentRenderer.flush();
          if (this._filters) {
            renderer.filterManager.pushFilter(this, this._filters);
          }
          if (this._mask) {
            renderer.maskManager.pushMask(this, this._mask);
          }
          renderer.currentRenderer.start();
          this._renderWebGL(renderer);
          for (i = 0, j = this.children.length; i < j; i++) {
            this.children[i].renderWebGL(renderer);
          }
          renderer.currentRenderer.flush();
          if (this._mask) {
            renderer.maskManager.popMask(this, this._mask);
          }
          if (this._filters) {
            renderer.filterManager.popFilter();
          }
          renderer.currentRenderer.start();
        } else {
          this._renderWebGL(renderer);
          for (i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].renderWebGL(renderer);
          }
        }
      };
      Container.prototype._renderWebGL = function(renderer) {};
      Container.prototype._renderCanvas = function(renderer) {};
      Container.prototype.renderCanvas = function(renderer) {
        if (!this.visible || this.alpha <= 0 || !this.renderable) {
          return;
        }
        if (this._mask) {
          renderer.maskManager.pushMask(this._mask, renderer);
        }
        this._renderCanvas(renderer);
        for (var i = 0,
            j = this.children.length; i < j; ++i) {
          this.children[i].renderCanvas(renderer);
        }
        if (this._mask) {
          renderer.maskManager.popMask(renderer);
        }
      };
      Container.prototype.destroy = function(destroyChildren) {
        DisplayObject.prototype.destroy.call(this);
        if (destroyChildren) {
          for (var i = 0,
              j = this.children.length; i < j; ++i) {
            this.children[i].destroy(destroyChildren);
          }
        }
        this.removeChildren();
        this.children = null;
      };
    }, {
      "../math": 32,
      "../textures/RenderTexture": 70,
      "./DisplayObject": 24
    }],
    24: [function(require, module, exports) {
      var math = require('../math'),
          RenderTexture = require('../textures/RenderTexture'),
          EventEmitter = require('eventemitter3'),
          CONST = require('../const'),
          _tempMatrix = new math.Matrix();
      function DisplayObject() {
        EventEmitter.call(this);
        this.position = new math.Point();
        this.scale = new math.Point(1, 1);
        this.pivot = new math.Point(0, 0);
        this.rotation = 0;
        this.alpha = 1;
        this.visible = true;
        this.renderable = true;
        this.parent = null;
        this.worldAlpha = 1;
        this.worldTransform = new math.Matrix();
        this.filterArea = null;
        this._sr = 0;
        this._cr = 1;
        this._bounds = new math.Rectangle(0, 0, 1, 1);
        this._currentBounds = null;
        this._mask = null;
        this._cacheAsBitmap = false;
        this._cachedObject = null;
      }
      DisplayObject.prototype = Object.create(EventEmitter.prototype);
      DisplayObject.prototype.constructor = DisplayObject;
      module.exports = DisplayObject;
      Object.defineProperties(DisplayObject.prototype, {
        x: {
          get: function() {
            return this.position.x;
          },
          set: function(value) {
            this.position.x = value;
          }
        },
        y: {
          get: function() {
            return this.position.y;
          },
          set: function(value) {
            this.position.y = value;
          }
        },
        worldVisible: {get: function() {
            var item = this;
            do {
              if (!item.visible) {
                return false;
              }
              item = item.parent;
            } while (item);
            return true;
          }},
        mask: {
          get: function() {
            return this._mask;
          },
          set: function(value) {
            if (this._mask) {
              this._mask.renderable = true;
            }
            this._mask = value;
            if (this._mask) {
              this._mask.renderable = false;
            }
          }
        },
        filters: {
          get: function() {
            return this._filters && this._filters.slice();
          },
          set: function(value) {
            this._filters = value && value.slice();
          }
        }
      });
      DisplayObject.prototype.updateTransform = function() {
        var pt = this.parent.worldTransform;
        var wt = this.worldTransform;
        var a,
            b,
            c,
            d,
            tx,
            ty;
        if (this.rotation % CONST.PI_2) {
          if (this.rotation !== this.rotationCache) {
            this.rotationCache = this.rotation;
            this._sr = Math.sin(this.rotation);
            this._cr = Math.cos(this.rotation);
          }
          a = this._cr * this.scale.x;
          b = this._sr * this.scale.x;
          c = -this._sr * this.scale.y;
          d = this._cr * this.scale.y;
          tx = this.position.x;
          ty = this.position.y;
          if (this.pivot.x || this.pivot.y) {
            tx -= this.pivot.x * a + this.pivot.y * c;
            ty -= this.pivot.x * b + this.pivot.y * d;
          }
          wt.a = a * pt.a + b * pt.c;
          wt.b = a * pt.b + b * pt.d;
          wt.c = c * pt.a + d * pt.c;
          wt.d = c * pt.b + d * pt.d;
          wt.tx = tx * pt.a + ty * pt.c + pt.tx;
          wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        } else {
          a = this.scale.x;
          d = this.scale.y;
          tx = this.position.x - this.pivot.x * a;
          ty = this.position.y - this.pivot.y * d;
          wt.a = a * pt.a;
          wt.b = a * pt.b;
          wt.c = d * pt.c;
          wt.d = d * pt.d;
          wt.tx = tx * pt.a + ty * pt.c + pt.tx;
          wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this._currentBounds = null;
      };
      DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
      DisplayObject.prototype.getBounds = function(matrix) {
        return math.Rectangle.EMPTY;
      };
      DisplayObject.prototype.getLocalBounds = function() {
        return this.getBounds(math.Matrix.IDENTITY);
      };
      DisplayObject.prototype.toGlobal = function(position) {
        this.displayObjectUpdateTransform();
        return this.worldTransform.apply(position);
      };
      DisplayObject.prototype.toLocal = function(position, from) {
        if (from) {
          position = from.toGlobal(position);
        }
        this.displayObjectUpdateTransform();
        return this.worldTransform.applyInverse(position);
      };
      DisplayObject.prototype.renderWebGL = function(renderer) {};
      DisplayObject.prototype.renderCanvas = function(renderer) {};
      DisplayObject.prototype.generateTexture = function(renderer, scaleMode, resolution) {
        var bounds = this.getLocalBounds();
        var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);
        _tempMatrix.tx = -bounds.x;
        _tempMatrix.ty = -bounds.y;
        renderTexture.render(this, _tempMatrix);
        return renderTexture;
      };
      DisplayObject.prototype.destroy = function() {
        this.position = null;
        this.scale = null;
        this.pivot = null;
        this.parent = null;
        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;
        this.worldTransform = null;
        this.filterArea = null;
      };
    }, {
      "../const": 22,
      "../math": 32,
      "../textures/RenderTexture": 70,
      eventemitter3: 11
    }],
    25: [function(require, module, exports) {
      var Container = require('../display/Container'),
          Texture = require('../textures/Texture'),
          CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),
          CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),
          GraphicsData = require('./GraphicsData'),
          math = require('../math'),
          CONST = require('../const'),
          tempPoint = new math.Point();
      function Graphics() {
        Container.call(this);
        this.fillAlpha = 1;
        this.lineWidth = 0;
        this.lineColor = 0;
        this.graphicsData = [];
        this.tint = 0xFFFFFF;
        this._prevTint = 0xFFFFFF;
        this.blendMode = CONST.BLEND_MODES.NORMAL;
        this.currentPath = null;
        this._webGL = {};
        this.isMask = false;
        this.boundsPadding = 0;
        this._localBounds = new math.Rectangle(0, 0, 1, 1);
        this.dirty = true;
        this.glDirty = false;
        this.boundsDirty = true;
        this.cachedSpriteDirty = false;
      }
      Graphics.prototype = Object.create(Container.prototype);
      Graphics.prototype.constructor = Graphics;
      module.exports = Graphics;
      Object.defineProperties(Graphics.prototype, {});
      Graphics.prototype.clone = function() {
        var clone = new Graphics();
        clone.renderable = this.renderable;
        clone.fillAlpha = this.fillAlpha;
        clone.lineWidth = this.lineWidth;
        clone.lineColor = this.lineColor;
        clone.tint = this.tint;
        clone.blendMode = this.blendMode;
        clone.isMask = this.isMask;
        clone.boundsPadding = this.boundsPadding;
        clone.dirty = this.dirty;
        clone.glDirty = this.glDirty;
        clone.cachedSpriteDirty = this.cachedSpriteDirty;
        for (var i = 0; i < this.graphicsData.length; ++i) {
          clone.graphicsData.push(this.graphicsData[i].clone());
        }
        clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];
        clone.updateLocalBounds();
        return clone;
      };
      Graphics.prototype.lineStyle = function(lineWidth, color, alpha) {
        this.lineWidth = lineWidth || 0;
        this.lineColor = color || 0;
        this.lineAlpha = (alpha === undefined) ? 1 : alpha;
        if (this.currentPath) {
          if (this.currentPath.shape.points.length) {
            this.drawShape(new math.Polygon(this.currentPath.shape.points.slice(-2)));
          } else {
            this.currentPath.lineWidth = this.lineWidth;
            this.currentPath.lineColor = this.lineColor;
            this.currentPath.lineAlpha = this.lineAlpha;
          }
        }
        return this;
      };
      Graphics.prototype.moveTo = function(x, y) {
        this.drawShape(new math.Polygon([x, y]));
        return this;
      };
      Graphics.prototype.lineTo = function(x, y) {
        this.currentPath.shape.points.push(x, y);
        this.dirty = true;
        return this;
      };
      Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
        if (this.currentPath) {
          if (this.currentPath.shape.points.length === 0) {
            this.currentPath.shape.points = [0, 0];
          }
        } else {
          this.moveTo(0, 0);
        }
        var xa,
            ya,
            n = 20,
            points = this.currentPath.shape.points;
        if (points.length === 0) {
          this.moveTo(0, 0);
        }
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var j = 0;
        for (var i = 1; i <= n; ++i) {
          j = i / n;
          xa = fromX + ((cpX - fromX) * j);
          ya = fromY + ((cpY - fromY) * j);
          points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j), ya + (((cpY + ((toY - cpY) * j)) - ya) * j));
        }
        this.dirty = this.boundsDirty = true;
        return this;
      };
      Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
        if (this.currentPath) {
          if (this.currentPath.shape.points.length === 0) {
            this.currentPath.shape.points = [0, 0];
          }
        } else {
          this.moveTo(0, 0);
        }
        var n = 20,
            dt,
            dt2,
            dt3,
            t2,
            t3,
            points = this.currentPath.shape.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var j = 0;
        for (var i = 1; i <= n; ++i) {
          j = i / n;
          dt = (1 - j);
          dt2 = dt * dt;
          dt3 = dt2 * dt;
          t2 = j * j;
          t3 = t2 * j;
          points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
        this.dirty = this.boundsDirty = true;
        return this;
      };
      Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        if (this.currentPath) {
          if (this.currentPath.shape.points.length === 0) {
            this.currentPath.shape.points.push(x1, y1);
          }
        } else {
          this.moveTo(x1, y1);
        }
        var points = this.currentPath.shape.points,
            fromX = points[points.length - 2],
            fromY = points[points.length - 1],
            a1 = fromY - y1,
            b1 = fromX - x1,
            a2 = y2 - y1,
            b2 = x2 - x1,
            mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1.0e-8 || radius === 0) {
          if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
            points.push(x1, y1);
          }
        } else {
          var dd = a1 * a1 + b1 * b1,
              cc = a2 * a2 + b2 * b2,
              tt = a1 * a2 + b1 * b2,
              k1 = radius * Math.sqrt(dd) / mm,
              k2 = radius * Math.sqrt(cc) / mm,
              j1 = k1 * tt / dd,
              j2 = k2 * tt / cc,
              cx = k1 * b2 + k2 * b1,
              cy = k1 * a2 + k2 * a1,
              px = b1 * (k2 + j1),
              py = a1 * (k2 + j1),
              qx = b2 * (k1 + j2),
              qy = a2 * (k1 + j2),
              startAngle = Math.atan2(py - cy, px - cx),
              endAngle = Math.atan2(qy - cy, qx - cx);
          this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
        }
        this.dirty = this.boundsDirty = true;
        return this;
      };
      Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        anticlockwise = anticlockwise || false;
        if (startAngle === endAngle) {
          return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
          endAngle += Math.PI * 2;
        } else if (anticlockwise && startAngle <= endAngle) {
          startAngle += Math.PI * 2;
        }
        var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle);
        var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;
        if (sweep === 0) {
          return this;
        }
        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;
        if (this.currentPath) {
          if (anticlockwise && this.filling) {
            this.currentPath.shape.points.push(cx, cy);
          } else {
            this.currentPath.shape.points.push(startX, startY);
          }
        } else {
          if (anticlockwise && this.filling) {
            this.moveTo(cx, cy);
          } else {
            this.moveTo(startX, startY);
          }
        }
        var points = this.currentPath.shape.points;
        var theta = sweep / (segs * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = segs - 1;
        var remainder = (segMinus % 1) / segMinus;
        for (var i = 0; i <= segMinus; i++) {
          var real = i + remainder * i;
          var angle = ((theta) + startAngle + (theta2 * real));
          var c = Math.cos(angle);
          var s = -Math.sin(angle);
          points.push(((cTheta * c) + (sTheta * s)) * radius + cx, ((cTheta * -s) + (sTheta * c)) * radius + cy);
        }
        this.dirty = this.boundsDirty = true;
        return this;
      };
      Graphics.prototype.beginFill = function(color, alpha) {
        this.filling = true;
        this.fillColor = color || 0;
        this.fillAlpha = (alpha === undefined) ? 1 : alpha;
        if (this.currentPath) {
          if (this.currentPath.shape.points.length <= 2) {
            this.currentPath.fill = this.filling;
            this.currentPath.fillColor = this.fillColor;
            this.currentPath.fillAlpha = this.fillAlpha;
          }
        }
        return this;
      };
      Graphics.prototype.endFill = function() {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1;
        return this;
      };
      Graphics.prototype.drawRect = function(x, y, width, height) {
        this.drawShape(new math.Rectangle(x, y, width, height));
        return this;
      };
      Graphics.prototype.drawRoundedRect = function(x, y, width, height, radius) {
        this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));
        return this;
      };
      Graphics.prototype.drawCircle = function(x, y, radius) {
        this.drawShape(new math.Circle(x, y, radius));
        return this;
      };
      Graphics.prototype.drawEllipse = function(x, y, width, height) {
        this.drawShape(new math.Ellipse(x, y, width, height));
        return this;
      };
      Graphics.prototype.drawPolygon = function(path) {
        var points = path;
        if (!Array.isArray(points)) {
          points = new Array(arguments.length);
          for (var i = 0; i < points.length; ++i) {
            points[i] = arguments[i];
          }
        }
        this.drawShape(new math.Polygon(points));
        return this;
      };
      Graphics.prototype.clear = function() {
        this.lineWidth = 0;
        this.filling = false;
        this.dirty = true;
        this.clearDirty = true;
        this.graphicsData = [];
        return this;
      };
      Graphics.prototype.generateTexture = function(renderer, resolution, scaleMode) {
        resolution = resolution || 1;
        var bounds = this.getLocalBounds();
        var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);
        var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);
        texture.baseTexture.resolution = resolution;
        canvasBuffer.context.scale(resolution, resolution);
        canvasBuffer.context.translate(-bounds.x, -bounds.y);
        CanvasGraphics.renderGraphics(this, canvasBuffer.context);
        return texture;
      };
      Graphics.prototype._renderWebGL = function(renderer) {
        if (this.glDirty) {
          this.dirty = true;
          this.glDirty = false;
        }
        renderer.setObjectRenderer(renderer.plugins.graphics);
        renderer.plugins.graphics.render(this);
      };
      Graphics.prototype._renderCanvas = function(renderer) {
        if (this.isMask === true) {
          return;
        }
        if (this._prevTint !== this.tint) {
          this.dirty = true;
          this._prevTint = this.tint;
        }
        var context = renderer.context;
        var transform = this.worldTransform;
        if (this.blendMode !== renderer.currentBlendMode) {
          renderer.currentBlendMode = this.blendMode;
          context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];
        }
        var resolution = renderer.resolution;
        context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
        CanvasGraphics.renderGraphics(this, context);
      };
      Graphics.prototype.getBounds = function(matrix) {
        if (!this._currentBounds) {
          if (!this.renderable) {
            return math.Rectangle.EMPTY;
          }
          if (this.boundsDirty) {
            this.updateLocalBounds();
            this.glDirty = true;
            this.cachedSpriteDirty = true;
            this.boundsDirty = false;
          }
          var bounds = this._localBounds;
          var w0 = bounds.x;
          var w1 = bounds.width + bounds.x;
          var h0 = bounds.y;
          var h1 = bounds.height + bounds.y;
          var worldTransform = matrix || this.worldTransform;
          var a = worldTransform.a;
          var b = worldTransform.b;
          var c = worldTransform.c;
          var d = worldTransform.d;
          var tx = worldTransform.tx;
          var ty = worldTransform.ty;
          var x1 = a * w1 + c * h1 + tx;
          var y1 = d * h1 + b * w1 + ty;
          var x2 = a * w0 + c * h1 + tx;
          var y2 = d * h1 + b * w0 + ty;
          var x3 = a * w0 + c * h0 + tx;
          var y3 = d * h0 + b * w0 + ty;
          var x4 = a * w1 + c * h0 + tx;
          var y4 = d * h0 + b * w1 + ty;
          var maxX = x1;
          var maxY = y1;
          var minX = x1;
          var minY = y1;
          minX = x2 < minX ? x2 : minX;
          minX = x3 < minX ? x3 : minX;
          minX = x4 < minX ? x4 : minX;
          minY = y2 < minY ? y2 : minY;
          minY = y3 < minY ? y3 : minY;
          minY = y4 < minY ? y4 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxX = x3 > maxX ? x3 : maxX;
          maxX = x4 > maxX ? x4 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
          maxY = y3 > maxY ? y3 : maxY;
          maxY = y4 > maxY ? y4 : maxY;
          this._bounds.x = minX;
          this._bounds.width = maxX - minX;
          this._bounds.y = minY;
          this._bounds.height = maxY - minY;
          this._currentBounds = this._bounds;
        }
        return this._currentBounds;
      };
      Graphics.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint);
        var graphicsData = this.graphicsData;
        for (var i = 0; i < graphicsData.length; i++) {
          var data = graphicsData[i];
          if (!data.fill) {
            continue;
          }
          if (data.shape) {
            if (data.shape.contains(tempPoint.x, tempPoint.y)) {
              return true;
            }
          }
        }
        return false;
      };
      Graphics.prototype.updateLocalBounds = function() {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        if (this.graphicsData.length) {
          var shape,
              points,
              x,
              y,
              w,
              h;
          for (var i = 0; i < this.graphicsData.length; i++) {
            var data = this.graphicsData[i];
            var type = data.type;
            var lineWidth = data.lineWidth;
            shape = data.shape;
            if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC) {
              x = shape.x - lineWidth / 2;
              y = shape.y - lineWidth / 2;
              w = shape.width + lineWidth;
              h = shape.height + lineWidth;
              minX = x < minX ? x : minX;
              maxX = x + w > maxX ? x + w : maxX;
              minY = y < minY ? y : minY;
              maxY = y + h > maxY ? y + h : maxY;
            } else if (type === CONST.SHAPES.CIRC) {
              x = shape.x;
              y = shape.y;
              w = shape.radius + lineWidth / 2;
              h = shape.radius + lineWidth / 2;
              minX = x - w < minX ? x - w : minX;
              maxX = x + w > maxX ? x + w : maxX;
              minY = y - h < minY ? y - h : minY;
              maxY = y + h > maxY ? y + h : maxY;
            } else if (type === CONST.SHAPES.ELIP) {
              x = shape.x;
              y = shape.y;
              w = shape.width + lineWidth / 2;
              h = shape.height + lineWidth / 2;
              minX = x - w < minX ? x - w : minX;
              maxX = x + w > maxX ? x + w : maxX;
              minY = y - h < minY ? y - h : minY;
              maxY = y + h > maxY ? y + h : maxY;
            } else {
              points = shape.points;
              for (var j = 0; j < points.length; j += 2) {
                x = points[j];
                y = points[j + 1];
                minX = x - lineWidth < minX ? x - lineWidth : minX;
                maxX = x + lineWidth > maxX ? x + lineWidth : maxX;
                minY = y - lineWidth < minY ? y - lineWidth : minY;
                maxY = y + lineWidth > maxY ? y + lineWidth : maxY;
              }
            }
          }
        } else {
          minX = 0;
          maxX = 0;
          minY = 0;
          maxY = 0;
        }
        var padding = this.boundsPadding;
        this._localBounds.x = minX - padding;
        this._localBounds.width = (maxX - minX) + padding * 2;
        this._localBounds.y = minY - padding;
        this._localBounds.height = (maxY - minY) + padding * 2;
      };
      Graphics.prototype.drawShape = function(shape) {
        if (this.currentPath) {
          if (this.currentPath.shape.points.length <= 2) {
            this.graphicsData.pop();
          }
        }
        this.currentPath = null;
        var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);
        this.graphicsData.push(data);
        if (data.type === CONST.SHAPES.POLY) {
          data.shape.closed = data.shape.closed || this.filling;
          this.currentPath = data;
        }
        this.dirty = this.boundsDirty = true;
        return data;
      };
      Graphics.prototype.destroy = function() {
        Container.prototype.destroy.apply(this, arguments);
        for (var i = 0; i < this.graphicsData.length; ++i) {
          this.graphicsData[i].destroy();
        }
        for (var id in this._webgl) {
          for (var j = 0; j < this._webgl[id].data.length; ++j) {
            this._webgl[id].data[j].destroy();
          }
        }
        this.graphicsData = null;
        this.currentPath = null;
        this._webgl = null;
        this._localBounds = null;
      };
    }, {
      "../const": 22,
      "../display/Container": 23,
      "../math": 32,
      "../renderers/canvas/utils/CanvasBuffer": 44,
      "../renderers/canvas/utils/CanvasGraphics": 45,
      "../textures/Texture": 71,
      "./GraphicsData": 26
    }],
    26: [function(require, module, exports) {
      function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) {
        this.lineWidth = lineWidth;
        this.lineColor = lineColor;
        this.lineAlpha = lineAlpha;
        this._lineTint = lineColor;
        this.fillColor = fillColor;
        this.fillAlpha = fillAlpha;
        this._fillTint = fillColor;
        this.fill = fill;
        this.shape = shape;
        this.type = shape.type;
      }
      GraphicsData.prototype.constructor = GraphicsData;
      module.exports = GraphicsData;
      GraphicsData.prototype.clone = function() {
        return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
      };
      GraphicsData.prototype.destroy = function() {
        this.shape = null;
      };
    }, {}],
    27: [function(require, module, exports) {
      var utils = require('../../utils'),
          math = require('../../math'),
          CONST = require('../../const'),
          ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
          WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
          WebGLGraphicsData = require('./WebGLGraphicsData'),
          earcut = require('earcut');
      function GraphicsRenderer(renderer) {
        ObjectRenderer.call(this, renderer);
        this.graphicsDataPool = [];
        this.primitiveShader = null;
        this.complexPrimitiveShader = null;
        this.maximumSimplePolySize = 200;
      }
      GraphicsRenderer.prototype = Object.create(ObjectRenderer.prototype);
      GraphicsRenderer.prototype.constructor = GraphicsRenderer;
      module.exports = GraphicsRenderer;
      WebGLRenderer.registerPlugin('graphics', GraphicsRenderer);
      GraphicsRenderer.prototype.onContextChange = function() {};
      GraphicsRenderer.prototype.destroy = function() {
        ObjectRenderer.prototype.destroy.call(this);
        for (var i = 0; i < this.graphicsDataPool.length; ++i) {
          this.graphicsDataPool[i].destroy();
        }
        this.graphicsDataPool = null;
      };
      GraphicsRenderer.prototype.render = function(graphics) {
        var renderer = this.renderer;
        var gl = renderer.gl;
        var shader = renderer.shaderManager.plugins.primitiveShader,
            webGLData;
        if (graphics.dirty) {
          this.updateGraphics(graphics, gl);
        }
        var webGL = graphics._webGL[gl.id];
        renderer.blendModeManager.setBlendMode(graphics.blendMode);
        for (var i = 0; i < webGL.data.length; i++) {
          if (webGL.data[i].mode === 1) {
            webGLData = webGL.data[i];
            renderer.stencilManager.pushStencil(graphics, webGLData, renderer);
            gl.uniform1f(renderer.shaderManager.complexPrimitiveShader.uniforms.alpha._location, graphics.worldAlpha * webGLData.alpha);
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
            renderer.stencilManager.popStencil(graphics, webGLData, renderer);
          } else {
            webGLData = webGL.data[i];
            shader = renderer.shaderManager.primitiveShader;
            renderer.shaderManager.setShader(shader);
            gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));
            gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, renderer.currentRenderTarget.projectionMatrix.toArray(true));
            gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));
            gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);
            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
          }
        }
      };
      GraphicsRenderer.prototype.updateGraphics = function(graphics) {
        var gl = this.renderer.gl;
        var webGL = graphics._webGL[gl.id];
        if (!webGL) {
          webGL = graphics._webGL[gl.id] = {
            lastIndex: 0,
            data: [],
            gl: gl
          };
        }
        graphics.dirty = false;
        var i;
        if (graphics.clearDirty) {
          graphics.clearDirty = false;
          for (i = 0; i < webGL.data.length; i++) {
            var graphicsData = webGL.data[i];
            graphicsData.reset();
            this.graphicsDataPool.push(graphicsData);
          }
          webGL.data = [];
          webGL.lastIndex = 0;
        }
        var webGLData;
        for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++) {
          var data = graphics.graphicsData[i];
          if (data.type === CONST.SHAPES.POLY) {
            data.points = data.shape.points.slice();
            if (data.shape.closed) {
              if (data.points[0] !== data.points[data.points.length - 2] || data.points[1] !== data.points[data.points.length - 1]) {
                data.points.push(data.points[0], data.points[1]);
              }
            }
            if (data.fill) {
              if (data.points.length >= 6) {
                if (data.points.length < this.maximumSimplePolySize * 2) {
                  webGLData = this.switchMode(webGL, 0);
                  var canDrawUsingSimple = this.buildPoly(data, webGLData);
                  if (!canDrawUsingSimple) {
                    webGLData = this.switchMode(webGL, 1);
                    this.buildComplexPoly(data, webGLData);
                  }
                } else {
                  webGLData = this.switchMode(webGL, 1);
                  this.buildComplexPoly(data, webGLData);
                }
              }
            }
            if (data.lineWidth > 0) {
              webGLData = this.switchMode(webGL, 0);
              this.buildLine(data, webGLData);
            }
          } else {
            webGLData = this.switchMode(webGL, 0);
            if (data.type === CONST.SHAPES.RECT) {
              this.buildRectangle(data, webGLData);
            } else if (data.type === CONST.SHAPES.CIRC || data.type === CONST.SHAPES.ELIP) {
              this.buildCircle(data, webGLData);
            } else if (data.type === CONST.SHAPES.RREC) {
              this.buildRoundedRectangle(data, webGLData);
            }
          }
          webGL.lastIndex++;
        }
        for (i = 0; i < webGL.data.length; i++) {
          webGLData = webGL.data[i];
          if (webGLData.dirty) {
            webGLData.upload();
          }
        }
      };
      GraphicsRenderer.prototype.switchMode = function(webGL, type) {
        var webGLData;
        if (!webGL.data.length) {
          webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
          webGLData.mode = type;
          webGL.data.push(webGLData);
        } else {
          webGLData = webGL.data[webGL.data.length - 1];
          if ((webGLData.points.length > 320000) || webGLData.mode !== type || type === 1) {
            webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
          }
        }
        webGLData.dirty = true;
        return webGLData;
      };
      GraphicsRenderer.prototype.buildRectangle = function(graphicsData, webGLData) {
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;
        if (graphicsData.fill) {
          var color = utils.hex2rgb(graphicsData.fillColor);
          var alpha = graphicsData.fillAlpha;
          var r = color[0] * alpha;
          var g = color[1] * alpha;
          var b = color[2] * alpha;
          var verts = webGLData.points;
          var indices = webGLData.indices;
          var vertPos = verts.length / 6;
          verts.push(x, y);
          verts.push(r, g, b, alpha);
          verts.push(x + width, y);
          verts.push(r, g, b, alpha);
          verts.push(x, y + height);
          verts.push(r, g, b, alpha);
          verts.push(x + width, y + height);
          verts.push(r, g, b, alpha);
          indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
        }
        if (graphicsData.lineWidth) {
          var tempPoints = graphicsData.points;
          graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];
          this.buildLine(graphicsData, webGLData);
          graphicsData.points = tempPoints;
        }
      };
      GraphicsRenderer.prototype.buildRoundedRectangle = function(graphicsData, webGLData) {
        var rrectData = graphicsData.shape;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;
        var radius = rrectData.radius;
        var recPoints = [];
        recPoints.push(x, y + radius);
        this.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
        this.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
        this.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
        this.quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);
        if (graphicsData.fill) {
          var color = utils.hex2rgb(graphicsData.fillColor);
          var alpha = graphicsData.fillAlpha;
          var r = color[0] * alpha;
          var g = color[1] * alpha;
          var b = color[2] * alpha;
          var verts = webGLData.points;
          var indices = webGLData.indices;
          var vecPos = verts.length / 6;
          var triangles = earcut(recPoints, null, 2);
          var i = 0;
          for (i = 0; i < triangles.length; i += 3) {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
          }
          for (i = 0; i < recPoints.length; i++) {
            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
          }
        }
        if (graphicsData.lineWidth) {
          var tempPoints = graphicsData.points;
          graphicsData.points = recPoints;
          this.buildLine(graphicsData, webGLData);
          graphicsData.points = tempPoints;
        }
      };
      GraphicsRenderer.prototype.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY, out) {
        var xa,
            ya,
            xb,
            yb,
            x,
            y,
            n = 20,
            points = out || [];
        function getPt(n1, n2, perc) {
          var diff = n2 - n1;
          return n1 + (diff * perc);
        }
        var j = 0;
        for (var i = 0; i <= n; i++) {
          j = i / n;
          xa = getPt(fromX, cpX, j);
          ya = getPt(fromY, cpY, j);
          xb = getPt(cpX, toX, j);
          yb = getPt(cpY, toY, j);
          x = getPt(xa, xb, j);
          y = getPt(ya, yb, j);
          points.push(x, y);
        }
        return points;
      };
      GraphicsRenderer.prototype.buildCircle = function(graphicsData, webGLData) {
        var circleData = graphicsData.shape;
        var x = circleData.x;
        var y = circleData.y;
        var width;
        var height;
        if (graphicsData.type === CONST.SHAPES.CIRC) {
          width = circleData.radius;
          height = circleData.radius;
        } else {
          width = circleData.width;
          height = circleData.height;
        }
        var totalSegs = 40;
        var seg = (Math.PI * 2) / totalSegs;
        var i = 0;
        if (graphicsData.fill) {
          var color = utils.hex2rgb(graphicsData.fillColor);
          var alpha = graphicsData.fillAlpha;
          var r = color[0] * alpha;
          var g = color[1] * alpha;
          var b = color[2] * alpha;
          var verts = webGLData.points;
          var indices = webGLData.indices;
          var vecPos = verts.length / 6;
          indices.push(vecPos);
          for (i = 0; i < totalSegs + 1; i++) {
            verts.push(x, y, r, g, b, alpha);
            verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);
            indices.push(vecPos++, vecPos++);
          }
          indices.push(vecPos - 1);
        }
        if (graphicsData.lineWidth) {
          var tempPoints = graphicsData.points;
          graphicsData.points = [];
          for (i = 0; i < totalSegs + 1; i++) {
            graphicsData.points.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height);
          }
          this.buildLine(graphicsData, webGLData);
          graphicsData.points = tempPoints;
        }
      };
      GraphicsRenderer.prototype.buildLine = function(graphicsData, webGLData) {
        var i = 0;
        var points = graphicsData.points;
        if (points.length === 0) {
          return;
        }
        if (graphicsData.lineWidth % 2) {
          for (i = 0; i < points.length; i++) {
            points[i] += 0.5;
          }
        }
        var firstPoint = new math.Point(points[0], points[1]);
        var lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);
        if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
          points = points.slice();
          points.pop();
          points.pop();
          lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);
          var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;
          var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;
          points.unshift(midPointX, midPointY);
          points.push(midPointX, midPointY);
        }
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 6;
        var width = graphicsData.lineWidth / 2;
        var color = utils.hex2rgb(graphicsData.lineColor);
        var alpha = graphicsData.lineAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var px,
            py,
            p1x,
            p1y,
            p2x,
            p2y,
            p3x,
            p3y;
        var perpx,
            perpy,
            perp2x,
            perp2y,
            perp3x,
            perp3y;
        var a1,
            b1,
            c1,
            a2,
            b2,
            c2;
        var denom,
            pdist,
            dist;
        p1x = points[0];
        p1y = points[1];
        p2x = points[2];
        p2y = points[3];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);
        verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);
        for (i = 1; i < length - 1; i++) {
          p1x = points[(i - 1) * 2];
          p1y = points[(i - 1) * 2 + 1];
          p2x = points[(i) * 2];
          p2y = points[(i) * 2 + 1];
          p3x = points[(i + 1) * 2];
          p3y = points[(i + 1) * 2 + 1];
          perpx = -(p1y - p2y);
          perpy = p1x - p2x;
          dist = Math.sqrt(perpx * perpx + perpy * perpy);
          perpx /= dist;
          perpy /= dist;
          perpx *= width;
          perpy *= width;
          perp2x = -(p2y - p3y);
          perp2y = p2x - p3x;
          dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
          perp2x /= dist;
          perp2y /= dist;
          perp2x *= width;
          perp2y *= width;
          a1 = (-perpy + p1y) - (-perpy + p2y);
          b1 = (-perpx + p2x) - (-perpx + p1x);
          c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
          a2 = (-perp2y + p3y) - (-perp2y + p2y);
          b2 = (-perp2x + p2x) - (-perp2x + p3x);
          c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
          denom = a1 * b2 - a2 * b1;
          if (Math.abs(denom) < 0.1) {
            denom += 10.1;
            verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);
            verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);
            continue;
          }
          px = (b1 * c2 - b2 * c1) / denom;
          py = (a2 * c1 - a1 * c2) / denom;
          pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
          if (pdist > 140 * 140) {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;
            dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;
            verts.push(p2x - perp3x, p2y - perp3y);
            verts.push(r, g, b, alpha);
            verts.push(p2x + perp3x, p2y + perp3y);
            verts.push(r, g, b, alpha);
            verts.push(p2x - perp3x, p2y - perp3y);
            verts.push(r, g, b, alpha);
            indexCount++;
          } else {
            verts.push(px, py);
            verts.push(r, g, b, alpha);
            verts.push(p2x - (px - p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
          }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[(length - 2) * 2 + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[(length - 1) * 2 + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - perpx, p2y - perpy);
        verts.push(r, g, b, alpha);
        verts.push(p2x + perpx, p2y + perpy);
        verts.push(r, g, b, alpha);
        indices.push(indexStart);
        for (i = 0; i < indexCount; i++) {
          indices.push(indexStart++);
        }
        indices.push(indexStart - 1);
      };
      GraphicsRenderer.prototype.buildComplexPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points.slice();
        if (points.length < 6) {
          return;
        }
        var indices = webGLData.indices;
        webGLData.points = points;
        webGLData.alpha = graphicsData.fillAlpha;
        webGLData.color = utils.hex2rgb(graphicsData.fillColor);
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var x,
            y;
        for (var i = 0; i < points.length; i += 2) {
          x = points[i];
          y = points[i + 1];
          minX = x < minX ? x : minX;
          maxX = x > maxX ? x : maxX;
          minY = y < minY ? y : minY;
          maxY = y > maxY ? y : maxY;
        }
        points.push(minX, minY, maxX, minY, maxX, maxY, minX, maxY);
        var length = points.length / 2;
        for (i = 0; i < length; i++) {
          indices.push(i);
        }
      };
      GraphicsRenderer.prototype.buildPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points;
        if (points.length < 6) {
          return;
        }
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var triangles = earcut(points, null, 2);
        if (!triangles) {
          return false;
        }
        var vertPos = verts.length / 6;
        var i = 0;
        for (i = 0; i < triangles.length; i += 3) {
          indices.push(triangles[i] + vertPos);
          indices.push(triangles[i] + vertPos);
          indices.push(triangles[i + 1] + vertPos);
          indices.push(triangles[i + 2] + vertPos);
          indices.push(triangles[i + 2] + vertPos);
        }
        for (i = 0; i < length; i++) {
          verts.push(points[i * 2], points[i * 2 + 1], r, g, b, alpha);
        }
        return true;
      };
    }, {
      "../../const": 22,
      "../../math": 32,
      "../../renderers/webgl/WebGLRenderer": 48,
      "../../renderers/webgl/utils/ObjectRenderer": 62,
      "../../utils": 76,
      "./WebGLGraphicsData": 28,
      earcut: 10
    }],
    28: [function(require, module, exports) {
      function WebGLGraphicsData(gl) {
        this.gl = gl;
        this.color = [0, 0, 0];
        this.points = [];
        this.indices = [];
        this.buffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.mode = 1;
        this.alpha = 1;
        this.dirty = true;
        this.glPoints = null;
        this.glIndices = null;
      }
      WebGLGraphicsData.prototype.constructor = WebGLGraphicsData;
      module.exports = WebGLGraphicsData;
      WebGLGraphicsData.prototype.reset = function() {
        this.points.length = 0;
        this.indices.length = 0;
      };
      WebGLGraphicsData.prototype.upload = function() {
        var gl = this.gl;
        this.glPoints = new Float32Array(this.points);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);
        this.glIndices = new Uint16Array(this.indices);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndices, gl.STATIC_DRAW);
        this.dirty = false;
      };
      WebGLGraphicsData.prototype.destroy = function() {
        this.color = null;
        this.points = null;
        this.indices = null;
        this.gl.deleteBuffer(this.buffer);
        this.gl.deleteBuffer(this.indexBuffer);
        this.gl = null;
        this.buffer = null;
        this.indexBuffer = null;
        this.glPoints = null;
        this.glIndices = null;
      };
    }, {}],
    29: [function(require, module, exports) {
      var core = module.exports = Object.assign(require('./const'), require('./math'), {
        utils: require('./utils'),
        ticker: require('./ticker'),
        DisplayObject: require('./display/DisplayObject'),
        Container: require('./display/Container'),
        Sprite: require('./sprites/Sprite'),
        ParticleContainer: require('./particles/ParticleContainer'),
        SpriteRenderer: require('./sprites/webgl/SpriteRenderer'),
        ParticleRenderer: require('./particles/webgl/ParticleRenderer'),
        Text: require('./text/Text'),
        Graphics: require('./graphics/Graphics'),
        GraphicsData: require('./graphics/GraphicsData'),
        GraphicsRenderer: require('./graphics/webgl/GraphicsRenderer'),
        Texture: require('./textures/Texture'),
        BaseTexture: require('./textures/BaseTexture'),
        RenderTexture: require('./textures/RenderTexture'),
        VideoBaseTexture: require('./textures/VideoBaseTexture'),
        TextureUvs: require('./textures/TextureUvs'),
        CanvasRenderer: require('./renderers/canvas/CanvasRenderer'),
        CanvasGraphics: require('./renderers/canvas/utils/CanvasGraphics'),
        CanvasBuffer: require('./renderers/canvas/utils/CanvasBuffer'),
        WebGLRenderer: require('./renderers/webgl/WebGLRenderer'),
        ShaderManager: require('./renderers/webgl/managers/ShaderManager'),
        Shader: require('./renderers/webgl/shaders/Shader'),
        ObjectRenderer: require('./renderers/webgl/utils/ObjectRenderer'),
        RenderTarget: require('./renderers/webgl/utils/RenderTarget'),
        AbstractFilter: require('./renderers/webgl/filters/AbstractFilter'),
        FXAAFilter: require('./renderers/webgl/filters/FXAAFilter'),
        SpriteMaskFilter: require('./renderers/webgl/filters/SpriteMaskFilter'),
        autoDetectRenderer: function(width, height, options, noWebGL) {
          width = width || 800;
          height = height || 600;
          if (!noWebGL && core.utils.isWebGLSupported()) {
            return new core.WebGLRenderer(width, height, options);
          }
          return new core.CanvasRenderer(width, height, options);
        }
      });
    }, {
      "./const": 22,
      "./display/Container": 23,
      "./display/DisplayObject": 24,
      "./graphics/Graphics": 25,
      "./graphics/GraphicsData": 26,
      "./graphics/webgl/GraphicsRenderer": 27,
      "./math": 32,
      "./particles/ParticleContainer": 38,
      "./particles/webgl/ParticleRenderer": 40,
      "./renderers/canvas/CanvasRenderer": 43,
      "./renderers/canvas/utils/CanvasBuffer": 44,
      "./renderers/canvas/utils/CanvasGraphics": 45,
      "./renderers/webgl/WebGLRenderer": 48,
      "./renderers/webgl/filters/AbstractFilter": 49,
      "./renderers/webgl/filters/FXAAFilter": 50,
      "./renderers/webgl/filters/SpriteMaskFilter": 51,
      "./renderers/webgl/managers/ShaderManager": 55,
      "./renderers/webgl/shaders/Shader": 60,
      "./renderers/webgl/utils/ObjectRenderer": 62,
      "./renderers/webgl/utils/RenderTarget": 64,
      "./sprites/Sprite": 66,
      "./sprites/webgl/SpriteRenderer": 67,
      "./text/Text": 68,
      "./textures/BaseTexture": 69,
      "./textures/RenderTexture": 70,
      "./textures/Texture": 71,
      "./textures/TextureUvs": 72,
      "./textures/VideoBaseTexture": 73,
      "./ticker": 75,
      "./utils": 76
    }],
    30: [function(require, module, exports) {
      var Point = require('./Point');
      function Matrix() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
      }
      Matrix.prototype.constructor = Matrix;
      module.exports = Matrix;
      Matrix.prototype.fromArray = function(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      };
      Matrix.prototype.toArray = function(transpose, out) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      };
      Matrix.prototype.apply = function(pos, newPos) {
        newPos = newPos || new Point();
        var x = pos.x;
        var y = pos.y;
        newPos.x = this.a * x + this.c * y + this.tx;
        newPos.y = this.b * x + this.d * y + this.ty;
        return newPos;
      };
      Matrix.prototype.applyInverse = function(pos, newPos) {
        newPos = newPos || new Point();
        var id = 1 / (this.a * this.d + this.c * -this.b);
        var x = pos.x;
        var y = pos.y;
        newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
        newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
        return newPos;
      };
      Matrix.prototype.translate = function(x, y) {
        this.tx += x;
        this.ty += y;
        return this;
      };
      Matrix.prototype.scale = function(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
      };
      Matrix.prototype.rotate = function(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      };
      Matrix.prototype.append = function(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      };
      Matrix.prototype.prepend = function(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          var a1 = this.a;
          var c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      };
      Matrix.prototype.invert = function() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = a1 * d1 - b1 * c1;
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;
        return this;
      };
      Matrix.prototype.identity = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      };
      Matrix.prototype.clone = function() {
        var matrix = new Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix.prototype.copy = function(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix.IDENTITY = new Matrix();
      Matrix.TEMP_MATRIX = new Matrix();
    }, {"./Point": 31}],
    31: [function(require, module, exports) {
      function Point(x, y) {
        this.x = x || 0;
        this.y = y || 0;
      }
      Point.prototype.constructor = Point;
      module.exports = Point;
      Point.prototype.clone = function() {
        return new Point(this.x, this.y);
      };
      Point.prototype.copy = function(p) {
        this.set(p.x, p.y);
      };
      Point.prototype.equals = function(p) {
        return (p.x === this.x) && (p.y === this.y);
      };
      Point.prototype.set = function(x, y) {
        this.x = x || 0;
        this.y = y || ((y !== 0) ? this.x : 0);
      };
    }, {}],
    32: [function(require, module, exports) {
      module.exports = {
        Point: require('./Point'),
        Matrix: require('./Matrix'),
        Circle: require('./shapes/Circle'),
        Ellipse: require('./shapes/Ellipse'),
        Polygon: require('./shapes/Polygon'),
        Rectangle: require('./shapes/Rectangle'),
        RoundedRectangle: require('./shapes/RoundedRectangle')
      };
    }, {
      "./Matrix": 30,
      "./Point": 31,
      "./shapes/Circle": 33,
      "./shapes/Ellipse": 34,
      "./shapes/Polygon": 35,
      "./shapes/Rectangle": 36,
      "./shapes/RoundedRectangle": 37
    }],
    33: [function(require, module, exports) {
      var Rectangle = require('./Rectangle'),
          CONST = require('../../const');
      function Circle(x, y, radius) {
        this.x = x || 0;
        this.y = y || 0;
        this.radius = radius || 0;
        this.type = CONST.SHAPES.CIRC;
      }
      Circle.prototype.constructor = Circle;
      module.exports = Circle;
      Circle.prototype.clone = function() {
        return new Circle(this.x, this.y, this.radius);
      };
      Circle.prototype.contains = function(x, y) {
        if (this.radius <= 0) {
          return false;
        }
        var dx = (this.x - x),
            dy = (this.y - y),
            r2 = this.radius * this.radius;
        dx *= dx;
        dy *= dy;
        return (dx + dy <= r2);
      };
      Circle.prototype.getBounds = function() {
        return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
      };
    }, {
      "../../const": 22,
      "./Rectangle": 36
    }],
    34: [function(require, module, exports) {
      var Rectangle = require('./Rectangle'),
          CONST = require('../../const');
      function Ellipse(x, y, width, height) {
        this.x = x || 0;
        this.y = y || 0;
        this.width = width || 0;
        this.height = height || 0;
        this.type = CONST.SHAPES.ELIP;
      }
      Ellipse.prototype.constructor = Ellipse;
      module.exports = Ellipse;
      Ellipse.prototype.clone = function() {
        return new Ellipse(this.x, this.y, this.width, this.height);
      };
      Ellipse.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        var normx = ((x - this.x) / this.width),
            normy = ((y - this.y) / this.height);
        normx *= normx;
        normy *= normy;
        return (normx + normy <= 1);
      };
      Ellipse.prototype.getBounds = function() {
        return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
      };
    }, {
      "../../const": 22,
      "./Rectangle": 36
    }],
    35: [function(require, module, exports) {
      var Point = require('../Point'),
          CONST = require('../../const');
      function Polygon(points_) {
        var points = points_;
        if (!Array.isArray(points)) {
          points = new Array(arguments.length);
          for (var a = 0; a < points.length; ++a) {
            points[a] = arguments[a];
          }
        }
        if (points[0] instanceof Point) {
          var p = [];
          for (var i = 0,
              il = points.length; i < il; i++) {
            p.push(points[i].x, points[i].y);
          }
          points = p;
        }
        this.closed = true;
        this.points = points;
        this.type = CONST.SHAPES.POLY;
      }
      Polygon.prototype.constructor = Polygon;
      module.exports = Polygon;
      Polygon.prototype.clone = function() {
        return new Polygon(this.points.slice());
      };
      Polygon.prototype.contains = function(x, y) {
        var inside = false;
        var length = this.points.length / 2;
        for (var i = 0,
            j = length - 1; i < length; j = i++) {
          var xi = this.points[i * 2],
              yi = this.points[i * 2 + 1],
              xj = this.points[j * 2],
              yj = this.points[j * 2 + 1],
              intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      };
    }, {
      "../../const": 22,
      "../Point": 31
    }],
    36: [function(require, module, exports) {
      var CONST = require('../../const');
      function Rectangle(x, y, width, height) {
        this.x = x || 0;
        this.y = y || 0;
        this.width = width || 0;
        this.height = height || 0;
        this.type = CONST.SHAPES.RECT;
      }
      Rectangle.prototype.constructor = Rectangle;
      module.exports = Rectangle;
      Rectangle.EMPTY = new Rectangle(0, 0, 0, 0);
      Rectangle.prototype.clone = function() {
        return new Rectangle(this.x, this.y, this.width, this.height);
      };
      Rectangle.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x >= this.x && x < this.x + this.width) {
          if (y >= this.y && y < this.y + this.height) {
            return true;
          }
        }
        return false;
      };
    }, {"../../const": 22}],
    37: [function(require, module, exports) {
      var CONST = require('../../const');
      function RoundedRectangle(x, y, width, height, radius) {
        this.x = x || 0;
        this.y = y || 0;
        this.width = width || 0;
        this.height = height || 0;
        this.radius = radius || 20;
        this.type = CONST.SHAPES.RREC;
      }
      RoundedRectangle.prototype.constructor = RoundedRectangle;
      module.exports = RoundedRectangle;
      RoundedRectangle.prototype.clone = function() {
        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      };
      RoundedRectangle.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
          if (y >= this.y && y <= this.y + this.height) {
            return true;
          }
        }
        return false;
      };
    }, {"../../const": 22}],
    38: [function(require, module, exports) {
      var Container = require('../display/Container'),
          CONST = require('../const');
      function ParticleContainer(size, properties) {
        Container.call(this);
        this._properties = [false, true, false, false, false];
        this._size = size || 15000;
        this._buffers = null;
        this._updateStatic = false;
        this.interactiveChildren = false;
        this.blendMode = CONST.BLEND_MODES.NORMAL;
        this.roundPixels = true;
        this.setProperties(properties);
      }
      ParticleContainer.prototype = Object.create(Container.prototype);
      ParticleContainer.prototype.constructor = ParticleContainer;
      module.exports = ParticleContainer;
      ParticleContainer.prototype.setProperties = function(properties) {
        if (properties) {
          this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];
          this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
          this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
          this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
          this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];
        }
      };
      ParticleContainer.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform();
      };
      ParticleContainer.prototype.renderWebGL = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
          return;
        }
        renderer.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
      };
      ParticleContainer.prototype.addChildAt = function(child, index) {
        if (child === this) {
          return child;
        }
        if (index >= 0 && index <= this.children.length) {
          if (child.parent) {
            child.parent.removeChild(child);
          }
          child.parent = this;
          this.children.splice(index, 0, child);
          this._updateStatic = true;
          return child;
        } else {
          throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);
        }
      };
      ParticleContainer.prototype.removeChildAt = function(index) {
        var child = this.getChildAt(index);
        child.parent = null;
        this.children.splice(index, 1);
        this._updateStatic = true;
        return child;
      };
      ParticleContainer.prototype.renderCanvas = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
          return;
        }
        var context = renderer.context;
        var transform = this.worldTransform;
        var isRotated = true;
        var positionX = 0;
        var positionY = 0;
        var finalWidth = 0;
        var finalHeight = 0;
        context.globalAlpha = this.worldAlpha;
        this.displayObjectUpdateTransform();
        for (var i = 0; i < this.children.length; ++i) {
          var child = this.children[i];
          if (!child.visible) {
            continue;
          }
          var frame = child.texture.frame;
          context.globalAlpha = this.worldAlpha * child.alpha;
          if (child.rotation % (Math.PI * 2) === 0) {
            if (isRotated) {
              context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
              isRotated = false;
            }
            positionX = ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x + 0.5);
            positionY = ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y + 0.5);
            finalWidth = frame.width * child.scale.x;
            finalHeight = frame.height * child.scale.y;
          } else {
            if (!isRotated) {
              isRotated = true;
            }
            child.displayObjectUpdateTransform();
            var childTransform = child.worldTransform;
            if (renderer.roundPixels) {
              context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);
            } else {
              context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx, childTransform.ty);
            }
            positionX = ((child.anchor.x) * (-frame.width) + 0.5);
            positionY = ((child.anchor.y) * (-frame.height) + 0.5);
            finalWidth = frame.width;
            finalHeight = frame.height;
          }
          context.drawImage(child.texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, positionX, positionY, finalWidth, finalHeight);
        }
      };
      ParticleContainer.prototype.destroy = function() {
        Container.prototype.destroy.apply(this, arguments);
        if (this._buffers) {
          for (var i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();
          }
        }
        this._properties = null;
        this._buffers = null;
      };
    }, {
      "../const": 22,
      "../display/Container": 23
    }],
    39: [function(require, module, exports) {
      function ParticleBuffer(gl, properties, size) {
        this.gl = gl;
        this.vertSize = 2;
        this.vertByteSize = this.vertSize * 4;
        this.size = size;
        this.dynamicProperties = [];
        this.staticProperties = [];
        for (var i = 0; i < properties.length; i++) {
          var property = properties[i];
          if (property.dynamic) {
            this.dynamicProperties.push(property);
          } else {
            this.staticProperties.push(property);
          }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.initBuffers();
      }
      ParticleBuffer.prototype.constructor = ParticleBuffer;
      module.exports = ParticleBuffer;
      ParticleBuffer.prototype.initBuffers = function() {
        var gl = this.gl;
        var i;
        var property;
        var dynamicOffset = 0;
        this.dynamicStride = 0;
        for (i = 0; i < this.dynamicProperties.length; i++) {
          property = this.dynamicProperties[i];
          property.offset = dynamicOffset;
          dynamicOffset += property.size;
          this.dynamicStride += property.size;
        }
        this.dynamicData = new Float32Array(this.size * this.dynamicStride * 4);
        this.dynamicBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.dynamicData, gl.DYNAMIC_DRAW);
        var staticOffset = 0;
        this.staticStride = 0;
        for (i = 0; i < this.staticProperties.length; i++) {
          property = this.staticProperties[i];
          property.offset = staticOffset;
          staticOffset += property.size;
          this.staticStride += property.size;
        }
        this.staticData = new Float32Array(this.size * this.staticStride * 4);
        this.staticBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.staticData, gl.DYNAMIC_DRAW);
      };
      ParticleBuffer.prototype.uploadDynamic = function(children, startIndex, amount) {
        var gl = this.gl;
        for (var i = 0; i < this.dynamicProperties.length; i++) {
          var property = this.dynamicProperties[i];
          property.uploadFunction(children, startIndex, amount, this.dynamicData, this.dynamicStride, property.offset);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.dynamicData);
      };
      ParticleBuffer.prototype.uploadStatic = function(children, startIndex, amount) {
        var gl = this.gl;
        for (var i = 0; i < this.staticProperties.length; i++) {
          var property = this.staticProperties[i];
          property.uploadFunction(children, startIndex, amount, this.staticData, this.staticStride, property.offset);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.staticData);
      };
      ParticleBuffer.prototype.bind = function() {
        var gl = this.gl;
        var i,
            property;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
        for (i = 0; i < this.dynamicProperties.length; i++) {
          property = this.dynamicProperties[i];
          gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.dynamicStride * 4, property.offset * 4);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
        for (i = 0; i < this.staticProperties.length; i++) {
          property = this.staticProperties[i];
          gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.staticStride * 4, property.offset * 4);
        }
      };
      ParticleBuffer.prototype.destroy = function() {
        this.dynamicProperties = null;
        this.dynamicData = null;
        this.gl.deleteBuffer(this.dynamicBuffer);
        this.staticProperties = null;
        this.staticData = null;
        this.gl.deleteBuffer(this.staticBuffer);
      };
    }, {}],
    40: [function(require, module, exports) {
      var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
          WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
          ParticleShader = require('./ParticleShader'),
          ParticleBuffer = require('./ParticleBuffer'),
          math = require('../../math');
      function ParticleRenderer(renderer) {
        ObjectRenderer.call(this, renderer);
        this.size = 15000;
        var numIndices = this.size * 6;
        this.indices = new Uint16Array(numIndices);
        for (var i = 0,
            j = 0; i < numIndices; i += 6, j += 4) {
          this.indices[i + 0] = j + 0;
          this.indices[i + 1] = j + 1;
          this.indices[i + 2] = j + 2;
          this.indices[i + 3] = j + 0;
          this.indices[i + 4] = j + 2;
          this.indices[i + 5] = j + 3;
        }
        this.shader = null;
        this.indexBuffer = null;
        this.properties = null;
        this.tempMatrix = new math.Matrix();
      }
      ParticleRenderer.prototype = Object.create(ObjectRenderer.prototype);
      ParticleRenderer.prototype.constructor = ParticleRenderer;
      module.exports = ParticleRenderer;
      WebGLRenderer.registerPlugin('particle', ParticleRenderer);
      ParticleRenderer.prototype.onContextChange = function() {
        var gl = this.renderer.gl;
        this.shader = new ParticleShader(this.renderer.shaderManager);
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        this.properties = [{
          attribute: this.shader.attributes.aVertexPosition,
          dynamic: false,
          size: 2,
          uploadFunction: this.uploadVertices,
          offset: 0
        }, {
          attribute: this.shader.attributes.aPositionCoord,
          dynamic: true,
          size: 2,
          uploadFunction: this.uploadPosition,
          offset: 0
        }, {
          attribute: this.shader.attributes.aRotation,
          dynamic: false,
          size: 1,
          uploadFunction: this.uploadRotation,
          offset: 0
        }, {
          attribute: this.shader.attributes.aTextureCoord,
          dynamic: false,
          size: 2,
          uploadFunction: this.uploadUvs,
          offset: 0
        }, {
          attribute: this.shader.attributes.aColor,
          dynamic: false,
          size: 1,
          uploadFunction: this.uploadAlpha,
          offset: 0
        }];
      };
      ParticleRenderer.prototype.start = function() {
        var gl = this.renderer.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var shader = this.shader;
        this.renderer.shaderManager.setShader(shader);
      };
      ParticleRenderer.prototype.render = function(container) {
        var children = container.children,
            totalChildren = children.length,
            maxSize = container._size;
        if (totalChildren === 0) {
          return;
        } else if (totalChildren > maxSize) {
          totalChildren = maxSize;
        }
        if (!container._buffers) {
          container._buffers = this.generateBuffers(container);
        }
        this.renderer.blendModeManager.setBlendMode(container.blendMode);
        var gl = this.renderer.gl;
        var m = container.worldTransform.copy(this.tempMatrix);
        m.prepend(this.renderer.currentRenderTarget.projectionMatrix);
        gl.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, false, m.toArray(true));
        gl.uniform1f(this.shader.uniforms.uAlpha._location, container.worldAlpha);
        var uploadStatic = container._updateStatic;
        var baseTexture = children[0]._texture.baseTexture;
        if (!baseTexture._glTextures[gl.id]) {
          if (!this.renderer.updateTexture(baseTexture)) {
            return;
          }
          if (!this.properties[0].dynamic || !this.properties[3].dynamic) {
            uploadStatic = true;
          }
        } else {
          gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);
        }
        var j = 0;
        for (var i = 0; i < totalChildren; i += this.size) {
          var amount = (totalChildren - i);
          if (amount > this.size) {
            amount = this.size;
          }
          var buffer = container._buffers[j++];
          buffer.uploadDynamic(children, i, amount);
          if (uploadStatic) {
            buffer.uploadStatic(children, i, amount);
          }
          buffer.bind(this.shader);
          gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
          this.renderer.drawCount++;
        }
        container._updateStatic = false;
      };
      ParticleRenderer.prototype.generateBuffers = function(container) {
        var gl = this.renderer.gl,
            buffers = [],
            size = container._size,
            i;
        for (i = 0; i < container._properties.length; i++) {
          this.properties[i].dynamic = container._properties[i];
        }
        for (i = 0; i < size; i += this.size) {
          buffers.push(new ParticleBuffer(gl, this.properties, this.size, this.shader));
        }
        return buffers;
      };
      ParticleRenderer.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset) {
        var sprite,
            texture,
            trim,
            sx,
            sy,
            w0,
            w1,
            h0,
            h1;
        for (var i = 0; i < amount; i++) {
          sprite = children[startIndex + i];
          texture = sprite._texture;
          sx = sprite.scale.x;
          sy = sprite.scale.y;
          if (texture.trim) {
            trim = texture.trim;
            w1 = trim.x - sprite.anchor.x * trim.width;
            w0 = w1 + texture.crop.width;
            h1 = trim.y - sprite.anchor.y * trim.height;
            h0 = h1 + texture.crop.height;
          } else {
            w0 = (texture._frame.width) * (1 - sprite.anchor.x);
            w1 = (texture._frame.width) * -sprite.anchor.x;
            h0 = texture._frame.height * (1 - sprite.anchor.y);
            h1 = texture._frame.height * -sprite.anchor.y;
          }
          array[offset] = w1 * sx;
          array[offset + 1] = h1 * sy;
          array[offset + stride] = w0 * sx;
          array[offset + stride + 1] = h1 * sy;
          array[offset + stride * 2] = w0 * sx;
          array[offset + stride * 2 + 1] = h0 * sy;
          array[offset + stride * 3] = w1 * sx;
          array[offset + stride * 3 + 1] = h0 * sy;
          offset += stride * 4;
        }
      };
      ParticleRenderer.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
          var spritePosition = children[startIndex + i].position;
          array[offset] = spritePosition.x;
          array[offset + 1] = spritePosition.y;
          array[offset + stride] = spritePosition.x;
          array[offset + stride + 1] = spritePosition.y;
          array[offset + stride * 2] = spritePosition.x;
          array[offset + stride * 2 + 1] = spritePosition.y;
          array[offset + stride * 3] = spritePosition.x;
          array[offset + stride * 3 + 1] = spritePosition.y;
          offset += stride * 4;
        }
      };
      ParticleRenderer.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
          var spriteRotation = children[startIndex + i].rotation;
          array[offset] = spriteRotation;
          array[offset + stride] = spriteRotation;
          array[offset + stride * 2] = spriteRotation;
          array[offset + stride * 3] = spriteRotation;
          offset += stride * 4;
        }
      };
      ParticleRenderer.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
          var textureUvs = children[startIndex + i]._texture._uvs;
          if (textureUvs) {
            array[offset] = textureUvs.x0;
            array[offset + 1] = textureUvs.y0;
            array[offset + stride] = textureUvs.x1;
            array[offset + stride + 1] = textureUvs.y1;
            array[offset + stride * 2] = textureUvs.x2;
            array[offset + stride * 2 + 1] = textureUvs.y2;
            array[offset + stride * 3] = textureUvs.x3;
            array[offset + stride * 3 + 1] = textureUvs.y3;
            offset += stride * 4;
          } else {
            array[offset] = 0;
            array[offset + 1] = 0;
            array[offset + stride] = 0;
            array[offset + stride + 1] = 0;
            array[offset + stride * 2] = 0;
            array[offset + stride * 2 + 1] = 0;
            array[offset + stride * 3] = 0;
            array[offset + stride * 3 + 1] = 0;
            offset += stride * 4;
          }
        }
      };
      ParticleRenderer.prototype.uploadAlpha = function(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
          var spriteAlpha = children[startIndex + i].alpha;
          array[offset] = spriteAlpha;
          array[offset + stride] = spriteAlpha;
          array[offset + stride * 2] = spriteAlpha;
          array[offset + stride * 3] = spriteAlpha;
          offset += stride * 4;
        }
      };
      ParticleRenderer.prototype.destroy = function() {
        if (this.renderer.gl) {
          this.renderer.gl.deleteBuffer(this.indexBuffer);
        }
        ObjectRenderer.prototype.destroy.apply(this, arguments);
        this.shader.destroy();
        this.indices = null;
        this.tempMatrix = null;
      };
    }, {
      "../../math": 32,
      "../../renderers/webgl/WebGLRenderer": 48,
      "../../renderers/webgl/utils/ObjectRenderer": 62,
      "./ParticleBuffer": 39,
      "./ParticleShader": 41
    }],
    41: [function(require, module, exports) {
      var TextureShader = require('../../renderers/webgl/shaders/TextureShader');
      function ParticleShader(shaderManager) {
        TextureShader.call(this, shaderManager, ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'attribute float aColor;', 'attribute vec2 aPositionCoord;', 'attribute vec2 aScale;', 'attribute float aRotation;', 'uniform mat3 projectionMatrix;', 'varying vec2 vTextureCoord;', 'varying float vColor;', 'void main(void){', '   vec2 v = aVertexPosition;', '   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);', '   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);', '   v = v + aPositionCoord;', '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '   vColor = aColor;', '}'].join('\n'), ['precision lowp float;', 'varying vec2 vTextureCoord;', 'varying float vColor;', 'uniform sampler2D uSampler;', 'uniform float uAlpha;', 'void main(void){', '  vec4 color = texture2D(uSampler, vTextureCoord) * vColor * uAlpha;', '  if (color.a == 0.0) discard;', '  gl_FragColor = color;', '}'].join('\n'), {uAlpha: {
            type: '1f',
            value: 1
          }}, {
          aPositionCoord: 0,
          aRotation: 0
        });
      }
      ParticleShader.prototype = Object.create(TextureShader.prototype);
      ParticleShader.prototype.constructor = ParticleShader;
      module.exports = ParticleShader;
    }, {"../../renderers/webgl/shaders/TextureShader": 61}],
    42: [function(require, module, exports) {
      var utils = require('../utils'),
          math = require('../math'),
          CONST = require('../const'),
          EventEmitter = require('eventemitter3');
      function SystemRenderer(system, width, height, options) {
        EventEmitter.call(this);
        utils.sayHello(system);
        if (options) {
          for (var i in CONST.DEFAULT_RENDER_OPTIONS) {
            if (typeof options[i] === 'undefined') {
              options[i] = CONST.DEFAULT_RENDER_OPTIONS[i];
            }
          }
        } else {
          options = CONST.DEFAULT_RENDER_OPTIONS;
        }
        this.type = CONST.RENDERER_TYPE.UNKNOWN;
        this.width = width || 800;
        this.height = height || 600;
        this.view = options.view || document.createElement('canvas');
        this.resolution = options.resolution;
        this.transparent = options.transparent;
        this.autoResize = options.autoResize || false;
        this.blendModes = null;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.clearBeforeRender = options.clearBeforeRender;
        this._backgroundColor = 0x000000;
        this._backgroundColorRgb = [0, 0, 0];
        this._backgroundColorString = '#000000';
        this.backgroundColor = options.backgroundColor || this._backgroundColor;
        this._tempDisplayObjectParent = {
          worldTransform: new math.Matrix(),
          worldAlpha: 1,
          children: []
        };
        this._lastObjectRendered = this._tempDisplayObjectParent;
      }
      SystemRenderer.prototype = Object.create(EventEmitter.prototype);
      SystemRenderer.prototype.constructor = SystemRenderer;
      module.exports = SystemRenderer;
      Object.defineProperties(SystemRenderer.prototype, {backgroundColor: {
          get: function() {
            return this._backgroundColor;
          },
          set: function(val) {
            this._backgroundColor = val;
            this._backgroundColorString = utils.hex2string(val);
            utils.hex2rgb(val, this._backgroundColorRgb);
          }
        }});
      SystemRenderer.prototype.resize = function(width, height) {
        this.width = width * this.resolution;
        this.height = height * this.resolution;
        this.view.width = this.width;
        this.view.height = this.height;
        if (this.autoResize) {
          this.view.style.width = this.width / this.resolution + 'px';
          this.view.style.height = this.height / this.resolution + 'px';
        }
      };
      SystemRenderer.prototype.destroy = function(removeView) {
        if (removeView && this.view.parent) {
          this.view.parent.removeChild(this.view);
        }
        this.type = CONST.RENDERER_TYPE.UNKNOWN;
        this.width = 0;
        this.height = 0;
        this.view = null;
        this.resolution = 0;
        this.transparent = false;
        this.autoResize = false;
        this.blendModes = null;
        this.preserveDrawingBuffer = false;
        this.clearBeforeRender = false;
        this._backgroundColor = 0;
        this._backgroundColorRgb = null;
        this._backgroundColorString = null;
      };
    }, {
      "../const": 22,
      "../math": 32,
      "../utils": 76,
      eventemitter3: 11
    }],
    43: [function(require, module, exports) {
      var SystemRenderer = require('../SystemRenderer'),
          CanvasMaskManager = require('./utils/CanvasMaskManager'),
          utils = require('../../utils'),
          math = require('../../math'),
          CONST = require('../../const');
      function CanvasRenderer(width, height, options) {
        SystemRenderer.call(this, 'Canvas', width, height, options);
        this.type = CONST.RENDERER_TYPE.CANVAS;
        this.context = this.view.getContext('2d', {alpha: this.transparent});
        this.refresh = true;
        this.maskManager = new CanvasMaskManager();
        this.roundPixels = false;
        this.currentScaleMode = CONST.SCALE_MODES.DEFAULT;
        this.currentBlendMode = CONST.BLEND_MODES.NORMAL;
        this.smoothProperty = 'imageSmoothingEnabled';
        if (!this.context.imageSmoothingEnabled) {
          if (this.context.webkitImageSmoothingEnabled) {
            this.smoothProperty = 'webkitImageSmoothingEnabled';
          } else if (this.context.mozImageSmoothingEnabled) {
            this.smoothProperty = 'mozImageSmoothingEnabled';
          } else if (this.context.oImageSmoothingEnabled) {
            this.smoothProperty = 'oImageSmoothingEnabled';
          } else if (this.context.msImageSmoothingEnabled) {
            this.smoothProperty = 'msImageSmoothingEnabled';
          }
        }
        this.initPlugins();
        this._mapBlendModes();
        this._tempDisplayObjectParent = {
          worldTransform: new math.Matrix(),
          worldAlpha: 1
        };
        this.resize(width, height);
      }
      CanvasRenderer.prototype = Object.create(SystemRenderer.prototype);
      CanvasRenderer.prototype.constructor = CanvasRenderer;
      module.exports = CanvasRenderer;
      utils.pluginTarget.mixin(CanvasRenderer);
      CanvasRenderer.prototype.render = function(object) {
        var cacheParent = object.parent;
        this._lastObjectRendered = object;
        object.parent = this._tempDisplayObjectParent;
        object.updateTransform();
        object.parent = cacheParent;
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.globalAlpha = 1;
        this.currentBlendMode = CONST.BLEND_MODES.NORMAL;
        this.context.globalCompositeOperation = this.blendModes[CONST.BLEND_MODES.NORMAL];
        if (navigator.isCocoonJS && this.view.screencanvas) {
          this.context.fillStyle = 'black';
          this.context.clear();
        }
        if (this.clearBeforeRender) {
          if (this.transparent) {
            this.context.clearRect(0, 0, this.width, this.height);
          } else {
            this.context.fillStyle = this._backgroundColorString;
            this.context.fillRect(0, 0, this.width, this.height);
          }
        }
        this.renderDisplayObject(object, this.context);
      };
      CanvasRenderer.prototype.destroy = function(removeView) {
        this.destroyPlugins();
        SystemRenderer.prototype.destroy.call(this, removeView);
        this.context = null;
        this.refresh = true;
        this.maskManager.destroy();
        this.maskManager = null;
        this.roundPixels = false;
        this.currentScaleMode = 0;
        this.currentBlendMode = 0;
        this.smoothProperty = null;
      };
      CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context) {
        var tempContext = this.context;
        this.context = context;
        displayObject.renderCanvas(this);
        this.context = tempContext;
      };
      CanvasRenderer.prototype.resize = function(w, h) {
        SystemRenderer.prototype.resize.call(this, w, h);
        this.currentScaleMode = CONST.SCALE_MODES.DEFAULT;
        if (this.smoothProperty) {
          this.context[this.smoothProperty] = (this.currentScaleMode === CONST.SCALE_MODES.LINEAR);
        }
      };
      CanvasRenderer.prototype._mapBlendModes = function() {
        if (!this.blendModes) {
          this.blendModes = {};
          if (utils.canUseNewCanvasBlendModes()) {
            this.blendModes[CONST.BLEND_MODES.NORMAL] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.ADD] = 'lighter';
            this.blendModes[CONST.BLEND_MODES.MULTIPLY] = 'multiply';
            this.blendModes[CONST.BLEND_MODES.SCREEN] = 'screen';
            this.blendModes[CONST.BLEND_MODES.OVERLAY] = 'overlay';
            this.blendModes[CONST.BLEND_MODES.DARKEN] = 'darken';
            this.blendModes[CONST.BLEND_MODES.LIGHTEN] = 'lighten';
            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE] = 'color-dodge';
            this.blendModes[CONST.BLEND_MODES.COLOR_BURN] = 'color-burn';
            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT] = 'hard-light';
            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT] = 'soft-light';
            this.blendModes[CONST.BLEND_MODES.DIFFERENCE] = 'difference';
            this.blendModes[CONST.BLEND_MODES.EXCLUSION] = 'exclusion';
            this.blendModes[CONST.BLEND_MODES.HUE] = 'hue';
            this.blendModes[CONST.BLEND_MODES.SATURATION] = 'saturate';
            this.blendModes[CONST.BLEND_MODES.COLOR] = 'color';
            this.blendModes[CONST.BLEND_MODES.LUMINOSITY] = 'luminosity';
          } else {
            this.blendModes[CONST.BLEND_MODES.NORMAL] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.ADD] = 'lighter';
            this.blendModes[CONST.BLEND_MODES.MULTIPLY] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SCREEN] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.OVERLAY] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.DARKEN] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.LIGHTEN] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR_BURN] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.DIFFERENCE] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.EXCLUSION] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.HUE] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SATURATION] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR] = 'source-over';
            this.blendModes[CONST.BLEND_MODES.LUMINOSITY] = 'source-over';
          }
        }
      };
    }, {
      "../../const": 22,
      "../../math": 32,
      "../../utils": 76,
      "../SystemRenderer": 42,
      "./utils/CanvasMaskManager": 46
    }],
    44: [function(require, module, exports) {
      function CanvasBuffer(width, height) {
        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');
        this.canvas.width = width;
        this.canvas.height = height;
      }
      CanvasBuffer.prototype.constructor = CanvasBuffer;
      module.exports = CanvasBuffer;
      Object.defineProperties(CanvasBuffer.prototype, {
        width: {
          get: function() {
            return this.canvas.width;
          },
          set: function(val) {
            this.canvas.width = val;
          }
        },
        height: {
          get: function() {
            return this.canvas.height;
          },
          set: function(val) {
            this.canvas.height = val;
          }
        }
      });
      CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
      CanvasBuffer.prototype.resize = function(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
      };
      CanvasBuffer.prototype.destroy = function() {
        this.context = null;
        this.canvas = null;
      };
    }, {}],
    45: [function(require, module, exports) {
      var CONST = require('../../../const');
      var CanvasGraphics = {};
      module.exports = CanvasGraphics;
      CanvasGraphics.renderGraphics = function(graphics, context) {
        var worldAlpha = graphics.worldAlpha;
        if (graphics.dirty) {
          this.updateGraphicsTint(graphics);
          graphics.dirty = false;
        }
        for (var i = 0; i < graphics.graphicsData.length; i++) {
          var data = graphics.graphicsData[i];
          var shape = data.shape;
          var fillColor = data._fillTint;
          var lineColor = data._lineTint;
          context.lineWidth = data.lineWidth;
          if (data.type === CONST.SHAPES.POLY) {
            context.beginPath();
            var points = shape.points;
            context.moveTo(points[0], points[1]);
            for (var j = 1; j < points.length / 2; j++) {
              context.lineTo(points[j * 2], points[j * 2 + 1]);
            }
            if (shape.closed) {
              context.lineTo(points[0], points[1]);
            }
            if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
              context.closePath();
            }
            if (data.fill) {
              context.globalAlpha = data.fillAlpha * worldAlpha;
              context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
              context.fill();
            }
            if (data.lineWidth) {
              context.globalAlpha = data.lineAlpha * worldAlpha;
              context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
              context.stroke();
            }
          } else if (data.type === CONST.SHAPES.RECT) {
            if (data.fillColor || data.fillColor === 0) {
              context.globalAlpha = data.fillAlpha * worldAlpha;
              context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
              context.fillRect(shape.x, shape.y, shape.width, shape.height);
            }
            if (data.lineWidth) {
              context.globalAlpha = data.lineAlpha * worldAlpha;
              context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
              context.strokeRect(shape.x, shape.y, shape.width, shape.height);
            }
          } else if (data.type === CONST.SHAPES.CIRC) {
            context.beginPath();
            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
            context.closePath();
            if (data.fill) {
              context.globalAlpha = data.fillAlpha * worldAlpha;
              context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
              context.fill();
            }
            if (data.lineWidth) {
              context.globalAlpha = data.lineAlpha * worldAlpha;
              context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
              context.stroke();
            }
          } else if (data.type === CONST.SHAPES.ELIP) {
            var w = shape.width * 2;
            var h = shape.height * 2;
            var x = shape.x - w / 2;
            var y = shape.y - h / 2;
            context.beginPath();
            var kappa = 0.5522848,
                ox = (w / 2) * kappa,
                oy = (h / 2) * kappa,
                xe = x + w,
                ye = y + h,
                xm = x + w / 2,
                ym = y + h / 2;
            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
            if (data.fill) {
              context.globalAlpha = data.fillAlpha * worldAlpha;
              context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
              context.fill();
            }
            if (data.lineWidth) {
              context.globalAlpha = data.lineAlpha * worldAlpha;
              context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
              context.stroke();
            }
          } else if (data.type === CONST.SHAPES.RREC) {
            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;
            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;
            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();
            if (data.fillColor || data.fillColor === 0) {
              context.globalAlpha = data.fillAlpha * worldAlpha;
              context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
              context.fill();
            }
            if (data.lineWidth) {
              context.globalAlpha = data.lineAlpha * worldAlpha;
              context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
              context.stroke();
            }
          }
        }
      };
      CanvasGraphics.renderGraphicsMask = function(graphics, context) {
        var len = graphics.graphicsData.length;
        if (len === 0) {
          return;
        }
        context.beginPath();
        for (var i = 0; i < len; i++) {
          var data = graphics.graphicsData[i];
          var shape = data.shape;
          if (data.type === CONST.SHAPES.POLY) {
            var points = shape.points;
            context.moveTo(points[0], points[1]);
            for (var j = 1; j < points.length / 2; j++) {
              context.lineTo(points[j * 2], points[j * 2 + 1]);
            }
            if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
              context.closePath();
            }
          } else if (data.type === CONST.SHAPES.RECT) {
            context.rect(shape.x, shape.y, shape.width, shape.height);
            context.closePath();
          } else if (data.type === CONST.SHAPES.CIRC) {
            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
            context.closePath();
          } else if (data.type === CONST.SHAPES.ELIP) {
            var w = shape.width * 2;
            var h = shape.height * 2;
            var x = shape.x - w / 2;
            var y = shape.y - h / 2;
            var kappa = 0.5522848,
                ox = (w / 2) * kappa,
                oy = (h / 2) * kappa,
                xe = x + w,
                ye = y + h,
                xm = x + w / 2,
                ym = y + h / 2;
            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
          } else if (data.type === CONST.SHAPES.RREC) {
            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;
            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();
          }
        }
      };
      CanvasGraphics.updateGraphicsTint = function(graphics) {
        if (graphics.tint === 0xFFFFFF) {
          return;
        }
        var tintR = (graphics.tint >> 16 & 0xFF) / 255;
        var tintG = (graphics.tint >> 8 & 0xFF) / 255;
        var tintB = (graphics.tint & 0xFF) / 255;
        for (var i = 0; i < graphics.graphicsData.length; i++) {
          var data = graphics.graphicsData[i];
          var fillColor = data.fillColor | 0;
          var lineColor = data.lineColor | 0;
          data._fillTint = (((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255);
          data._lineTint = (((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255);
        }
      };
    }, {"../../../const": 22}],
    46: [function(require, module, exports) {
      var CanvasGraphics = require('./CanvasGraphics');
      function CanvasMaskManager() {}
      CanvasMaskManager.prototype.constructor = CanvasMaskManager;
      module.exports = CanvasMaskManager;
      CanvasMaskManager.prototype.pushMask = function(maskData, renderer) {
        renderer.context.save();
        var cacheAlpha = maskData.alpha;
        var transform = maskData.worldTransform;
        var resolution = renderer.resolution;
        renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
        if (!maskData.texture) {
          CanvasGraphics.renderGraphicsMask(maskData, renderer.context);
          renderer.context.clip();
        }
        maskData.worldAlpha = cacheAlpha;
      };
      CanvasMaskManager.prototype.popMask = function(renderer) {
        renderer.context.restore();
      };
      CanvasMaskManager.prototype.destroy = function() {};
    }, {"./CanvasGraphics": 45}],
    47: [function(require, module, exports) {
      var utils = require('../../../utils');
      var CanvasTinter = {};
      module.exports = CanvasTinter;
      CanvasTinter.getTintedTexture = function(sprite, color) {
        var texture = sprite.texture;
        color = CanvasTinter.roundColor(color);
        var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
        texture.tintCache = texture.tintCache || {};
        if (texture.tintCache[stringColor]) {
          return texture.tintCache[stringColor];
        }
        var canvas = CanvasTinter.canvas || document.createElement('canvas');
        CanvasTinter.tintMethod(texture, color, canvas);
        if (CanvasTinter.convertTintToImage) {
          var tintImage = new Image();
          tintImage.src = canvas.toDataURL();
          texture.tintCache[stringColor] = tintImage;
        } else {
          texture.tintCache[stringColor] = canvas;
          CanvasTinter.canvas = null;
        }
        return canvas;
      };
      CanvasTinter.tintWithMultiply = function(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture.crop;
        canvas.width = crop.width;
        canvas.height = crop.height;
        context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, crop.width, crop.height);
        context.globalCompositeOperation = 'multiply';
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
        context.globalCompositeOperation = 'destination-atop';
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
      };
      CanvasTinter.tintWithOverlay = function(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture.crop;
        canvas.width = crop.width;
        canvas.height = crop.height;
        context.globalCompositeOperation = 'copy';
        context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, crop.width, crop.height);
        context.globalCompositeOperation = 'destination-atop';
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
      };
      CanvasTinter.tintWithPerPixel = function(texture, color, canvas) {
        var context = canvas.getContext('2d');
        var crop = texture.crop;
        canvas.width = crop.width;
        canvas.height = crop.height;
        context.globalCompositeOperation = 'copy';
        context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
        var rgbValues = utils.hex2rgb(color);
        var r = rgbValues[0],
            g = rgbValues[1],
            b = rgbValues[2];
        var pixelData = context.getImageData(0, 0, crop.width, crop.height);
        var pixels = pixelData.data;
        for (var i = 0; i < pixels.length; i += 4) {
          pixels[i + 0] *= r;
          pixels[i + 1] *= g;
          pixels[i + 2] *= b;
        }
        context.putImageData(pixelData, 0, 0);
      };
      CanvasTinter.roundColor = function(color) {
        var step = CanvasTinter.cacheStepsPerColorChannel;
        var rgbValues = utils.hex2rgb(color);
        rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
        rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
        rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);
        return utils.rgb2hex(rgbValues);
      };
      CanvasTinter.cacheStepsPerColorChannel = 8;
      CanvasTinter.convertTintToImage = false;
      CanvasTinter.canUseMultiply = utils.canUseNewCanvasBlendModes();
      CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;
    }, {"../../../utils": 76}],
    48: [function(require, module, exports) {
      var SystemRenderer = require('../SystemRenderer'),
          ShaderManager = require('./managers/ShaderManager'),
          MaskManager = require('./managers/MaskManager'),
          StencilManager = require('./managers/StencilManager'),
          FilterManager = require('./managers/FilterManager'),
          BlendModeManager = require('./managers/BlendModeManager'),
          RenderTarget = require('./utils/RenderTarget'),
          ObjectRenderer = require('./utils/ObjectRenderer'),
          FXAAFilter = require('./filters/FXAAFilter'),
          utils = require('../../utils'),
          CONST = require('../../const');
      function WebGLRenderer(width, height, options) {
        options = options || {};
        SystemRenderer.call(this, 'WebGL', width, height, options);
        this.type = CONST.RENDERER_TYPE.WEBGL;
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        this.view.addEventListener('webglcontextlost', this.handleContextLost, false);
        this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);
        this._useFXAA = !!options.forceFXAA && options.antialias;
        this._FXAAFilter = null;
        this._contextOptions = {
          alpha: this.transparent,
          antialias: options.antialias,
          premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer
        };
        this.drawCount = 0;
        this.shaderManager = new ShaderManager(this);
        this.maskManager = new MaskManager(this);
        this.stencilManager = new StencilManager(this);
        this.filterManager = new FilterManager(this);
        this.blendModeManager = new BlendModeManager(this);
        this.currentRenderTarget = null;
        this.currentRenderer = new ObjectRenderer(this);
        this.initPlugins();
        this._createContext();
        this._initContext();
        this._mapGlModes();
        this._renderTargetStack = [];
      }
      WebGLRenderer.prototype = Object.create(SystemRenderer.prototype);
      WebGLRenderer.prototype.constructor = WebGLRenderer;
      module.exports = WebGLRenderer;
      utils.pluginTarget.mixin(WebGLRenderer);
      WebGLRenderer.glContextId = 0;
      WebGLRenderer.prototype._createContext = function() {
        var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);
        this.gl = gl;
        if (!gl) {
          throw new Error('This browser does not support webGL. Try using the canvas renderer');
        }
        this.glContextId = WebGLRenderer.glContextId++;
        gl.id = this.glContextId;
        gl.renderer = this;
      };
      WebGLRenderer.prototype._initContext = function() {
        var gl = this.gl;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        this.renderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);
        this.setRenderTarget(this.renderTarget);
        this.emit('context', gl);
        this.resize(this.width, this.height);
        if (!this._useFXAA) {
          this._useFXAA = (this._contextOptions.antialias && !gl.getContextAttributes().antialias);
        }
        if (this._useFXAA) {
          window.console.warn('FXAA antialiasing being used instead of native antialiasing');
          this._FXAAFilter = [new FXAAFilter()];
        }
      };
      WebGLRenderer.prototype.render = function(object) {
        if (this.gl.isContextLost()) {
          return;
        }
        this.drawCount = 0;
        this._lastObjectRendered = object;
        if (this._useFXAA) {
          this._FXAAFilter[0].uniforms.resolution.value.x = this.width;
          this._FXAAFilter[0].uniforms.resolution.value.y = this.height;
          object.filterArea = this.renderTarget.size;
          object.filters = this._FXAAFilter;
        }
        var cacheParent = object.parent;
        object.parent = this._tempDisplayObjectParent;
        object.updateTransform();
        object.parent = cacheParent;
        var gl = this.gl;
        this.setRenderTarget(this.renderTarget);
        if (this.clearBeforeRender) {
          if (this.transparent) {
            gl.clearColor(0, 0, 0, 0);
          } else {
            gl.clearColor(this._backgroundColorRgb[0], this._backgroundColorRgb[1], this._backgroundColorRgb[2], 1);
          }
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
        this.renderDisplayObject(object, this.renderTarget);
      };
      WebGLRenderer.prototype.renderDisplayObject = function(displayObject, renderTarget, clear) {
        this.setRenderTarget(renderTarget);
        if (clear) {
          renderTarget.clear();
        }
        this.filterManager.setFilterStack(renderTarget.filterStack);
        displayObject.renderWebGL(this);
        this.currentRenderer.flush();
      };
      WebGLRenderer.prototype.setObjectRenderer = function(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
          return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
      };
      WebGLRenderer.prototype.setRenderTarget = function(renderTarget) {
        if (this.currentRenderTarget === renderTarget) {
          return;
        }
        this.currentRenderTarget = renderTarget;
        this.currentRenderTarget.activate();
        this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);
      };
      WebGLRenderer.prototype.resize = function(width, height) {
        SystemRenderer.prototype.resize.call(this, width, height);
        this.filterManager.resize(width, height);
        this.renderTarget.resize(width, height);
        if (this.currentRenderTarget === this.renderTarget) {
          this.renderTarget.activate();
          this.gl.viewport(0, 0, this.width, this.height);
        }
      };
      WebGLRenderer.prototype.updateTexture = function(texture) {
        texture = texture.baseTexture || texture;
        if (!texture.hasLoaded) {
          return;
        }
        var gl = this.gl;
        if (!texture._glTextures[gl.id]) {
          texture._glTextures[gl.id] = gl.createTexture();
          texture.on('update', this.updateTexture, this);
          texture.on('dispose', this.destroyTexture, this);
        }
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        if (texture.mipmap && texture.isPowerOfTwo) {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
          gl.generateMipmap(gl.TEXTURE_2D);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        }
        if (!texture.isPowerOfTwo) {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }
        return texture._glTextures[gl.id];
      };
      WebGLRenderer.prototype.destroyTexture = function(texture) {
        texture = texture.baseTexture || texture;
        if (!texture.hasLoaded) {
          return;
        }
        if (texture._glTextures[this.gl.id]) {
          this.gl.deleteTexture(texture._glTextures[this.gl.id]);
        }
      };
      WebGLRenderer.prototype.handleContextLost = function(event) {
        event.preventDefault();
      };
      WebGLRenderer.prototype.handleContextRestored = function() {
        this._initContext();
        for (var key in utils.BaseTextureCache) {
          utils.BaseTextureCache[key]._glTextures.length = 0;
        }
      };
      WebGLRenderer.prototype.destroy = function(removeView) {
        this.destroyPlugins();
        this.view.removeEventListener('webglcontextlost', this.handleContextLost);
        this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);
        SystemRenderer.prototype.destroy.call(this, removeView);
        this.uid = 0;
        this.shaderManager.destroy();
        this.maskManager.destroy();
        this.stencilManager.destroy();
        this.filterManager.destroy();
        this.shaderManager = null;
        this.maskManager = null;
        this.filterManager = null;
        this.blendModeManager = null;
        this.handleContextLost = null;
        this.handleContextRestored = null;
        this._contextOptions = null;
        this.drawCount = 0;
        this.gl = null;
      };
      WebGLRenderer.prototype._mapGlModes = function() {
        var gl = this.gl;
        if (!this.blendModes) {
          this.blendModes = {};
          this.blendModes[CONST.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.ADD] = [gl.SRC_ALPHA, gl.DST_ALPHA];
          this.blendModes[CONST.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.SCREEN] = [gl.SRC_ALPHA, gl.ONE];
          this.blendModes[CONST.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
          this.blendModes[CONST.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        }
        if (!this.drawModes) {
          this.drawModes = {};
          this.drawModes[CONST.DRAW_MODES.POINTS] = gl.POINTS;
          this.drawModes[CONST.DRAW_MODES.LINES] = gl.LINES;
          this.drawModes[CONST.DRAW_MODES.LINE_LOOP] = gl.LINE_LOOP;
          this.drawModes[CONST.DRAW_MODES.LINE_STRIP] = gl.LINE_STRIP;
          this.drawModes[CONST.DRAW_MODES.TRIANGLES] = gl.TRIANGLES;
          this.drawModes[CONST.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
          this.drawModes[CONST.DRAW_MODES.TRIANGLE_FAN] = gl.TRIANGLE_FAN;
        }
      };
    }, {
      "../../const": 22,
      "../../utils": 76,
      "../SystemRenderer": 42,
      "./filters/FXAAFilter": 50,
      "./managers/BlendModeManager": 52,
      "./managers/FilterManager": 53,
      "./managers/MaskManager": 54,
      "./managers/ShaderManager": 55,
      "./managers/StencilManager": 56,
      "./utils/ObjectRenderer": 62,
      "./utils/RenderTarget": 64
    }],
    49: [function(require, module, exports) {
      var DefaultShader = require('../shaders/TextureShader');
      function AbstractFilter(vertexSrc, fragmentSrc, uniforms) {
        this.shaders = [];
        this.padding = 0;
        this.uniforms = uniforms || {};
        this.vertexSrc = vertexSrc || DefaultShader.defaultVertexSrc;
        this.fragmentSrc = fragmentSrc || DefaultShader.defaultFragmentSrc;
      }
      AbstractFilter.prototype.constructor = AbstractFilter;
      module.exports = AbstractFilter;
      AbstractFilter.prototype.getShader = function(renderer) {
        var gl = renderer.gl;
        var shader = this.shaders[gl.id];
        if (!shader) {
          shader = new DefaultShader(renderer.shaderManager, this.vertexSrc, this.fragmentSrc, this.uniforms, this.attributes);
          this.shaders[gl.id] = shader;
        }
        return shader;
      };
      AbstractFilter.prototype.applyFilter = function(renderer, input, output, clear) {
        var shader = this.getShader(renderer);
        renderer.filterManager.applyFilter(shader, input, output, clear);
      };
      AbstractFilter.prototype.syncUniform = function(uniform) {
        for (var i = 0,
            j = this.shaders.length; i < j; ++i) {
          this.shaders[i].syncUniform(uniform);
        }
      };
    }, {"../shaders/TextureShader": 61}],
    50: [function(require, module, exports) {
      var AbstractFilter = require('./AbstractFilter');
      function FXAAFilter() {
        AbstractFilter.call(this, "\nprecision mediump float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform vec2 resolution;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\n            out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n   vResolution = resolution;\n\n   //compute the texture coords and send them to varyings\n   texcoords(aTextureCoord * resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", "precision lowp float;\n\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE,\n            vec2 v_rgbSW, vec2 v_rgbSE,\n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform sampler2D uSampler;\n\n\nvoid main(void){\n\n    gl_FragColor = fxaa(uSampler, vTextureCoord * vResolution, vResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n}\n", {resolution: {
            type: 'v2',
            value: {
              x: 1,
              y: 1
            }
          }});
      }
      FXAAFilter.prototype = Object.create(AbstractFilter.prototype);
      FXAAFilter.prototype.constructor = FXAAFilter;
      module.exports = FXAAFilter;
      FXAAFilter.prototype.applyFilter = function(renderer, input, output) {
        var filterManager = renderer.filterManager;
        var shader = this.getShader(renderer);
        filterManager.applyFilter(shader, input, output);
      };
    }, {"./AbstractFilter": 49}],
    51: [function(require, module, exports) {
      var AbstractFilter = require('./AbstractFilter'),
          math = require('../../../math');
      function SpriteMaskFilter(sprite) {
        var maskMatrix = new math.Matrix();
        AbstractFilter.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n", "precision lowp float;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    original *= (masky.r * masky.a * alpha * clip);\n    gl_FragColor = original;\n}\n", {
          mask: {
            type: 'sampler2D',
            value: sprite._texture
          },
          alpha: {
            type: 'f',
            value: 1
          },
          otherMatrix: {
            type: 'mat3',
            value: maskMatrix.toArray(true)
          }
        });
        this.maskSprite = sprite;
        this.maskMatrix = maskMatrix;
      }
      SpriteMaskFilter.prototype = Object.create(AbstractFilter.prototype);
      SpriteMaskFilter.prototype.constructor = SpriteMaskFilter;
      module.exports = SpriteMaskFilter;
      SpriteMaskFilter.prototype.applyFilter = function(renderer, input, output) {
        var filterManager = renderer.filterManager;
        this.uniforms.mask.value = this.maskSprite._texture;
        filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);
        this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
        this.uniforms.alpha.value = this.maskSprite.worldAlpha;
        var shader = this.getShader(renderer);
        filterManager.applyFilter(shader, input, output);
      };
      Object.defineProperties(SpriteMaskFilter.prototype, {
        map: {
          get: function() {
            return this.uniforms.mask.value;
          },
          set: function(value) {
            this.uniforms.mask.value = value;
          }
        },
        offset: {
          get: function() {
            return this.uniforms.offset.value;
          },
          set: function(value) {
            this.uniforms.offset.value = value;
          }
        }
      });
    }, {
      "../../../math": 32,
      "./AbstractFilter": 49
    }],
    52: [function(require, module, exports) {
      var WebGLManager = require('./WebGLManager');
      function BlendModeManager(renderer) {
        WebGLManager.call(this, renderer);
        this.currentBlendMode = 99999;
      }
      BlendModeManager.prototype = Object.create(WebGLManager.prototype);
      BlendModeManager.prototype.constructor = BlendModeManager;
      module.exports = BlendModeManager;
      BlendModeManager.prototype.setBlendMode = function(blendMode) {
        if (this.currentBlendMode === blendMode) {
          return false;
        }
        this.currentBlendMode = blendMode;
        var mode = this.renderer.blendModes[this.currentBlendMode];
        this.renderer.gl.blendFunc(mode[0], mode[1]);
        return true;
      };
    }, {"./WebGLManager": 57}],
    53: [function(require, module, exports) {
      var WebGLManager = require('./WebGLManager'),
          RenderTarget = require('../utils/RenderTarget'),
          CONST = require('../../../const'),
          Quad = require('../utils/Quad'),
          math = require('../../../math');
      function FilterManager(renderer) {
        WebGLManager.call(this, renderer);
        this.filterStack = [];
        this.filterStack.push({
          renderTarget: renderer.currentRenderTarget,
          filter: [],
          bounds: null
        });
        this.texturePool = [];
        this.textureSize = new math.Rectangle(0, 0, renderer.width, renderer.height);
        this.currentFrame = null;
      }
      FilterManager.prototype = Object.create(WebGLManager.prototype);
      FilterManager.prototype.constructor = FilterManager;
      module.exports = FilterManager;
      FilterManager.prototype.onContextChange = function() {
        this.texturePool.length = 0;
        var gl = this.renderer.gl;
        this.quad = new Quad(gl);
      };
      FilterManager.prototype.setFilterStack = function(filterStack) {
        this.filterStack = filterStack;
      };
      FilterManager.prototype.pushFilter = function(target, filters) {
        var bounds = target.filterArea ? target.filterArea.clone() : target.getBounds();
        bounds.x = bounds.x | 0;
        bounds.y = bounds.y | 0;
        bounds.width = bounds.width | 0;
        bounds.height = bounds.height | 0;
        var padding = filters[0].padding | 0;
        bounds.x -= padding;
        bounds.y -= padding;
        bounds.width += padding * 2;
        bounds.height += padding * 2;
        if (this.renderer.currentRenderTarget.transform) {
          var transform = this.renderer.currentRenderTarget.transform;
          bounds.x += transform.tx;
          bounds.y += transform.ty;
          this.capFilterArea(bounds);
          bounds.x -= transform.tx;
          bounds.y -= transform.ty;
        } else {
          this.capFilterArea(bounds);
        }
        if (bounds.width > 0 && bounds.height > 0) {
          this.currentFrame = bounds;
          var texture = this.getRenderTarget();
          this.renderer.setRenderTarget(texture);
          texture.clear();
          this.filterStack.push({
            renderTarget: texture,
            filter: filters
          });
        } else {
          this.filterStack.push({
            renderTarget: null,
            filter: filters
          });
        }
      };
      FilterManager.prototype.popFilter = function() {
        var filterData = this.filterStack.pop();
        var previousFilterData = this.filterStack[this.filterStack.length - 1];
        var input = filterData.renderTarget;
        if (!filterData.renderTarget) {
          return;
        }
        var output = previousFilterData.renderTarget;
        var gl = this.renderer.gl;
        this.currentFrame = input.frame;
        this.quad.map(this.textureSize, input.frame);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);
        var filters = filterData.filter;
        gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
        gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
        this.renderer.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);
        if (filters.length === 1) {
          if (filters[0].uniforms.dimensions) {
            filters[0].uniforms.dimensions.value[0] = this.renderer.width;
            filters[0].uniforms.dimensions.value[1] = this.renderer.height;
            filters[0].uniforms.dimensions.value[2] = this.quad.vertices[0];
            filters[0].uniforms.dimensions.value[3] = this.quad.vertices[5];
          }
          filters[0].applyFilter(this.renderer, input, output);
          this.returnRenderTarget(input);
        } else {
          var flipTexture = input;
          var flopTexture = this.getRenderTarget(true);
          for (var i = 0; i < filters.length - 1; i++) {
            var filter = filters[i];
            if (filter.uniforms.dimensions) {
              filter.uniforms.dimensions.value[0] = this.renderer.width;
              filter.uniforms.dimensions.value[1] = this.renderer.height;
              filter.uniforms.dimensions.value[2] = this.quad.vertices[0];
              filter.uniforms.dimensions.value[3] = this.quad.vertices[5];
            }
            filter.applyFilter(this.renderer, flipTexture, flopTexture);
            var temp = flipTexture;
            flipTexture = flopTexture;
            flopTexture = temp;
          }
          filters[filters.length - 1].applyFilter(this.renderer, flipTexture, output);
          this.returnRenderTarget(flipTexture);
          this.returnRenderTarget(flopTexture);
        }
        return filterData.filter;
      };
      FilterManager.prototype.getRenderTarget = function(clear) {
        var renderTarget = this.texturePool.pop() || new RenderTarget(this.renderer.gl, this.textureSize.width, this.textureSize.height, CONST.SCALE_MODES.LINEAR, this.renderer.resolution * CONST.FILTER_RESOLUTION);
        renderTarget.frame = this.currentFrame;
        if (clear) {
          renderTarget.clear(true);
        }
        return renderTarget;
      };
      FilterManager.prototype.returnRenderTarget = function(renderTarget) {
        this.texturePool.push(renderTarget);
      };
      FilterManager.prototype.applyFilter = function(shader, inputTarget, outputTarget, clear) {
        var gl = this.renderer.gl;
        this.renderer.setRenderTarget(outputTarget);
        if (clear) {
          outputTarget.clear();
        }
        this.renderer.shaderManager.setShader(shader);
        shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);
        shader.syncUniforms();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      };
      FilterManager.prototype.calculateMappedMatrix = function(filterArea, sprite, outputMatrix) {
        var worldTransform = sprite.worldTransform.copy(math.Matrix.TEMP_MATRIX),
            texture = sprite._texture.baseTexture;
        var mappedMatrix = outputMatrix.identity();
        var ratio = this.textureSize.height / this.textureSize.width;
        mappedMatrix.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);
        mappedMatrix.scale(1, ratio);
        var translateScaleX = (this.textureSize.width / texture.width);
        var translateScaleY = (this.textureSize.height / texture.height);
        worldTransform.tx /= texture.width * translateScaleX;
        worldTransform.ty /= texture.width * translateScaleX;
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1, 1 / ratio);
        mappedMatrix.scale(translateScaleX, translateScaleY);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      };
      FilterManager.prototype.capFilterArea = function(filterArea) {
        if (filterArea.x < 0) {
          filterArea.width += filterArea.x;
          filterArea.x = 0;
        }
        if (filterArea.y < 0) {
          filterArea.height += filterArea.y;
          filterArea.y = 0;
        }
        if (filterArea.x + filterArea.width > this.textureSize.width) {
          filterArea.width = this.textureSize.width - filterArea.x;
        }
        if (filterArea.y + filterArea.height > this.textureSize.height) {
          filterArea.height = this.textureSize.height - filterArea.y;
        }
      };
      FilterManager.prototype.resize = function(width, height) {
        this.textureSize.width = width;
        this.textureSize.height = height;
        for (var i = 0; i < this.texturePool.length; i++) {
          this.texturePool[i].resize(width, height);
        }
      };
      FilterManager.prototype.destroy = function() {
        this.filterStack = null;
        this.offsetY = 0;
        for (var i = 0; i < this.texturePool.length; i++) {
          this.texturePool[i].destroy();
        }
        this.texturePool = null;
      };
    }, {
      "../../../const": 22,
      "../../../math": 32,
      "../utils/Quad": 63,
      "../utils/RenderTarget": 64,
      "./WebGLManager": 57
    }],
    54: [function(require, module, exports) {
      var WebGLManager = require('./WebGLManager'),
          AlphaMaskFilter = require('../filters/SpriteMaskFilter');
      function MaskManager(renderer) {
        WebGLManager.call(this, renderer);
        this.stencilStack = [];
        this.reverse = true;
        this.count = 0;
        this.alphaMaskPool = [];
      }
      MaskManager.prototype = Object.create(WebGLManager.prototype);
      MaskManager.prototype.constructor = MaskManager;
      module.exports = MaskManager;
      MaskManager.prototype.pushMask = function(target, maskData) {
        if (maskData.texture) {
          this.pushSpriteMask(target, maskData);
        } else {
          this.pushStencilMask(target, maskData);
        }
      };
      MaskManager.prototype.popMask = function(target, maskData) {
        if (maskData.texture) {
          this.popSpriteMask(target, maskData);
        } else {
          this.popStencilMask(target, maskData);
        }
      };
      MaskManager.prototype.pushSpriteMask = function(target, maskData) {
        var alphaMaskFilter = this.alphaMaskPool.pop();
        if (!alphaMaskFilter) {
          alphaMaskFilter = [new AlphaMaskFilter(maskData)];
        }
        alphaMaskFilter[0].maskSprite = maskData;
        this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
      };
      MaskManager.prototype.popSpriteMask = function() {
        var filters = this.renderer.filterManager.popFilter();
        this.alphaMaskPool.push(filters);
      };
      MaskManager.prototype.pushStencilMask = function(target, maskData) {
        this.renderer.stencilManager.pushMask(maskData);
      };
      MaskManager.prototype.popStencilMask = function(target, maskData) {
        this.renderer.stencilManager.popMask(maskData);
      };
    }, {
      "../filters/SpriteMaskFilter": 51,
      "./WebGLManager": 57
    }],
    55: [function(require, module, exports) {
      var WebGLManager = require('./WebGLManager'),
          TextureShader = require('../shaders/TextureShader'),
          ComplexPrimitiveShader = require('../shaders/ComplexPrimitiveShader'),
          PrimitiveShader = require('../shaders/PrimitiveShader'),
          utils = require('../../../utils');
      function ShaderManager(renderer) {
        WebGLManager.call(this, renderer);
        this.maxAttibs = 10;
        this.attribState = [];
        this.tempAttribState = [];
        for (var i = 0; i < this.maxAttibs; i++) {
          this.attribState[i] = false;
        }
        this.stack = [];
        this._currentId = -1;
        this.currentShader = null;
      }
      ShaderManager.prototype = Object.create(WebGLManager.prototype);
      ShaderManager.prototype.constructor = ShaderManager;
      utils.pluginTarget.mixin(ShaderManager);
      module.exports = ShaderManager;
      ShaderManager.prototype.onContextChange = function() {
        this.initPlugins();
        var gl = this.renderer.gl;
        this.maxAttibs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this.attribState = [];
        for (var i = 0; i < this.maxAttibs; i++) {
          this.attribState[i] = false;
        }
        this.defaultShader = new TextureShader(this);
        this.primitiveShader = new PrimitiveShader(this);
        this.complexPrimitiveShader = new ComplexPrimitiveShader(this);
      };
      ShaderManager.prototype.setAttribs = function(attribs) {
        var i;
        for (i = 0; i < this.tempAttribState.length; i++) {
          this.tempAttribState[i] = false;
        }
        for (var a in attribs) {
          this.tempAttribState[attribs[a]] = true;
        }
        var gl = this.renderer.gl;
        for (i = 0; i < this.attribState.length; i++) {
          if (this.attribState[i] !== this.tempAttribState[i]) {
            this.attribState[i] = this.tempAttribState[i];
            if (this.attribState[i]) {
              gl.enableVertexAttribArray(i);
            } else {
              gl.disableVertexAttribArray(i);
            }
          }
        }
      };
      ShaderManager.prototype.setShader = function(shader) {
        if (this._currentId === shader.uid) {
          return false;
        }
        this._currentId = shader.uid;
        this.currentShader = shader;
        this.renderer.gl.useProgram(shader.program);
        this.setAttribs(shader.attributes);
        return true;
      };
      ShaderManager.prototype.destroy = function() {
        WebGLManager.prototype.destroy.call(this);
        this.destroyPlugins();
        this.attribState = null;
        this.tempAttribState = null;
      };
    }, {
      "../../../utils": 76,
      "../shaders/ComplexPrimitiveShader": 58,
      "../shaders/PrimitiveShader": 59,
      "../shaders/TextureShader": 61,
      "./WebGLManager": 57
    }],
    56: [function(require, module, exports) {
      var WebGLManager = require('./WebGLManager'),
          utils = require('../../../utils');
      function WebGLMaskManager(renderer) {
        WebGLManager.call(this, renderer);
        this.stencilMaskStack = null;
      }
      WebGLMaskManager.prototype = Object.create(WebGLManager.prototype);
      WebGLMaskManager.prototype.constructor = WebGLMaskManager;
      module.exports = WebGLMaskManager;
      WebGLMaskManager.prototype.setMaskStack = function(stencilMaskStack) {
        this.stencilMaskStack = stencilMaskStack;
        var gl = this.renderer.gl;
        if (stencilMaskStack.stencilStack.length === 0) {
          gl.disable(gl.STENCIL_TEST);
        } else {
          gl.enable(gl.STENCIL_TEST);
        }
      };
      WebGLMaskManager.prototype.pushStencil = function(graphics, webGLData) {
        this.renderer.currentRenderTarget.attachStencilBuffer();
        var gl = this.renderer.gl,
            sms = this.stencilMaskStack;
        this.bindGraphics(graphics, webGLData, this.renderer);
        if (sms.stencilStack.length === 0) {
          gl.enable(gl.STENCIL_TEST);
          gl.clear(gl.STENCIL_BUFFER_BIT);
          sms.reverse = true;
          sms.count = 0;
        }
        sms.stencilStack.push(webGLData);
        var level = sms.count;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
        if (webGLData.mode === 1) {
          gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);
          if (sms.reverse) {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
          } else {
            gl.stencilFunc(gl.EQUAL, level, 0xFF);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
          }
          gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
          if (sms.reverse) {
            gl.stencilFunc(gl.EQUAL, 0xFF - (level + 1), 0xFF);
          } else {
            gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
          }
          sms.reverse = !sms.reverse;
        } else {
          if (!sms.reverse) {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
          } else {
            gl.stencilFunc(gl.EQUAL, level, 0xFF);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
          }
          gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
          if (!sms.reverse) {
            gl.stencilFunc(gl.EQUAL, 0xFF - (level + 1), 0xFF);
          } else {
            gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
          }
        }
        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        sms.count++;
      };
      WebGLMaskManager.prototype.bindGraphics = function(graphics, webGLData) {
        this._currentGraphics = graphics;
        var gl = this.renderer.gl;
        var shader;
        if (webGLData.mode === 1) {
          shader = this.renderer.shaderManager.complexPrimitiveShader;
          this.renderer.shaderManager.setShader(shader);
          gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));
          gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));
          gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));
          gl.uniform3fv(shader.uniforms.color._location, webGLData.color);
          gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);
          gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
          gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
        } else {
          shader = this.renderer.shaderManager.primitiveShader;
          this.renderer.shaderManager.setShader(shader);
          gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));
          gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));
          gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));
          gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);
          gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
          gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
          gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
        }
      };
      WebGLMaskManager.prototype.popStencil = function(graphics, webGLData) {
        var gl = this.renderer.gl,
            sms = this.stencilMaskStack;
        sms.stencilStack.pop();
        sms.count--;
        if (sms.stencilStack.length === 0) {
          gl.disable(gl.STENCIL_TEST);
        } else {
          var level = sms.count;
          this.bindGraphics(graphics, webGLData, this.renderer);
          gl.colorMask(false, false, false, false);
          if (webGLData.mode === 1) {
            sms.reverse = !sms.reverse;
            if (sms.reverse) {
              gl.stencilFunc(gl.EQUAL, 0xFF - (level + 1), 0xFF);
              gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
            } else {
              gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
              gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            }
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
            gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
            gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);
            if (!sms.reverse) {
              gl.stencilFunc(gl.EQUAL, 0xFF - (level), 0xFF);
            } else {
              gl.stencilFunc(gl.EQUAL, level, 0xFF);
            }
          } else {
            if (!sms.reverse) {
              gl.stencilFunc(gl.EQUAL, 0xFF - (level + 1), 0xFF);
              gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
            } else {
              gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
              gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            }
            gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
            if (!sms.reverse) {
              gl.stencilFunc(gl.EQUAL, 0xFF - (level), 0xFF);
            } else {
              gl.stencilFunc(gl.EQUAL, level, 0xFF);
            }
          }
          gl.colorMask(true, true, true, true);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        }
      };
      WebGLMaskManager.prototype.destroy = function() {
        WebGLManager.prototype.destroy.call(this);
        this.stencilMaskStack.stencilStack = null;
      };
      WebGLMaskManager.prototype.pushMask = function(maskData) {
        this.renderer.setObjectRenderer(this.renderer.plugins.graphics);
        if (maskData.dirty) {
          this.renderer.plugins.graphics.updateGraphics(maskData, this.renderer.gl);
        }
        if (!maskData._webGL[this.renderer.gl.id].data.length) {
          return;
        }
        this.pushStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0], this.renderer);
      };
      WebGLMaskManager.prototype.popMask = function(maskData) {
        this.renderer.setObjectRenderer(this.renderer.plugins.graphics);
        this.popStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0], this.renderer);
      };
    }, {
      "../../../utils": 76,
      "./WebGLManager": 57
    }],
    57: [function(require, module, exports) {
      function WebGLManager(renderer) {
        this.renderer = renderer;
        this.renderer.on('context', this.onContextChange, this);
      }
      WebGLManager.prototype.constructor = WebGLManager;
      module.exports = WebGLManager;
      WebGLManager.prototype.onContextChange = function() {};
      WebGLManager.prototype.destroy = function() {
        this.renderer.off('context', this.onContextChange, this);
        this.renderer = null;
      };
    }, {}],
    58: [function(require, module, exports) {
      var Shader = require('./Shader');
      function ComplexPrimitiveShader(shaderManager) {
        Shader.call(this, shaderManager, ['attribute vec2 aVertexPosition;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform vec3 tint;', 'uniform float alpha;', 'uniform vec3 color;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = vec4(color * alpha * tint, alpha);', '}'].join('\n'), ['precision mediump float;', 'varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n'), {
          tint: {
            type: '3f',
            value: [0, 0, 0]
          },
          alpha: {
            type: '1f',
            value: 0
          },
          color: {
            type: '3f',
            value: [0, 0, 0]
          },
          translationMatrix: {
            type: 'mat3',
            value: new Float32Array(9)
          },
          projectionMatrix: {
            type: 'mat3',
            value: new Float32Array(9)
          }
        }, {aVertexPosition: 0});
      }
      ComplexPrimitiveShader.prototype = Object.create(Shader.prototype);
      ComplexPrimitiveShader.prototype.constructor = ComplexPrimitiveShader;
      module.exports = ComplexPrimitiveShader;
    }, {"./Shader": 60}],
    59: [function(require, module, exports) {
      var Shader = require('./Shader');
      function PrimitiveShader(shaderManager) {
        Shader.call(this, shaderManager, ['attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform float alpha;', 'uniform float flipY;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}'].join('\n'), ['precision mediump float;', 'varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n'), {
          tint: {
            type: '3f',
            value: [0, 0, 0]
          },
          alpha: {
            type: '1f',
            value: 0
          },
          translationMatrix: {
            type: 'mat3',
            value: new Float32Array(9)
          },
          projectionMatrix: {
            type: 'mat3',
            value: new Float32Array(9)
          }
        }, {
          aVertexPosition: 0,
          aColor: 0
        });
      }
      PrimitiveShader.prototype = Object.create(Shader.prototype);
      PrimitiveShader.prototype.constructor = PrimitiveShader;
      module.exports = PrimitiveShader;
    }, {"./Shader": 60}],
    60: [function(require, module, exports) {
      var utils = require('../../../utils');
      function Shader(shaderManager, vertexSrc, fragmentSrc, uniforms, attributes) {
        if (!vertexSrc || !fragmentSrc) {
          throw new Error('Pixi.js Error. Shader requires vertexSrc and fragmentSrc');
        }
        this.uid = utils.uid();
        this.gl = shaderManager.renderer.gl;
        this.shaderManager = shaderManager;
        this.program = null;
        this.uniforms = uniforms || {};
        this.attributes = attributes || {};
        this.textureCount = 1;
        this.vertexSrc = vertexSrc;
        this.fragmentSrc = fragmentSrc;
        this.init();
      }
      Shader.prototype.constructor = Shader;
      module.exports = Shader;
      Shader.prototype.init = function() {
        this.compile();
        this.gl.useProgram(this.program);
        this.cacheUniformLocations(Object.keys(this.uniforms));
        this.cacheAttributeLocations(Object.keys(this.attributes));
      };
      Shader.prototype.cacheUniformLocations = function(keys) {
        for (var i = 0; i < keys.length; ++i) {
          this.uniforms[keys[i]]._location = this.gl.getUniformLocation(this.program, keys[i]);
        }
      };
      Shader.prototype.cacheAttributeLocations = function(keys) {
        for (var i = 0; i < keys.length; ++i) {
          this.attributes[keys[i]] = this.gl.getAttribLocation(this.program, keys[i]);
        }
      };
      Shader.prototype.compile = function() {
        var gl = this.gl;
        var glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexSrc);
        var glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentSrc);
        var program = gl.createProgram();
        gl.attachShader(program, glVertShader);
        gl.attachShader(program, glFragShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Pixi.js Error: Could not initialize shader.');
          console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
          console.error('gl.getError()', gl.getError());
          if (gl.getProgramInfoLog(program) !== '') {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
          }
          gl.deleteProgram(program);
          program = null;
        }
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
        return (this.program = program);
      };
      Shader.prototype.syncUniform = function(uniform) {
        var location = uniform._location,
            value = uniform.value,
            gl = this.gl,
            i,
            il;
        switch (uniform.type) {
          case 'b':
          case 'bool':
          case 'boolean':
            gl.uniform1i(location, value ? 1 : 0);
            break;
          case 'i':
          case '1i':
            gl.uniform1i(location, value);
            break;
          case 'f':
          case '1f':
            gl.uniform1f(location, value);
            break;
          case '2f':
            gl.uniform2f(location, value[0], value[1]);
            break;
          case '3f':
            gl.uniform3f(location, value[0], value[1], value[2]);
            break;
          case '4f':
            gl.uniform4f(location, value[0], value[1], value[2], value[3]);
            break;
          case 'v2':
            gl.uniform2f(location, value.x, value.y);
            break;
          case 'v3':
            gl.uniform3f(location, value.x, value.y, value.z);
            break;
          case 'v4':
            gl.uniform4f(location, value.x, value.y, value.z, value.w);
            break;
          case '1iv':
            gl.uniform1iv(location, value);
            break;
          case '2iv':
            gl.uniform2iv(location, value);
            break;
          case '3iv':
            gl.uniform3iv(location, value);
            break;
          case '4iv':
            gl.uniform4iv(location, value);
            break;
          case '1fv':
            gl.uniform1fv(location, value);
            break;
          case '2fv':
            gl.uniform2fv(location, value);
            break;
          case '3fv':
            gl.uniform3fv(location, value);
            break;
          case '4fv':
            gl.uniform4fv(location, value);
            break;
          case 'm2':
          case 'mat2':
          case 'Matrix2fv':
            gl.uniformMatrix2fv(location, uniform.transpose, value);
            break;
          case 'm3':
          case 'mat3':
          case 'Matrix3fv':
            gl.uniformMatrix3fv(location, uniform.transpose, value);
            break;
          case 'm4':
          case 'mat4':
          case 'Matrix4fv':
            gl.uniformMatrix4fv(location, uniform.transpose, value);
            break;
          case 'c':
            if (typeof value === 'number') {
              value = utils.hex2rgb(value);
            }
            gl.uniform3f(location, value[0], value[1], value[2]);
            break;
          case 'iv1':
            gl.uniform1iv(location, value);
            break;
          case 'iv':
            gl.uniform3iv(location, value);
            break;
          case 'fv1':
            gl.uniform1fv(location, value);
            break;
          case 'fv':
            gl.uniform3fv(location, value);
            break;
          case 'v2v':
            if (!uniform._array) {
              uniform._array = new Float32Array(2 * value.length);
            }
            for (i = 0, il = value.length; i < il; ++i) {
              uniform._array[i * 2] = value[i].x;
              uniform._array[i * 2 + 1] = value[i].y;
            }
            gl.uniform2fv(location, uniform._array);
            break;
          case 'v3v':
            if (!uniform._array) {
              uniform._array = new Float32Array(3 * value.length);
            }
            for (i = 0, il = value.length; i < il; ++i) {
              uniform._array[i * 3] = value[i].x;
              uniform._array[i * 3 + 1] = value[i].y;
              uniform._array[i * 3 + 2] = value[i].z;
            }
            gl.uniform3fv(location, uniform._array);
            break;
          case 'v4v':
            if (!uniform._array) {
              uniform._array = new Float32Array(4 * value.length);
            }
            for (i = 0, il = value.length; i < il; ++i) {
              uniform._array[i * 4] = value[i].x;
              uniform._array[i * 4 + 1] = value[i].y;
              uniform._array[i * 4 + 2] = value[i].z;
              uniform._array[i * 4 + 3] = value[i].w;
            }
            gl.uniform4fv(location, uniform._array);
            break;
          case 't':
          case 'sampler2D':
            if (!uniform.value || !uniform.value.baseTexture.hasLoaded) {
              break;
            }
            gl.activeTexture(gl['TEXTURE' + this.textureCount]);
            var texture = uniform.value.baseTexture._glTextures[gl.id];
            if (!texture) {
              this.initSampler2D(uniform);
              texture = uniform.value.baseTexture._glTextures[gl.id];
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(uniform._location, this.textureCount);
            this.textureCount++;
            break;
          default:
            console.warn('Pixi.js Shader Warning: Unknown uniform type: ' + uniform.type);
        }
      };
      Shader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        for (var key in this.uniforms) {
          this.syncUniform(this.uniforms[key]);
        }
      };
      Shader.prototype.initSampler2D = function(uniform) {
        var gl = this.gl;
        var texture = uniform.value.baseTexture;
        if (!texture.hasLoaded) {
          return;
        }
        if (uniform.textureData) {
          var data = uniform.textureData;
          texture._glTextures[gl.id] = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
          gl.texImage2D(gl.TEXTURE_2D, 0, data.luminance ? gl.LUMINANCE : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, data.magFilter ? data.magFilter : gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE);
        } else {
          this.shaderManager.renderer.updateTexture(texture);
        }
      };
      Shader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.gl = null;
        this.uniforms = null;
        this.attributes = null;
        this.vertexSrc = null;
        this.fragmentSrc = null;
      };
      Shader.prototype._glCompile = function(type, src) {
        var shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, src);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.log(this.gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      };
    }, {"../../../utils": 76}],
    61: [function(require, module, exports) {
      var Shader = require('./Shader');
      function TextureShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes) {
        var uniforms = {
          uSampler: {
            type: 'sampler2D',
            value: 0
          },
          projectionMatrix: {
            type: 'mat3',
            value: new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
          }
        };
        if (customUniforms) {
          for (var u in customUniforms) {
            uniforms[u] = customUniforms[u];
          }
        }
        var attributes = {
          aVertexPosition: 0,
          aTextureCoord: 0,
          aColor: 0
        };
        if (customAttributes) {
          for (var a in customAttributes) {
            attributes[a] = customAttributes[a];
          }
        }
        vertexSrc = vertexSrc || TextureShader.defaultVertexSrc;
        fragmentSrc = fragmentSrc || TextureShader.defaultFragmentSrc;
        Shader.call(this, shaderManager, vertexSrc, fragmentSrc, uniforms, attributes);
      }
      TextureShader.prototype = Object.create(Shader.prototype);
      TextureShader.prototype.constructor = TextureShader;
      module.exports = TextureShader;
      TextureShader.defaultVertexSrc = ['precision lowp float;', 'attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'attribute vec4 aColor;', 'uniform mat3 projectionMatrix;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);', '}'].join('\n');
      TextureShader.defaultFragmentSrc = ['precision lowp float;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'uniform sampler2D uSampler;', 'void main(void){', '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;', '}'].join('\n');
    }, {"./Shader": 60}],
    62: [function(require, module, exports) {
      var WebGLManager = require('../managers/WebGLManager');
      function ObjectRenderer(renderer) {
        WebGLManager.call(this, renderer);
      }
      ObjectRenderer.prototype = Object.create(WebGLManager.prototype);
      ObjectRenderer.prototype.constructor = ObjectRenderer;
      module.exports = ObjectRenderer;
      ObjectRenderer.prototype.start = function() {};
      ObjectRenderer.prototype.stop = function() {
        this.flush();
      };
      ObjectRenderer.prototype.flush = function() {};
      ObjectRenderer.prototype.render = function(object) {};
    }, {"../managers/WebGLManager": 57}],
    63: [function(require, module, exports) {
      function Quad(gl) {
        this.gl = gl;
        this.vertices = new Float32Array([0, 0, 200, 0, 200, 200, 0, 200]);
        this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        this.colors = new Float32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
        this.indices = new Uint16Array([0, 1, 2, 0, 3, 2]);
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        this.upload();
      }
      Quad.prototype.constructor = Quad;
      Quad.prototype.map = function(rect, rect2) {
        var x = 0;
        var y = 0;
        this.uvs[0] = x;
        this.uvs[1] = y;
        this.uvs[2] = x + rect2.width / rect.width;
        this.uvs[3] = y;
        this.uvs[4] = x + rect2.width / rect.width;
        this.uvs[5] = y + rect2.height / rect.height;
        this.uvs[6] = x;
        this.uvs[7] = y + rect2.height / rect.height;
        x = rect2.x;
        y = rect2.y;
        this.vertices[0] = x;
        this.vertices[1] = y;
        this.vertices[2] = x + rect2.width;
        this.vertices[3] = y;
        this.vertices[4] = x + rect2.width;
        this.vertices[5] = y + rect2.height;
        this.vertices[6] = x;
        this.vertices[7] = y + rect2.height;
        this.upload();
      };
      Quad.prototype.upload = function() {
        var gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this.uvs);
        gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this.colors);
      };
      module.exports = Quad;
    }, {}],
    64: [function(require, module, exports) {
      var math = require('../../../math'),
          utils = require('../../../utils'),
          CONST = require('../../../const'),
          StencilMaskStack = require('./StencilMaskStack');
      var RenderTarget = function(gl, width, height, scaleMode, resolution, root) {
        this.gl = gl;
        this.frameBuffer = null;
        this.texture = null;
        this.size = new math.Rectangle(0, 0, 1, 1);
        this.resolution = resolution || CONST.RESOLUTION;
        this.projectionMatrix = new math.Matrix();
        this.transform = null;
        this.frame = null;
        this.stencilBuffer = null;
        this.stencilMaskStack = new StencilMaskStack();
        this.filterStack = [{
          renderTarget: this,
          filter: [],
          bounds: this.size
        }];
        this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
        this.root = root;
        if (!this.root) {
          this.frameBuffer = gl.createFramebuffer();
          this.texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
          var isPowerOfTwo = utils.isPowerOfTwo(width, height);
          if (!isPowerOfTwo) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          } else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
        }
        this.resize(width, height);
      };
      RenderTarget.prototype.constructor = RenderTarget;
      module.exports = RenderTarget;
      RenderTarget.prototype.clear = function(bind) {
        var gl = this.gl;
        if (bind) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        }
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      };
      RenderTarget.prototype.attachStencilBuffer = function() {
        if (this.stencilBuffer) {
          return;
        }
        if (!this.root) {
          var gl = this.gl;
          this.stencilBuffer = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencilBuffer);
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, this.size.width * this.resolution, this.size.height * this.resolution);
        }
      };
      RenderTarget.prototype.activate = function() {
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        var projectionFrame = this.frame || this.size;
        this.calculateProjection(projectionFrame);
        if (this.transform) {
          this.projectionMatrix.append(this.transform);
        }
        gl.viewport(0, 0, projectionFrame.width * this.resolution, projectionFrame.height * this.resolution);
      };
      RenderTarget.prototype.calculateProjection = function(projectionFrame) {
        var pm = this.projectionMatrix;
        pm.identity();
        if (!this.root) {
          pm.a = 1 / projectionFrame.width * 2;
          pm.d = 1 / projectionFrame.height * 2;
          pm.tx = -1 - projectionFrame.x * pm.a;
          pm.ty = -1 - projectionFrame.y * pm.d;
        } else {
          pm.a = 1 / projectionFrame.width * 2;
          pm.d = -1 / projectionFrame.height * 2;
          pm.tx = -1 - projectionFrame.x * pm.a;
          pm.ty = 1 - projectionFrame.y * pm.d;
        }
      };
      RenderTarget.prototype.resize = function(width, height) {
        width = width | 0;
        height = height | 0;
        if (this.size.width === width && this.size.height === height) {
          return;
        }
        this.size.width = width;
        this.size.height = height;
        if (!this.root) {
          var gl = this.gl;
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width * this.resolution, height * this.resolution, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          if (this.stencilBuffer) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width * this.resolution, height * this.resolution);
          }
        }
        var projectionFrame = this.frame || this.size;
        this.calculateProjection(projectionFrame);
      };
      RenderTarget.prototype.destroy = function() {
        var gl = this.gl;
        gl.deleteFramebuffer(this.frameBuffer);
        gl.deleteTexture(this.texture);
        this.frameBuffer = null;
        this.texture = null;
      };
    }, {
      "../../../const": 22,
      "../../../math": 32,
      "../../../utils": 76,
      "./StencilMaskStack": 65
    }],
    65: [function(require, module, exports) {
      function StencilMaskStack() {
        this.stencilStack = [];
        this.reverse = true;
        this.count = 0;
      }
      StencilMaskStack.prototype.constructor = StencilMaskStack;
      module.exports = StencilMaskStack;
    }, {}],
    66: [function(require, module, exports) {
      var math = require('../math'),
          Texture = require('../textures/Texture'),
          Container = require('../display/Container'),
          CanvasTinter = require('../renderers/canvas/utils/CanvasTinter'),
          utils = require('../utils'),
          CONST = require('../const'),
          tempPoint = new math.Point();
      function Sprite(texture) {
        Container.call(this);
        this.anchor = new math.Point();
        this._texture = null;
        this._width = 0;
        this._height = 0;
        this.tint = 0xFFFFFF;
        this.blendMode = CONST.BLEND_MODES.NORMAL;
        this.shader = null;
        this.cachedTint = 0xFFFFFF;
        this.texture = texture || Texture.EMPTY;
      }
      Sprite.prototype = Object.create(Container.prototype);
      Sprite.prototype.constructor = Sprite;
      module.exports = Sprite;
      Object.defineProperties(Sprite.prototype, {
        width: {
          get: function() {
            return this.scale.x * this.texture._frame.width;
          },
          set: function(value) {
            this.scale.x = value / this.texture._frame.width;
            this._width = value;
          }
        },
        height: {
          get: function() {
            return this.scale.y * this.texture._frame.height;
          },
          set: function(value) {
            this.scale.y = value / this.texture._frame.height;
            this._height = value;
          }
        },
        texture: {
          get: function() {
            return this._texture;
          },
          set: function(value) {
            if (this._texture === value) {
              return;
            }
            this._texture = value;
            this.cachedTint = 0xFFFFFF;
            if (value) {
              if (value.baseTexture.hasLoaded) {
                this._onTextureUpdate();
              } else {
                value.once('update', this._onTextureUpdate, this);
              }
            }
          }
        }
      });
      Sprite.prototype._onTextureUpdate = function() {
        if (this._width) {
          this.scale.x = this._width / this.texture.frame.width;
        }
        if (this._height) {
          this.scale.y = this._height / this.texture.frame.height;
        }
      };
      Sprite.prototype._renderWebGL = function(renderer) {
        renderer.setObjectRenderer(renderer.plugins.sprite);
        renderer.plugins.sprite.render(this);
      };
      Sprite.prototype.getBounds = function(matrix) {
        if (!this._currentBounds) {
          var width = this._texture._frame.width;
          var height = this._texture._frame.height;
          var w0 = width * (1 - this.anchor.x);
          var w1 = width * -this.anchor.x;
          var h0 = height * (1 - this.anchor.y);
          var h1 = height * -this.anchor.y;
          var worldTransform = matrix || this.worldTransform;
          var a = worldTransform.a;
          var b = worldTransform.b;
          var c = worldTransform.c;
          var d = worldTransform.d;
          var tx = worldTransform.tx;
          var ty = worldTransform.ty;
          var minX,
              maxX,
              minY,
              maxY;
          if (b === 0 && c === 0) {
            if (a < 0) {
              a *= -1;
            }
            if (d < 0) {
              d *= -1;
            }
            minX = a * w1 + tx;
            maxX = a * w0 + tx;
            minY = d * h1 + ty;
            maxY = d * h0 + ty;
          } else {
            var x1 = a * w1 + c * h1 + tx;
            var y1 = d * h1 + b * w1 + ty;
            var x2 = a * w0 + c * h1 + tx;
            var y2 = d * h1 + b * w0 + ty;
            var x3 = a * w0 + c * h0 + tx;
            var y3 = d * h0 + b * w0 + ty;
            var x4 = a * w1 + c * h0 + tx;
            var y4 = d * h0 + b * w1 + ty;
            minX = x1;
            minX = x2 < minX ? x2 : minX;
            minX = x3 < minX ? x3 : minX;
            minX = x4 < minX ? x4 : minX;
            minY = y1;
            minY = y2 < minY ? y2 : minY;
            minY = y3 < minY ? y3 : minY;
            minY = y4 < minY ? y4 : minY;
            maxX = x1;
            maxX = x2 > maxX ? x2 : maxX;
            maxX = x3 > maxX ? x3 : maxX;
            maxX = x4 > maxX ? x4 : maxX;
            maxY = y1;
            maxY = y2 > maxY ? y2 : maxY;
            maxY = y3 > maxY ? y3 : maxY;
            maxY = y4 > maxY ? y4 : maxY;
          }
          if (this.children.length) {
            var childBounds = this.containerGetBounds();
            w0 = childBounds.x;
            w1 = childBounds.x + childBounds.width;
            h0 = childBounds.y;
            h1 = childBounds.y + childBounds.height;
            minX = (minX < w0) ? minX : w0;
            minY = (minY < h0) ? minY : h0;
            maxX = (maxX > w1) ? maxX : w1;
            maxY = (maxY > h1) ? maxY : h1;
          }
          var bounds = this._bounds;
          bounds.x = minX;
          bounds.width = maxX - minX;
          bounds.y = minY;
          bounds.height = maxY - minY;
          this._currentBounds = bounds;
        }
        return this._currentBounds;
      };
      Sprite.prototype.getLocalBounds = function() {
        this._bounds.x = -this._texture._frame.width * this.anchor.x;
        this._bounds.y = -this._texture._frame.height * this.anchor.y;
        this._bounds.width = this._texture._frame.width;
        this._bounds.height = this._texture._frame.height;
        return this._bounds;
      };
      Sprite.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint);
        var width = this._texture._frame.width;
        var height = this._texture._frame.height;
        var x1 = -width * this.anchor.x;
        var y1;
        if (tempPoint.x > x1 && tempPoint.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (tempPoint.y > y1 && tempPoint.y < y1 + height) {
            return true;
          }
        }
        return false;
      };
      Sprite.prototype._renderCanvas = function(renderer) {
        if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0) {
          return;
        }
        if (this.blendMode !== renderer.currentBlendMode) {
          renderer.currentBlendMode = this.blendMode;
          renderer.context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];
        }
        if (this.texture.valid) {
          var texture = this._texture,
              wt = this.worldTransform,
              dx,
              dy,
              width,
              height;
          renderer.context.globalAlpha = this.worldAlpha;
          if (renderer.smoothProperty && renderer.currentScaleMode !== texture.baseTexture.scaleMode) {
            renderer.currentScaleMode = texture.baseTexture.scaleMode;
            renderer.context[renderer.smoothProperty] = (renderer.currentScaleMode === CONST.SCALE_MODES.LINEAR);
          }
          if (texture.rotate) {
            var a = wt.a;
            var b = wt.b;
            wt.a = -wt.c;
            wt.b = -wt.d;
            wt.c = a;
            wt.d = b;
            width = texture.crop.height;
            height = texture.crop.width;
            dx = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;
            dy = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;
          } else {
            width = texture.crop.width;
            height = texture.crop.height;
            dx = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;
            dy = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;
          }
          if (renderer.roundPixels) {
            renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, (wt.tx * renderer.resolution) | 0, (wt.ty * renderer.resolution) | 0);
            dx = dx | 0;
            dy = dy | 0;
          } else {
            renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);
          }
          var resolution = texture.baseTexture.resolution;
          if (this.tint !== 0xFFFFFF) {
            if (this.cachedTint !== this.tint) {
              this.cachedTint = this.tint;
              this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
            }
            renderer.context.drawImage(this.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
          } else {
            renderer.context.drawImage(texture.baseTexture.source, texture.crop.x * resolution, texture.crop.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
          }
        }
      };
      Sprite.prototype.destroy = function(destroyTexture, destroyBaseTexture) {
        Container.prototype.destroy.call(this);
        this.anchor = null;
        if (destroyTexture) {
          this._texture.destroy(destroyBaseTexture);
        }
        this._texture = null;
        this.shader = null;
      };
      Sprite.fromFrame = function(frameId) {
        var texture = utils.TextureCache[frameId];
        if (!texture) {
          throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
        }
        return new Sprite(texture);
      };
      Sprite.fromImage = function(imageId, crossorigin, scaleMode) {
        return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));
      };
    }, {
      "../const": 22,
      "../display/Container": 23,
      "../math": 32,
      "../renderers/canvas/utils/CanvasTinter": 47,
      "../textures/Texture": 71,
      "../utils": 76
    }],
    67: [function(require, module, exports) {
      var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
          WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
          CONST = require('../../const');
      function SpriteRenderer(renderer) {
        ObjectRenderer.call(this, renderer);
        this.vertSize = 5;
        this.vertByteSize = this.vertSize * 4;
        this.size = CONST.SPRITE_BATCH_SIZE;
        var numVerts = (this.size * 4) * this.vertByteSize;
        var numIndices = this.size * 6;
        this.vertices = new ArrayBuffer(numVerts);
        this.positions = new Float32Array(this.vertices);
        this.colors = new Uint32Array(this.vertices);
        this.indices = new Uint16Array(numIndices);
        for (var i = 0,
            j = 0; i < numIndices; i += 6, j += 4) {
          this.indices[i + 0] = j + 0;
          this.indices[i + 1] = j + 1;
          this.indices[i + 2] = j + 2;
          this.indices[i + 3] = j + 0;
          this.indices[i + 4] = j + 2;
          this.indices[i + 5] = j + 3;
        }
        this.currentBatchSize = 0;
        this.sprites = [];
        this.shader = null;
      }
      SpriteRenderer.prototype = Object.create(ObjectRenderer.prototype);
      SpriteRenderer.prototype.constructor = SpriteRenderer;
      module.exports = SpriteRenderer;
      WebGLRenderer.registerPlugin('sprite', SpriteRenderer);
      SpriteRenderer.prototype.onContextChange = function() {
        var gl = this.renderer.gl;
        this.shader = this.renderer.shaderManager.defaultShader;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
        this.currentBlendMode = 99999;
      };
      SpriteRenderer.prototype.render = function(sprite) {
        var texture = sprite._texture;
        if (this.currentBatchSize >= this.size) {
          this.flush();
        }
        var uvs = texture._uvs;
        if (!uvs) {
          return;
        }
        var aX = sprite.anchor.x;
        var aY = sprite.anchor.y;
        var w0,
            w1,
            h0,
            h1;
        if (texture.trim) {
          var trim = texture.trim;
          w1 = trim.x - aX * trim.width;
          w0 = w1 + texture.crop.width;
          h1 = trim.y - aY * trim.height;
          h0 = h1 + texture.crop.height;
        } else {
          w0 = (texture._frame.width) * (1 - aX);
          w1 = (texture._frame.width) * -aX;
          h0 = texture._frame.height * (1 - aY);
          h1 = texture._frame.height * -aY;
        }
        var index = this.currentBatchSize * this.vertByteSize;
        var worldTransform = sprite.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var colors = this.colors;
        var positions = this.positions;
        if (this.renderer.roundPixels) {
          positions[index] = a * w1 + c * h1 + tx | 0;
          positions[index + 1] = d * h1 + b * w1 + ty | 0;
          positions[index + 5] = a * w0 + c * h1 + tx | 0;
          positions[index + 6] = d * h1 + b * w0 + ty | 0;
          positions[index + 10] = a * w0 + c * h0 + tx | 0;
          positions[index + 11] = d * h0 + b * w0 + ty | 0;
          positions[index + 15] = a * w1 + c * h0 + tx | 0;
          positions[index + 16] = d * h0 + b * w1 + ty | 0;
        } else {
          positions[index] = a * w1 + c * h1 + tx;
          positions[index + 1] = d * h1 + b * w1 + ty;
          positions[index + 5] = a * w0 + c * h1 + tx;
          positions[index + 6] = d * h1 + b * w0 + ty;
          positions[index + 10] = a * w0 + c * h0 + tx;
          positions[index + 11] = d * h0 + b * w0 + ty;
          positions[index + 15] = a * w1 + c * h0 + tx;
          positions[index + 16] = d * h0 + b * w1 + ty;
        }
        positions[index + 2] = uvs.x0;
        positions[index + 3] = uvs.y0;
        positions[index + 7] = uvs.x1;
        positions[index + 8] = uvs.y1;
        positions[index + 12] = uvs.x2;
        positions[index + 13] = uvs.y2;
        positions[index + 17] = uvs.x3;
        positions[index + 18] = uvs.y3;
        var tint = sprite.tint;
        colors[index + 4] = colors[index + 9] = colors[index + 14] = colors[index + 19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);
        this.sprites[this.currentBatchSize++] = sprite;
      };
      SpriteRenderer.prototype.flush = function() {
        if (this.currentBatchSize === 0) {
          return;
        }
        var gl = this.renderer.gl;
        var shader;
        if (this.currentBatchSize > (this.size * 0.5)) {
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        } else {
          var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
        }
        var nextTexture,
            nextBlendMode,
            nextShader;
        var batchSize = 0;
        var start = 0;
        var currentBaseTexture = null;
        var currentBlendMode = this.renderer.blendModeManager.currentBlendMode;
        var currentShader = null;
        var blendSwap = false;
        var shaderSwap = false;
        var sprite;
        for (var i = 0,
            j = this.currentBatchSize; i < j; i++) {
          sprite = this.sprites[i];
          nextTexture = sprite._texture.baseTexture;
          nextBlendMode = sprite.blendMode;
          nextShader = sprite.shader || this.shader;
          blendSwap = currentBlendMode !== nextBlendMode;
          shaderSwap = currentShader !== nextShader;
          if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap) {
            this.renderBatch(currentBaseTexture, batchSize, start);
            start = i;
            batchSize = 0;
            currentBaseTexture = nextTexture;
            if (blendSwap) {
              currentBlendMode = nextBlendMode;
              this.renderer.blendModeManager.setBlendMode(currentBlendMode);
            }
            if (shaderSwap) {
              currentShader = nextShader;
              shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;
              if (!shader) {
                shader = currentShader.getShader(this.renderer);
              }
              this.renderer.shaderManager.setShader(shader);
              shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);
              shader.syncUniforms();
              gl.activeTexture(gl.TEXTURE0);
            }
          }
          batchSize++;
        }
        this.renderBatch(currentBaseTexture, batchSize, start);
        this.currentBatchSize = 0;
      };
      SpriteRenderer.prototype.renderBatch = function(texture, size, startIndex) {
        if (size === 0) {
          return;
        }
        var gl = this.renderer.gl;
        if (!texture._glTextures[gl.id]) {
          this.renderer.updateTexture(texture);
        } else {
          gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        }
        gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);
        this.renderer.drawCount++;
      };
      SpriteRenderer.prototype.start = function() {
        var gl = this.renderer.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var stride = this.vertByteSize;
        gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
        gl.vertexAttribPointer(this.shader.attributes.aColor, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);
      };
      SpriteRenderer.prototype.destroy = function() {
        this.renderer.gl.deleteBuffer(this.vertexBuffer);
        this.renderer.gl.deleteBuffer(this.indexBuffer);
        this.shader.destroy();
        this.renderer = null;
        this.vertices = null;
        this.positions = null;
        this.colors = null;
        this.indices = null;
        this.vertexBuffer = null;
        this.indexBuffer = null;
        this.sprites = null;
        this.shader = null;
      };
    }, {
      "../../const": 22,
      "../../renderers/webgl/WebGLRenderer": 48,
      "../../renderers/webgl/utils/ObjectRenderer": 62
    }],
    68: [function(require, module, exports) {
      var Sprite = require('../sprites/Sprite'),
          Texture = require('../textures/Texture'),
          math = require('../math'),
          utils = require('../utils'),
          CONST = require('../const');
      function Text(text, style, resolution) {
        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');
        this.resolution = resolution || CONST.RESOLUTION;
        this._text = null;
        this._style = null;
        var texture = Texture.fromCanvas(this.canvas);
        texture.trim = new math.Rectangle();
        Sprite.call(this, texture);
        this.text = text;
        this.style = style;
      }
      Text.prototype = Object.create(Sprite.prototype);
      Text.prototype.constructor = Text;
      module.exports = Text;
      Text.fontPropertiesCache = {};
      Text.fontPropertiesCanvas = document.createElement('canvas');
      Text.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');
      Object.defineProperties(Text.prototype, {
        width: {
          get: function() {
            if (this.dirty) {
              this.updateText();
            }
            return this.scale.x * this._texture._frame.width;
          },
          set: function(value) {
            this.scale.x = value / this._texture._frame.width;
            this._width = value;
          }
        },
        height: {
          get: function() {
            if (this.dirty) {
              this.updateText();
            }
            return this.scale.y * this._texture._frame.height;
          },
          set: function(value) {
            this.scale.y = value / this._texture._frame.height;
            this._height = value;
          }
        },
        style: {
          get: function() {
            return this._style;
          },
          set: function(style) {
            style = style || {};
            if (typeof style.fill === 'number') {
              style.fill = utils.hex2string(style.fill);
            }
            if (typeof style.stroke === 'number') {
              style.stroke = utils.hex2string(style.stroke);
            }
            if (typeof style.dropShadowColor === 'number') {
              style.dropShadowColor = utils.hex2string(style.dropShadowColor);
            }
            style.font = style.font || 'bold 20pt Arial';
            style.fill = style.fill || 'black';
            style.align = style.align || 'left';
            style.stroke = style.stroke || 'black';
            style.strokeThickness = style.strokeThickness || 0;
            style.wordWrap = style.wordWrap || false;
            style.wordWrapWidth = style.wordWrapWidth || 100;
            style.dropShadow = style.dropShadow || false;
            style.dropShadowColor = style.dropShadowColor || '#000000';
            style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;
            style.dropShadowDistance = style.dropShadowDistance || 5;
            style.padding = style.padding || 0;
            style.textBaseline = style.textBaseline || 'alphabetic';
            style.lineJoin = style.lineJoin || 'miter';
            style.miterLimit = style.miterLimit || 10;
            this._style = style;
            this.dirty = true;
          }
        },
        text: {
          get: function() {
            return this._text;
          },
          set: function(text) {
            text = text.toString() || ' ';
            if (this._text === text) {
              return;
            }
            this._text = text;
            this.dirty = true;
          }
        }
      });
      Text.prototype.updateText = function() {
        var style = this._style;
        this.context.font = style.font;
        var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        var fontProperties = this.determineFontProperties(style.font);
        for (var i = 0; i < lines.length; i++) {
          var lineWidth = this.context.measureText(lines[i]).width;
          lineWidths[i] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
          width += style.dropShadowDistance;
        }
        this.canvas.width = (width + this.context.lineWidth) * this.resolution;
        var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = lineHeight * lines.length;
        if (style.dropShadow) {
          height += style.dropShadowDistance;
        }
        this.canvas.height = (height + this._style.padding * 2) * this.resolution;
        this.context.scale(this.resolution, this.resolution);
        if (navigator.isCocoonJS) {
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        this.context.font = style.font;
        this.context.strokeStyle = style.stroke;
        this.context.lineWidth = style.strokeThickness;
        this.context.textBaseline = style.textBaseline;
        this.context.lineJoin = style.lineJoin;
        this.context.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        if (style.dropShadow) {
          this.context.fillStyle = style.dropShadowColor;
          var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
          var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
          for (i = 0; i < lines.length; i++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;
            if (style.align === 'right') {
              linePositionX += maxLineWidth - lineWidths[i];
            } else if (style.align === 'center') {
              linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (style.fill) {
              this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + this._style.padding);
            }
          }
        }
        this.context.fillStyle = style.fill;
        for (i = 0; i < lines.length; i++) {
          linePositionX = style.strokeThickness / 2;
          linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;
          if (style.align === 'right') {
            linePositionX += maxLineWidth - lineWidths[i];
          } else if (style.align === 'center') {
            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
          }
          if (style.stroke && style.strokeThickness) {
            this.context.strokeText(lines[i], linePositionX, linePositionY + this._style.padding);
          }
          if (style.fill) {
            this.context.fillText(lines[i], linePositionX, linePositionY + this._style.padding);
          }
        }
        this.updateTexture();
      };
      Text.prototype.updateTexture = function() {
        var texture = this._texture;
        texture.baseTexture.hasLoaded = true;
        texture.baseTexture.resolution = this.resolution;
        texture.baseTexture.width = this.canvas.width / this.resolution;
        texture.baseTexture.height = this.canvas.height / this.resolution;
        texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;
        texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;
        texture.trim.x = 0;
        texture.trim.y = -this._style.padding;
        texture.trim.width = texture._frame.width;
        texture.trim.height = texture._frame.height - this._style.padding * 2;
        this._width = this.canvas.width / this.resolution;
        this._height = this.canvas.height / this.resolution;
        texture.baseTexture.emit('update', texture.baseTexture);
        this.dirty = false;
      };
      Text.prototype.renderWebGL = function(renderer) {
        if (this.dirty) {
          this.updateText();
        }
        Sprite.prototype.renderWebGL.call(this, renderer);
      };
      Text.prototype._renderCanvas = function(renderer) {
        if (this.dirty) {
          this.updateText();
        }
        Sprite.prototype._renderCanvas.call(this, renderer);
      };
      Text.prototype.determineFontProperties = function(fontStyle) {
        var properties = Text.fontPropertiesCache[fontStyle];
        if (!properties) {
          properties = {};
          var canvas = Text.fontPropertiesCanvas;
          var context = Text.fontPropertiesContext;
          context.font = fontStyle;
          var width = Math.ceil(context.measureText('|MÉq').width);
          var baseline = Math.ceil(context.measureText('M').width);
          var height = 2 * baseline;
          baseline = baseline * 1.4 | 0;
          canvas.width = width;
          canvas.height = height;
          context.fillStyle = '#f00';
          context.fillRect(0, 0, width, height);
          context.font = fontStyle;
          context.textBaseline = 'alphabetic';
          context.fillStyle = '#000';
          context.fillText('|MÉq', 0, baseline);
          var imagedata = context.getImageData(0, 0, width, height).data;
          var pixels = imagedata.length;
          var line = width * 4;
          var i,
              j;
          var idx = 0;
          var stop = false;
          for (i = 0; i < baseline; i++) {
            for (j = 0; j < line; j += 4) {
              if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx += line;
            } else {
              break;
            }
          }
          properties.ascent = baseline - i;
          idx = pixels - line;
          stop = false;
          for (i = height; i > baseline; i--) {
            for (j = 0; j < line; j += 4) {
              if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx -= line;
            } else {
              break;
            }
          }
          properties.descent = i - baseline;
          properties.fontSize = properties.ascent + properties.descent;
          Text.fontPropertiesCache[fontStyle] = properties;
        }
        return properties;
      };
      Text.prototype.wordWrap = function(text) {
        var result = '';
        var lines = text.split('\n');
        var wordWrapWidth = this._style.wordWrapWidth;
        for (var i = 0; i < lines.length; i++) {
          var spaceLeft = wordWrapWidth;
          var words = lines[i].split(' ');
          for (var j = 0; j < words.length; j++) {
            var wordWidth = this.context.measureText(words[j]).width;
            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
            if (j === 0 || wordWidthWithSpace > spaceLeft) {
              if (j > 0) {
                result += '\n';
              }
              result += words[j];
              spaceLeft = wordWrapWidth - wordWidth;
            } else {
              spaceLeft -= wordWidthWithSpace;
              result += ' ' + words[j];
            }
          }
          if (i < lines.length - 1) {
            result += '\n';
          }
        }
        return result;
      };
      Text.prototype.getBounds = function(matrix) {
        if (this.dirty) {
          this.updateText();
        }
        return Sprite.prototype.getBounds.call(this, matrix);
      };
      Text.prototype.destroy = function(destroyBaseTexture) {
        this.context = null;
        this.canvas = null;
        this._style = null;
        this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
      };
    }, {
      "../const": 22,
      "../math": 32,
      "../sprites/Sprite": 66,
      "../textures/Texture": 71,
      "../utils": 76
    }],
    69: [function(require, module, exports) {
      var utils = require('../utils'),
          CONST = require('../const'),
          EventEmitter = require('eventemitter3');
      function BaseTexture(source, scaleMode, resolution) {
        EventEmitter.call(this);
        this.uid = utils.uid();
        this.resolution = resolution || 1;
        this.width = 100;
        this.height = 100;
        this.realWidth = 100;
        this.realHeight = 100;
        this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
        this.hasLoaded = false;
        this.isLoading = false;
        this.source = null;
        this.premultipliedAlpha = true;
        this.imageUrl = null;
        this.isPowerOfTwo = false;
        this.mipmap = false;
        this._glTextures = [];
        if (source) {
          this.loadSource(source);
        }
      }
      BaseTexture.prototype = Object.create(EventEmitter.prototype);
      BaseTexture.prototype.constructor = BaseTexture;
      module.exports = BaseTexture;
      BaseTexture.prototype.update = function() {
        this.realWidth = this.source.naturalWidth || this.source.width;
        this.realHeight = this.source.naturalHeight || this.source.height;
        this.width = this.realWidth / this.resolution;
        this.height = this.realHeight / this.resolution;
        this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);
        this.emit('update', this);
      };
      BaseTexture.prototype.loadSource = function(source) {
        var wasLoading = this.isLoading;
        this.hasLoaded = false;
        this.isLoading = false;
        if (wasLoading && this.source) {
          this.source.onload = null;
          this.source.onerror = null;
        }
        this.source = source;
        if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) {
          this._sourceLoaded();
        } else if (!source.getContext) {
          this.isLoading = true;
          var scope = this;
          source.onload = function() {
            source.onload = null;
            source.onerror = null;
            if (!scope.isLoading) {
              return;
            }
            scope.isLoading = false;
            scope._sourceLoaded();
            scope.emit('loaded', scope);
          };
          source.onerror = function() {
            source.onload = null;
            source.onerror = null;
            if (!scope.isLoading) {
              return;
            }
            scope.isLoading = false;
            scope.emit('error', scope);
          };
          if (source.complete && source.src) {
            this.isLoading = false;
            source.onload = null;
            source.onerror = null;
            if (source.width && source.height) {
              this._sourceLoaded();
              if (wasLoading) {
                this.emit('loaded', this);
              }
            } else {
              if (wasLoading) {
                this.emit('error', this);
              }
            }
          }
        }
      };
      BaseTexture.prototype._sourceLoaded = function() {
        this.hasLoaded = true;
        this.update();
      };
      BaseTexture.prototype.destroy = function() {
        if (this.imageUrl) {
          delete utils.BaseTextureCache[this.imageUrl];
          delete utils.TextureCache[this.imageUrl];
          this.imageUrl = null;
          if (!navigator.isCocoonJS) {
            this.source.src = '';
          }
        } else if (this.source && this.source._pixiId) {
          delete utils.BaseTextureCache[this.source._pixiId];
        }
        this.source = null;
        this.dispose();
      };
      BaseTexture.prototype.dispose = function() {
        this.emit('dispose', this);
        this._glTextures.length = 0;
      };
      BaseTexture.prototype.updateSourceImage = function(newSrc) {
        this.source.src = newSrc;
        this.loadSource(this.source);
      };
      BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode) {
        var baseTexture = utils.BaseTextureCache[imageUrl];
        if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0) {
          crossorigin = true;
        }
        if (!baseTexture) {
          var image = new Image();
          if (crossorigin) {
            image.crossOrigin = '';
          }
          baseTexture = new BaseTexture(image, scaleMode);
          baseTexture.imageUrl = imageUrl;
          image.src = imageUrl;
          utils.BaseTextureCache[imageUrl] = baseTexture;
          baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);
        }
        return baseTexture;
      };
      BaseTexture.fromCanvas = function(canvas, scaleMode) {
        if (!canvas._pixiId) {
          canvas._pixiId = 'canvas_' + utils.uid();
        }
        var baseTexture = utils.BaseTextureCache[canvas._pixiId];
        if (!baseTexture) {
          baseTexture = new BaseTexture(canvas, scaleMode);
          utils.BaseTextureCache[canvas._pixiId] = baseTexture;
        }
        return baseTexture;
      };
    }, {
      "../const": 22,
      "../utils": 76,
      eventemitter3: 11
    }],
    70: [function(require, module, exports) {
      var BaseTexture = require('./BaseTexture'),
          Texture = require('./Texture'),
          RenderTarget = require('../renderers/webgl/utils/RenderTarget'),
          FilterManager = require('../renderers/webgl/managers/FilterManager'),
          CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),
          math = require('../math'),
          CONST = require('../const'),
          tempMatrix = new math.Matrix();
      function RenderTexture(renderer, width, height, scaleMode, resolution) {
        if (!renderer) {
          throw new Error('Unable to create RenderTexture, you must pass a renderer into the constructor.');
        }
        width = width || 100;
        height = height || 100;
        resolution = resolution || CONST.RESOLUTION;
        var baseTexture = new BaseTexture();
        baseTexture.width = width;
        baseTexture.height = height;
        baseTexture.resolution = resolution;
        baseTexture.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
        baseTexture.hasLoaded = true;
        Texture.call(this, baseTexture, new math.Rectangle(0, 0, width, height));
        this.width = width;
        this.height = height;
        this.resolution = resolution;
        this.render = null;
        this.renderer = renderer;
        if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {
          var gl = this.renderer.gl;
          this.textureBuffer = new RenderTarget(gl, this.width, this.height, baseTexture.scaleMode, this.resolution);
          this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture;
          this.filterManager = new FilterManager(this.renderer);
          this.filterManager.onContextChange();
          this.filterManager.resize(width, height);
          this.render = this.renderWebGL;
          this.renderer.currentRenderer.start();
          this.renderer.currentRenderTarget.activate();
        } else {
          this.render = this.renderCanvas;
          this.textureBuffer = new CanvasBuffer(this.width * this.resolution, this.height * this.resolution);
          this.baseTexture.source = this.textureBuffer.canvas;
        }
        this.valid = true;
        this._updateUvs();
      }
      RenderTexture.prototype = Object.create(Texture.prototype);
      RenderTexture.prototype.constructor = RenderTexture;
      module.exports = RenderTexture;
      RenderTexture.prototype.resize = function(width, height, updateBase) {
        if (width === this.width && height === this.height) {
          return;
        }
        this.valid = (width > 0 && height > 0);
        this.width = this._frame.width = this.crop.width = width;
        this.height = this._frame.height = this.crop.height = height;
        if (updateBase) {
          this.baseTexture.width = this.width;
          this.baseTexture.height = this.height;
        }
        if (!this.valid) {
          return;
        }
        this.textureBuffer.resize(this.width, this.height);
        if (this.filterManager) {
          this.filterManager.resize(this.width, this.height);
        }
      };
      RenderTexture.prototype.clear = function() {
        if (!this.valid) {
          return;
        }
        if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {
          this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        }
        this.textureBuffer.clear();
      };
      RenderTexture.prototype.renderWebGL = function(displayObject, matrix, clear, updateTransform) {
        if (!this.valid) {
          return;
        }
        updateTransform = (updateTransform !== undefined) ? updateTransform : true;
        this.textureBuffer.transform = matrix;
        this.textureBuffer.activate();
        displayObject.worldAlpha = 1;
        if (updateTransform) {
          displayObject.worldTransform.identity();
          displayObject.currentBounds = null;
          var children = displayObject.children;
          var i,
              j;
          for (i = 0, j = children.length; i < j; ++i) {
            children[i].updateTransform();
          }
        }
        var temp = this.renderer.filterManager;
        this.renderer.filterManager = this.filterManager;
        this.renderer.renderDisplayObject(displayObject, this.textureBuffer, clear);
        this.renderer.filterManager = temp;
      };
      RenderTexture.prototype.renderCanvas = function(displayObject, matrix, clear, updateTransform) {
        if (!this.valid) {
          return;
        }
        updateTransform = !!updateTransform;
        var cachedWt = displayObject.worldTransform;
        var wt = tempMatrix;
        wt.identity();
        if (matrix) {
          wt.append(matrix);
        }
        displayObject.worldTransform = wt;
        displayObject.worldAlpha = 1;
        var children = displayObject.children;
        var i,
            j;
        for (i = 0, j = children.length; i < j; ++i) {
          children[i].updateTransform();
        }
        if (clear) {
          this.textureBuffer.clear();
        }
        displayObject.worldTransform = cachedWt;
        var context = this.textureBuffer.context;
        var realResolution = this.renderer.resolution;
        this.renderer.resolution = this.resolution;
        this.renderer.renderDisplayObject(displayObject, context);
        this.renderer.resolution = realResolution;
      };
      RenderTexture.prototype.destroy = function() {
        Texture.prototype.destroy.call(this, true);
        this.textureBuffer.destroy();
        if (this.filterManager) {
          this.filterManager.destroy();
        }
        this.renderer = null;
      };
      RenderTexture.prototype.getImage = function() {
        var image = new Image();
        image.src = this.getBase64();
        return image;
      };
      RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL();
      };
      RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {
          var gl = this.renderer.gl;
          var width = this.textureBuffer.size.width;
          var height = this.textureBuffer.size.height;
          var webGLPixels = new Uint8Array(4 * width * height);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          var tempCanvas = new CanvasBuffer(width, height);
          var canvasData = tempCanvas.context.getImageData(0, 0, width, height);
          canvasData.data.set(webGLPixels);
          tempCanvas.context.putImageData(canvasData, 0, 0);
          return tempCanvas.canvas;
        } else {
          return this.textureBuffer.canvas;
        }
      };
      RenderTexture.prototype.getPixels = function() {
        var width,
            height;
        if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {
          var gl = this.renderer.gl;
          width = this.textureBuffer.size.width;
          height = this.textureBuffer.size.height;
          var webGLPixels = new Uint8Array(4 * width * height);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return webGLPixels;
        } else {
          width = this.textureBuffer.canvas.width;
          height = this.textureBuffer.canvas.height;
          return this.textureBuffer.canvas.getContext('2d').getImageData(0, 0, width, height).data;
        }
      };
      RenderTexture.prototype.getPixel = function(x, y) {
        if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {
          var gl = this.renderer.gl;
          var webGLPixels = new Uint8Array(4);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
          gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return webGLPixels;
        } else {
          return this.textureBuffer.canvas.getContext('2d').getImageData(x, y, 1, 1).data;
        }
      };
    }, {
      "../const": 22,
      "../math": 32,
      "../renderers/canvas/utils/CanvasBuffer": 44,
      "../renderers/webgl/managers/FilterManager": 53,
      "../renderers/webgl/utils/RenderTarget": 64,
      "./BaseTexture": 69,
      "./Texture": 71
    }],
    71: [function(require, module, exports) {
      var BaseTexture = require('./BaseTexture'),
          VideoBaseTexture = require('./VideoBaseTexture'),
          TextureUvs = require('./TextureUvs'),
          EventEmitter = require('eventemitter3'),
          math = require('../math'),
          utils = require('../utils');
      function Texture(baseTexture, frame, crop, trim, rotate) {
        EventEmitter.call(this);
        this.noFrame = false;
        if (!frame) {
          this.noFrame = true;
          frame = new math.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture) {
          baseTexture = baseTexture.baseTexture;
        }
        this.baseTexture = baseTexture;
        this._frame = frame;
        this.trim = trim;
        this.valid = false;
        this.requiresUpdate = false;
        this._uvs = null;
        this.width = 0;
        this.height = 0;
        this.crop = crop || frame;
        this.rotate = !!rotate;
        if (baseTexture.hasLoaded) {
          if (this.noFrame) {
            frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            baseTexture.on('update', this.onBaseTextureUpdated, this);
          }
          this.frame = frame;
        } else {
          baseTexture.once('loaded', this.onBaseTextureLoaded, this);
        }
      }
      Texture.prototype = Object.create(EventEmitter.prototype);
      Texture.prototype.constructor = Texture;
      module.exports = Texture;
      Object.defineProperties(Texture.prototype, {frame: {
          get: function() {
            return this._frame;
          },
          set: function(frame) {
            this._frame = frame;
            this.noFrame = false;
            this.width = frame.width;
            this.height = frame.height;
            if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)) {
              throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
            }
            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;
            if (this.trim) {
              this.width = this.trim.width;
              this.height = this.trim.height;
              this._frame.width = this.trim.width;
              this._frame.height = this.trim.height;
            } else {
              this.crop = frame;
            }
            if (this.valid) {
              this._updateUvs();
            }
          }
        }});
      Texture.prototype.update = function() {
        this.baseTexture.update();
      };
      Texture.prototype.onBaseTextureLoaded = function(baseTexture) {
        if (this.noFrame) {
          this.frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        } else {
          this.frame = this._frame;
        }
        this.emit('update', this);
      };
      Texture.prototype.onBaseTextureUpdated = function(baseTexture) {
        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;
        this.emit('update', this);
      };
      Texture.prototype.destroy = function(destroyBase) {
        if (this.baseTexture) {
          if (destroyBase) {
            this.baseTexture.destroy();
          }
          this.baseTexture.off('update', this.onBaseTextureUpdated, this);
          this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);
          this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.crop = null;
        this.valid = false;
      };
      Texture.prototype.clone = function() {
        return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);
      };
      Texture.prototype._updateUvs = function() {
        if (!this._uvs) {
          this._uvs = new TextureUvs();
        }
        this._uvs.set(this.crop, this.baseTexture, this.rotate);
      };
      Texture.fromImage = function(imageUrl, crossorigin, scaleMode) {
        var texture = utils.TextureCache[imageUrl];
        if (!texture) {
          texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
          utils.TextureCache[imageUrl] = texture;
        }
        return texture;
      };
      Texture.fromFrame = function(frameId) {
        var texture = utils.TextureCache[frameId];
        if (!texture) {
          throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
        }
        return texture;
      };
      Texture.fromCanvas = function(canvas, scaleMode) {
        return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));
      };
      Texture.fromVideo = function(video, scaleMode) {
        if (typeof video === 'string') {
          return Texture.fromVideoUrl(video, scaleMode);
        } else {
          return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));
        }
      };
      Texture.fromVideoUrl = function(videoUrl, scaleMode) {
        return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));
      };
      Texture.addTextureToCache = function(texture, id) {
        utils.TextureCache[id] = texture;
      };
      Texture.removeTextureFromCache = function(id) {
        var texture = utils.TextureCache[id];
        delete utils.TextureCache[id];
        delete utils.BaseTextureCache[id];
        return texture;
      };
      Texture.EMPTY = new Texture(new BaseTexture());
    }, {
      "../math": 32,
      "../utils": 76,
      "./BaseTexture": 69,
      "./TextureUvs": 72,
      "./VideoBaseTexture": 73,
      eventemitter3: 11
    }],
    72: [function(require, module, exports) {
      function TextureUvs() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
      }
      module.exports = TextureUvs;
      TextureUvs.prototype.set = function(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;
        if (rotate) {
          this.x0 = (frame.x + frame.height) / tw;
          this.y0 = frame.y / th;
          this.x1 = (frame.x + frame.height) / tw;
          this.y1 = (frame.y + frame.width) / th;
          this.x2 = frame.x / tw;
          this.y2 = (frame.y + frame.width) / th;
          this.x3 = frame.x / tw;
          this.y3 = frame.y / th;
        } else {
          this.x0 = frame.x / tw;
          this.y0 = frame.y / th;
          this.x1 = (frame.x + frame.width) / tw;
          this.y1 = frame.y / th;
          this.x2 = (frame.x + frame.width) / tw;
          this.y2 = (frame.y + frame.height) / th;
          this.x3 = frame.x / tw;
          this.y3 = (frame.y + frame.height) / th;
        }
      };
    }, {}],
    73: [function(require, module, exports) {
      var BaseTexture = require('./BaseTexture'),
          utils = require('../utils');
      function VideoBaseTexture(source, scaleMode) {
        if (!source) {
          throw new Error('No video source element specified.');
        }
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
          source.complete = true;
        }
        BaseTexture.call(this, source, scaleMode);
        this.autoUpdate = false;
        this._onUpdate = this._onUpdate.bind(this);
        this._onCanPlay = this._onCanPlay.bind(this);
        if (!source.complete) {
          source.addEventListener('canplay', this._onCanPlay);
          source.addEventListener('canplaythrough', this._onCanPlay);
          source.addEventListener('play', this._onPlayStart.bind(this));
          source.addEventListener('pause', this._onPlayStop.bind(this));
        }
        this.__loaded = false;
      }
      VideoBaseTexture.prototype = Object.create(BaseTexture.prototype);
      VideoBaseTexture.prototype.constructor = VideoBaseTexture;
      module.exports = VideoBaseTexture;
      VideoBaseTexture.prototype._onUpdate = function() {
        if (this.autoUpdate) {
          window.requestAnimationFrame(this._onUpdate);
          this.update();
        }
      };
      VideoBaseTexture.prototype._onPlayStart = function() {
        if (!this.autoUpdate) {
          window.requestAnimationFrame(this._onUpdate);
          this.autoUpdate = true;
        }
      };
      VideoBaseTexture.prototype._onPlayStop = function() {
        this.autoUpdate = false;
      };
      VideoBaseTexture.prototype._onCanPlay = function() {
        this.hasLoaded = true;
        if (this.source) {
          this.source.removeEventListener('canplay', this._onCanPlay);
          this.source.removeEventListener('canplaythrough', this._onCanPlay);
          this.width = this.source.videoWidth;
          this.height = this.source.videoHeight;
          this.source.play();
          if (!this.__loaded) {
            this.__loaded = true;
            this.emit('loaded', this);
          }
        }
      };
      VideoBaseTexture.prototype.destroy = function() {
        if (this.source && this.source._pixiId) {
          delete utils.BaseTextureCache[this.source._pixiId];
          delete this.source._pixiId;
        }
        BaseTexture.prototype.destroy.call(this);
      };
      VideoBaseTexture.fromVideo = function(video, scaleMode) {
        if (!video._pixiId) {
          video._pixiId = 'video_' + utils.uid();
        }
        var baseTexture = utils.BaseTextureCache[video._pixiId];
        if (!baseTexture) {
          baseTexture = new VideoBaseTexture(video, scaleMode);
          utils.BaseTextureCache[video._pixiId] = baseTexture;
        }
        return baseTexture;
      };
      VideoBaseTexture.fromUrl = function(videoSrc, scaleMode) {
        var video = document.createElement('video');
        if (Array.isArray(videoSrc)) {
          for (var i = 0; i < videoSrc.length; ++i) {
            video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
          }
        } else {
          video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
        }
        video.load();
        video.play();
        return VideoBaseTexture.fromVideo(video, scaleMode);
      };
      VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;
      function createSource(path, type) {
        if (!type) {
          type = 'video/' + path.substr(path.lastIndexOf('.') + 1);
        }
        var source = document.createElement('source');
        source.src = path;
        source.type = type;
        return source;
      }
    }, {
      "../utils": 76,
      "./BaseTexture": 69
    }],
    74: [function(require, module, exports) {
      var CONST = require('../const'),
          EventEmitter = require('eventemitter3'),
          TICK = 'tick';
      function Ticker() {
        var _this = this;
        this._tick = function _tick(time) {
          _this._requestId = null;
          if (_this.started) {
            _this.update(time);
            if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true)) {
              _this._requestId = requestAnimationFrame(_this._tick);
            }
          }
        };
        this._emitter = new EventEmitter();
        this._requestId = null;
        this._maxElapsedMS = 100;
        this.autoStart = false;
        this.deltaTime = 1;
        this.elapsedMS = 1 / CONST.TARGET_FPMS;
        this.lastTime = 0;
        this.speed = 1;
        this.started = false;
      }
      Object.defineProperties(Ticker.prototype, {
        FPS: {get: function() {
            return 1000 / this.elapsedMS;
          }},
        minFPS: {
          get: function() {
            return 1000 / this._maxElapsedMS;
          },
          set: function(fps) {
            var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);
            this._maxElapsedMS = 1 / minFPMS;
          }
        }
      });
      Ticker.prototype._requestIfNeeded = function _requestIfNeeded() {
        if (this._requestId === null && this._emitter.listeners(TICK, true)) {
          this.lastTime = performance.now();
          this._requestId = requestAnimationFrame(this._tick);
        }
      };
      Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      };
      Ticker.prototype._startIfPossible = function _startIfPossible() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      };
      Ticker.prototype.add = function add(fn, context) {
        this._emitter.on(TICK, fn, context);
        this._startIfPossible();
        return this;
      };
      Ticker.prototype.addOnce = function addOnce(fn, context) {
        this._emitter.once(TICK, fn, context);
        this._startIfPossible();
        return this;
      };
      Ticker.prototype.remove = function remove(fn, context) {
        this._emitter.off(TICK, fn, context);
        if (!this._emitter.listeners(TICK, true)) {
          this._cancelIfNeeded();
        }
        return this;
      };
      Ticker.prototype.start = function start() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      };
      Ticker.prototype.stop = function stop() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      };
      Ticker.prototype.update = function update(currentTime) {
        var elapsedMS;
        currentTime = currentTime || performance.now();
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed;
        this._emitter.emit(TICK, this.deltaTime);
        this.lastTime = currentTime;
      };
      module.exports = Ticker;
    }, {
      "../const": 22,
      eventemitter3: 11
    }],
    75: [function(require, module, exports) {
      var Ticker = require('./Ticker');
      var shared = new Ticker();
      shared.autoStart = true;
      module.exports = {
        shared: shared,
        Ticker: Ticker
      };
    }, {"./Ticker": 74}],
    76: [function(require, module, exports) {
      var CONST = require('../const');
      var utils = module.exports = {
        _uid: 0,
        _saidHello: false,
        pluginTarget: require('./pluginTarget'),
        async: require('async'),
        uid: function() {
          return ++utils._uid;
        },
        hex2rgb: function(hex, out) {
          out = out || [];
          out[0] = (hex >> 16 & 0xFF) / 255;
          out[1] = (hex >> 8 & 0xFF) / 255;
          out[2] = (hex & 0xFF) / 255;
          return out;
        },
        hex2string: function(hex) {
          hex = hex.toString(16);
          hex = '000000'.substr(0, 6 - hex.length) + hex;
          return '#' + hex;
        },
        rgb2hex: function(rgb) {
          return ((rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255);
        },
        canUseNewCanvasBlendModes: function() {
          if (typeof document === 'undefined') {
            return false;
          }
          var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
          var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';
          var magenta = new Image();
          magenta.src = pngHead + 'AP804Oa6' + pngEnd;
          var yellow = new Image();
          yellow.src = pngHead + '/wCKxvRF' + pngEnd;
          var canvas = document.createElement('canvas');
          canvas.width = 6;
          canvas.height = 1;
          var context = canvas.getContext('2d');
          context.globalCompositeOperation = 'multiply';
          context.drawImage(magenta, 0, 0);
          context.drawImage(yellow, 2, 0);
          var data = context.getImageData(2, 0, 1, 1).data;
          return (data[0] === 255 && data[1] === 0 && data[2] === 0);
        },
        getNextPowerOfTwo: function(number) {
          if (number > 0 && (number & (number - 1)) === 0) {
            return number;
          } else {
            var result = 1;
            while (result < number) {
              result <<= 1;
            }
            return result;
          }
        },
        isPowerOfTwo: function(width, height) {
          return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
        },
        getResolutionOfUrl: function(url) {
          var resolution = CONST.RETINA_PREFIX.exec(url);
          if (resolution) {
            return parseFloat(resolution[1]);
          }
          return 1;
        },
        sayHello: function(type) {
          if (utils._saidHello) {
            return;
          }
          if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
            var args = ['\n %c %c %c Pixi.js ' + CONST.VERSION + ' - ✰ ' + type + ' ✰  %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n', 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;'];
            window.console.log.apply(console, args);
          } else if (window.console) {
            window.console.log('Pixi.js ' + CONST.VERSION + ' - ' + type + ' - http://www.pixijs.com/');
          }
          utils._saidHello = true;
        },
        isWebGLSupported: function() {
          var contextOptions = {stencil: true};
          try {
            if (!window.WebGLRenderingContext) {
              return false;
            }
            var canvas = document.createElement('canvas'),
                gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
            return !!(gl && gl.getContextAttributes().stencil);
          } catch (e) {
            return false;
          }
        },
        TextureCache: {},
        BaseTextureCache: {}
      };
    }, {
      "../const": 22,
      "./pluginTarget": 77,
      async: 2
    }],
    77: [function(require, module, exports) {
      function pluginTarget(obj) {
        obj.__plugins = {};
        obj.registerPlugin = function(pluginName, ctor) {
          obj.__plugins[pluginName] = ctor;
        };
        obj.prototype.initPlugins = function() {
          this.plugins = this.plugins || {};
          for (var o in obj.__plugins) {
            this.plugins[o] = new (obj.__plugins[o])(this);
          }
        };
        obj.prototype.destroyPlugins = function() {
          for (var o in this.plugins) {
            this.plugins[o].destroy();
            this.plugins[o] = null;
          }
          this.plugins = null;
        };
      }
      module.exports = {mixin: function mixin(obj) {
          pluginTarget(obj);
        }};
    }, {}],
    78: [function(require, module, exports) {
      var core = require('./core'),
          mesh = require('./mesh'),
          extras = require('./extras'),
          filters = require('./filters');
      core.SpriteBatch = function() {
        throw new ReferenceError('SpriteBatch does not exist any more, please use the new ParticleContainer instead.');
      };
      core.AssetLoader = function() {
        throw new ReferenceError('The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.');
      };
      Object.defineProperties(core, {
        Stage: {get: function() {
            console.warn('You do not need to use a PIXI Stage any more, you can simply render any container.');
            return core.Container;
          }},
        DisplayObjectContainer: {get: function() {
            console.warn('DisplayObjectContainer has been shortened to Container, please use Container from now on.');
            return core.Container;
          }},
        Strip: {get: function() {
            console.warn('The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on.');
            return mesh.Mesh;
          }},
        Rope: {get: function() {
            console.warn('The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on.');
            return mesh.Rope;
          }},
        MovieClip: {get: function() {
            console.warn('The MovieClip class has been moved to extras.MovieClip, please use extras.MovieClip from now on.');
            return extras.MovieClip;
          }},
        TilingSprite: {get: function() {
            console.warn('The TilingSprite class has been moved to extras.TilingSprite, please use extras.TilingSprite from now on.');
            return extras.TilingSprite;
          }},
        BitmapText: {get: function() {
            console.warn('The BitmapText class has been moved to extras.BitmapText, please use extras.BitmapText from now on.');
            return extras.BitmapText;
          }},
        blendModes: {get: function() {
            console.warn('The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on.');
            return core.BLEND_MODES;
          }},
        scaleModes: {get: function() {
            console.warn('The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on.');
            return core.SCALE_MODES;
          }},
        BaseTextureCache: {get: function() {
            console.warn('The BaseTextureCache class has been moved to utils.BaseTextureCache, please use utils.BaseTextureCache from now on.');
            return core.utils.BaseTextureCache;
          }},
        TextureCache: {get: function() {
            console.warn('The TextureCache class has been moved to utils.TextureCache, please use utils.TextureCache from now on.');
            return core.utils.TextureCache;
          }},
        math: {get: function() {
            console.warn('The math namespace is deprecated, please access members already accessible on PIXI.');
            return core;
          }}
      });
      core.Sprite.prototype.setTexture = function(texture) {
        this.texture = texture;
        console.warn('setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;');
      };
      extras.BitmapText.prototype.setText = function(text) {
        this.text = text;
        console.warn('setText is now deprecated, please use the text property, e.g : myBitmapText.text = \'my text\';');
      };
      core.Text.prototype.setText = function(text) {
        this.text = text;
        console.warn('setText is now deprecated, please use the text property, e.g : myText.text = \'my text\';');
      };
      core.Text.prototype.setStyle = function(style) {
        this.style = style;
        console.warn('setStyle is now deprecated, please use the style property, e.g : myText.style = style;');
      };
      core.Texture.prototype.setFrame = function(frame) {
        this.frame = frame;
        console.warn('setFrame is now deprecated, please use the frame property, e.g : myTexture.frame = frame;');
      };
      Object.defineProperties(filters, {
        AbstractFilter: {get: function() {
            console.warn('filters.AbstractFilter is an undocumented alias, please use AbstractFilter from now on.');
            return core.AbstractFilter;
          }},
        FXAAFilter: {get: function() {
            console.warn('filters.FXAAFilter is an undocumented alias, please use FXAAFilter from now on.');
            return core.FXAAFilter;
          }},
        SpriteMaskFilter: {get: function() {
            console.warn('filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on.');
            return core.SpriteMaskFilter;
          }}
      });
      core.utils.uuid = function() {
        console.warn('utils.uuid() is deprecated, please use utils.uid() from now on.');
        return core.utils.uid();
      };
    }, {
      "./core": 29,
      "./extras": 85,
      "./filters": 102,
      "./mesh": 126
    }],
    79: [function(require, module, exports) {
      var core = require('../core');
      function BitmapText(text, style) {
        core.Container.call(this);
        style = style || {};
        this.textWidth = 0;
        this.textHeight = 0;
        this._glyphs = [];
        this._font = {
          tint: style.tint !== undefined ? style.tint : 0xFFFFFF,
          align: style.align || 'left',
          name: null,
          size: 0
        };
        this.font = style.font;
        this._text = text;
        this.maxWidth = 0;
        this.dirty = false;
        this.updateText();
      }
      BitmapText.prototype = Object.create(core.Container.prototype);
      BitmapText.prototype.constructor = BitmapText;
      module.exports = BitmapText;
      Object.defineProperties(BitmapText.prototype, {
        tint: {
          get: function() {
            return this._font.tint;
          },
          set: function(value) {
            this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;
            this.dirty = true;
          }
        },
        align: {
          get: function() {
            return this._font.align;
          },
          set: function(value) {
            this._font.align = value || 'left';
            this.dirty = true;
          }
        },
        font: {
          get: function() {
            return this._font;
          },
          set: function(value) {
            if (!value) {
              return;
            }
            if (typeof value === 'string') {
              value = value.split(' ');
              this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');
              this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;
            } else {
              this._font.name = value.name;
              this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);
            }
            this.dirty = true;
          }
        },
        text: {
          get: function() {
            return this._text;
          },
          set: function(value) {
            value = value.toString() || ' ';
            if (this._text === value) {
              return;
            }
            this._text = value;
            this.dirty = true;
          }
        }
      });
      BitmapText.prototype.updateText = function() {
        var data = BitmapText.fonts[this._font.name];
        var pos = new core.Point();
        var prevCharCode = null;
        var chars = [];
        var lastLineWidth = 0;
        var maxLineWidth = 0;
        var lineWidths = [];
        var line = 0;
        var scale = this._font.size / data.size;
        var lastSpace = -1;
        for (var i = 0; i < this.text.length; i++) {
          var charCode = this.text.charCodeAt(i);
          lastSpace = /(\s)/.test(this.text.charAt(i)) ? i : lastSpace;
          if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) {
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            line++;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
          }
          if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth) {
            chars.splice(lastSpace, i - lastSpace);
            i = lastSpace;
            lastSpace = -1;
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            line++;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
          }
          var charData = data.chars[charCode];
          if (!charData) {
            continue;
          }
          if (prevCharCode && charData.kerning[prevCharCode]) {
            pos.x += charData.kerning[prevCharCode];
          }
          chars.push({
            texture: charData.texture,
            line: line,
            charCode: charCode,
            position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)
          });
          lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);
          pos.x += charData.xAdvance;
          prevCharCode = charCode;
        }
        lineWidths.push(lastLineWidth);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        var lineAlignOffsets = [];
        for (i = 0; i <= line; i++) {
          var alignOffset = 0;
          if (this._font.align === 'right') {
            alignOffset = maxLineWidth - lineWidths[i];
          } else if (this._font.align === 'center') {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
          }
          lineAlignOffsets.push(alignOffset);
        }
        var lenChars = chars.length;
        var tint = this.tint;
        for (i = 0; i < lenChars; i++) {
          var c = this._glyphs[i];
          if (c) {
            c.texture = chars[i].texture;
          } else {
            c = new core.Sprite(chars[i].texture);
            this._glyphs.push(c);
          }
          c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
          c.position.y = chars[i].position.y * scale;
          c.scale.x = c.scale.y = scale;
          c.tint = tint;
          if (!c.parent) {
            this.addChild(c);
          }
        }
        for (i = lenChars; i < this._glyphs.length; ++i) {
          this.removeChild(this._glyphs[i]);
        }
        this.textWidth = maxLineWidth * scale;
        this.textHeight = (pos.y + data.lineHeight) * scale;
      };
      BitmapText.prototype.updateTransform = function() {
        this.validate();
        this.containerUpdateTransform();
      };
      BitmapText.prototype.getLocalBounds = function() {
        this.validate();
        return core.Container.prototype.getLocalBounds.call(this);
      };
      BitmapText.prototype.validate = function() {
        if (this.dirty) {
          this.updateText();
          this.dirty = false;
        }
      };
      BitmapText.fonts = {};
    }, {"../core": 29}],
    80: [function(require, module, exports) {
      var core = require('../core');
      function MovieClip(textures) {
        core.Sprite.call(this, textures[0]);
        this._textures = textures;
        this.animationSpeed = 1;
        this.loop = true;
        this.onComplete = null;
        this._currentTime = 0;
        this.playing = false;
      }
      MovieClip.prototype = Object.create(core.Sprite.prototype);
      MovieClip.prototype.constructor = MovieClip;
      module.exports = MovieClip;
      Object.defineProperties(MovieClip.prototype, {
        totalFrames: {get: function() {
            return this._textures.length;
          }},
        textures: {
          get: function() {
            return this._textures;
          },
          set: function(value) {
            this._textures = value;
            this.texture = this._textures[Math.floor(this._currentTime) % this._textures.length];
          }
        },
        currentFrame: {get: function() {
            return Math.floor(this._currentTime) % this._textures.length;
          }}
      });
      MovieClip.prototype.stop = function() {
        if (!this.playing) {
          return;
        }
        this.playing = false;
        core.ticker.shared.remove(this.update, this);
      };
      MovieClip.prototype.play = function() {
        if (this.playing) {
          return;
        }
        this.playing = true;
        core.ticker.shared.add(this.update, this);
      };
      MovieClip.prototype.gotoAndStop = function(frameNumber) {
        this.stop();
        this._currentTime = frameNumber;
        var round = Math.floor(this._currentTime);
        this._texture = this._textures[round % this._textures.length];
      };
      MovieClip.prototype.gotoAndPlay = function(frameNumber) {
        this._currentTime = frameNumber;
        this.play();
      };
      MovieClip.prototype.update = function(deltaTime) {
        this._currentTime += this.animationSpeed * deltaTime;
        var floor = Math.floor(this._currentTime);
        if (floor < 0) {
          if (this.loop) {
            this._texture = this._textures[this._textures.length - 1 + floor % this._textures.length];
          } else {
            this.gotoAndStop(0);
            if (this.onComplete) {
              this.onComplete();
            }
          }
        } else if (this.loop || floor < this._textures.length) {
          this._texture = this._textures[floor % this._textures.length];
        } else if (floor >= this._textures.length) {
          this.gotoAndStop(this.textures.length - 1);
          if (this.onComplete) {
            this.onComplete();
          }
        }
      };
      MovieClip.prototype.destroy = function() {
        this.stop();
        core.Sprite.prototype.destroy.call(this);
      };
      MovieClip.fromFrames = function(frames) {
        var textures = [];
        for (var i = 0; i < frames.length; ++i) {
          textures.push(new core.Texture.fromFrame(frames[i]));
        }
        return new MovieClip(textures);
      };
      MovieClip.fromImages = function(images) {
        var textures = [];
        for (var i = 0; i < images.length; ++i) {
          textures.push(new core.Texture.fromImage(images[i]));
        }
        return new MovieClip(textures);
      };
    }, {"../core": 29}],
    81: [function(require, module, exports) {
      var core = require('../core'),
          tempPoint = new core.Point();
      function TilingSprite(texture, width, height) {
        core.Sprite.call(this, texture);
        this.tileScale = new core.Point(1, 1);
        this.tilePosition = new core.Point(0, 0);
        this._width = width || 100;
        this._height = height || 100;
        this._uvs = new core.TextureUvs();
        this._canvasPattern = null;
        this.shader = new core.AbstractFilter(['precision lowp float;', 'attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'attribute vec4 aColor;', 'uniform mat3 projectionMatrix;', 'uniform vec4 uFrame;', 'uniform vec4 uTransform;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vec2 coord = aTextureCoord;', '   coord -= uTransform.xy;', '   coord /= uTransform.zw;', '   vTextureCoord = coord;', '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);', '}'].join('\n'), ['precision lowp float;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'uniform sampler2D uSampler;', 'uniform vec4 uFrame;', 'uniform vec2 uPixelSize;', 'void main(void){', '   vec2 coord = mod(vTextureCoord, uFrame.zw);', '   coord = clamp(coord, uPixelSize, uFrame.zw - uPixelSize);', '   coord += uFrame.xy;', '   gl_FragColor =  texture2D(uSampler, coord) * vColor ;', '}'].join('\n'), {
          uFrame: {
            type: '4fv',
            value: [0, 0, 1, 1]
          },
          uTransform: {
            type: '4fv',
            value: [0, 0, 1, 1]
          },
          uPixelSize: {
            type: '2fv',
            value: [1, 1]
          }
        });
      }
      TilingSprite.prototype = Object.create(core.Sprite.prototype);
      TilingSprite.prototype.constructor = TilingSprite;
      module.exports = TilingSprite;
      Object.defineProperties(TilingSprite.prototype, {
        width: {
          get: function() {
            return this._width;
          },
          set: function(value) {
            this._width = value;
          }
        },
        height: {
          get: function() {
            return this._height;
          },
          set: function(value) {
            this._height = value;
          }
        }
      });
      TilingSprite.prototype._onTextureUpdate = function() {
        return;
      };
      TilingSprite.prototype._renderWebGL = function(renderer) {
        var texture = this._texture;
        if (!texture || !texture._uvs) {
          return;
        }
        var tempUvs = texture._uvs,
            tempWidth = texture._frame.width,
            tempHeight = texture._frame.height,
            tw = texture.baseTexture.width,
            th = texture.baseTexture.height;
        texture._uvs = this._uvs;
        texture._frame.width = this.width;
        texture._frame.height = this.height;
        this.shader.uniforms.uPixelSize.value[0] = 1.0 / tw;
        this.shader.uniforms.uPixelSize.value[1] = 1.0 / th;
        this.shader.uniforms.uFrame.value[0] = tempUvs.x0;
        this.shader.uniforms.uFrame.value[1] = tempUvs.y0;
        this.shader.uniforms.uFrame.value[2] = tempUvs.x1 - tempUvs.x0;
        this.shader.uniforms.uFrame.value[3] = tempUvs.y2 - tempUvs.y0;
        this.shader.uniforms.uTransform.value[0] = (this.tilePosition.x % (tempWidth * this.tileScale.x)) / this._width;
        this.shader.uniforms.uTransform.value[1] = (this.tilePosition.y % (tempHeight * this.tileScale.y)) / this._height;
        this.shader.uniforms.uTransform.value[2] = (tw / this._width) * this.tileScale.x;
        this.shader.uniforms.uTransform.value[3] = (th / this._height) * this.tileScale.y;
        renderer.setObjectRenderer(renderer.plugins.sprite);
        renderer.plugins.sprite.render(this);
        texture._uvs = tempUvs;
        texture._frame.width = tempWidth;
        texture._frame.height = tempHeight;
      };
      TilingSprite.prototype._renderCanvas = function(renderer) {
        var texture = this._texture;
        if (!texture.baseTexture.hasLoaded) {
          return;
        }
        var context = renderer.context,
            transform = this.worldTransform,
            resolution = renderer.resolution,
            baseTexture = texture.baseTexture,
            modX = this.tilePosition.x % (texture._frame.width * this.tileScale.x),
            modY = this.tilePosition.y % (texture._frame.height * this.tileScale.y);
        if (!this._canvasPattern) {
          var tempCanvas = new core.CanvasBuffer(texture._frame.width, texture._frame.height);
          tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x, -texture._frame.y);
          this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');
        }
        context.globalAlpha = this.worldAlpha;
        context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
        context.scale(this.tileScale.x, this.tileScale.y);
        context.translate(modX + (this.anchor.x * -this._width), modY + (this.anchor.y * -this._height));
        if (this.blendMode !== renderer.currentBlendMode) {
          renderer.currentBlendMode = this.blendMode;
          context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];
        }
        context.fillStyle = this._canvasPattern;
        context.fillRect(-modX, -modY, this._width / this.tileScale.x, this._height / this.tileScale.y);
      };
      TilingSprite.prototype.getBounds = function() {
        var width = this._width;
        var height = this._height;
        var w0 = width * (1 - this.anchor.x);
        var w1 = width * -this.anchor.x;
        var h0 = height * (1 - this.anchor.y);
        var h1 = height * -this.anchor.y;
        var worldTransform = this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;
        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;
        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;
        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;
        var minX,
            maxX,
            minY,
            maxY;
        minX = x1;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;
        minY = y1;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;
        maxX = x1;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;
        maxY = y1;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        this._currentBounds = bounds;
        return bounds;
      };
      TilingSprite.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint);
        var width = this._width;
        var height = this._height;
        var x1 = -width * this.anchor.x;
        var y1;
        if (tempPoint.x > x1 && tempPoint.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (tempPoint.y > y1 && tempPoint.y < y1 + height) {
            return true;
          }
        }
        return false;
      };
      TilingSprite.prototype.destroy = function() {
        core.Sprite.prototype.destroy.call(this);
        this.tileScale = null;
        this._tileScaleOffset = null;
        this.tilePosition = null;
        this._uvs = null;
      };
      TilingSprite.fromFrame = function(frameId, width, height) {
        var texture = core.utils.TextureCache[frameId];
        if (!texture) {
          throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this);
        }
        return new TilingSprite(texture, width, height);
      };
      TilingSprite.fromImage = function(imageId, width, height, crossorigin, scaleMode) {
        return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);
      };
    }, {"../core": 29}],
    82: [function(require, module, exports) {
      var core = require('../core'),
          DisplayObject = core.DisplayObject,
          _tempMatrix = new core.Matrix();
      DisplayObject.prototype._cacheAsBitmap = false;
      DisplayObject.prototype._originalRenderWebGL = null;
      DisplayObject.prototype._originalRenderCanvas = null;
      DisplayObject.prototype._originalUpdateTransform = null;
      DisplayObject.prototype._originalHitTest = null;
      DisplayObject.prototype._originalDestroy = null;
      DisplayObject.prototype._cachedSprite = null;
      Object.defineProperties(DisplayObject.prototype, {cacheAsBitmap: {
          get: function() {
            return this._cacheAsBitmap;
          },
          set: function(value) {
            if (this._cacheAsBitmap === value) {
              return;
            }
            this._cacheAsBitmap = value;
            if (value) {
              this._originalRenderWebGL = this.renderWebGL;
              this._originalRenderCanvas = this.renderCanvas;
              this._originalUpdateTransform = this.updateTransform;
              this._originalGetBounds = this.getBounds;
              this._originalDestroy = this.destroy;
              this._originalContainsPoint = this.containsPoint;
              this.renderWebGL = this._renderCachedWebGL;
              this.renderCanvas = this._renderCachedCanvas;
              this.destroy = this._cacheAsBitmapDestroy;
            } else {
              if (this._cachedSprite) {
                this._destroyCachedDisplayObject();
              }
              this.renderWebGL = this._originalRenderWebGL;
              this.renderCanvas = this._originalRenderCanvas;
              this.getBounds = this._originalGetBounds;
              this.destroy = this._originalDestroy;
              this.updateTransform = this._originalUpdateTransform;
              this.containsPoint = this._originalContainsPoint;
            }
          }
        }});
      DisplayObject.prototype._renderCachedWebGL = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
          return;
        }
        this._initCachedDisplayObject(renderer);
        this._cachedSprite.worldAlpha = this.worldAlpha;
        renderer.setObjectRenderer(renderer.plugins.sprite);
        renderer.plugins.sprite.render(this._cachedSprite);
      };
      DisplayObject.prototype._initCachedDisplayObject = function(renderer) {
        if (this._cachedSprite) {
          return;
        }
        renderer.currentRenderer.flush();
        var bounds = this.getLocalBounds().clone();
        if (this._filters) {
          var padding = this._filters[0].padding;
          bounds.x -= padding;
          bounds.y -= padding;
          bounds.width += padding * 2;
          bounds.height += padding * 2;
        }
        var cachedRenderTarget = renderer.currentRenderTarget;
        var stack = renderer.filterManager.filterStack;
        var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);
        var m = _tempMatrix;
        m.tx = -bounds.x;
        m.ty = -bounds.y;
        this.renderWebGL = this._originalRenderWebGL;
        renderTexture.render(this, m, true, true);
        renderer.setRenderTarget(cachedRenderTarget);
        renderer.filterManager.filterStack = stack;
        this.renderWebGL = this._renderCachedWebGL;
        this.updateTransform = this.displayObjectUpdateTransform;
        this.getBounds = this._getCachedBounds;
        this._cachedSprite = new core.Sprite(renderTexture);
        this._cachedSprite.worldTransform = this.worldTransform;
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);
        this.updateTransform();
        this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
      };
      DisplayObject.prototype._renderCachedCanvas = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
          return;
        }
        this._initCachedDisplayObjectCanvas(renderer);
        this._cachedSprite.worldAlpha = this.worldAlpha;
        this._cachedSprite.renderCanvas(renderer);
      };
      DisplayObject.prototype._initCachedDisplayObjectCanvas = function(renderer) {
        if (this._cachedSprite) {
          return;
        }
        var bounds = this.getLocalBounds();
        var cachedRenderTarget = renderer.context;
        var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);
        var m = _tempMatrix;
        m.tx = -bounds.x;
        m.ty = -bounds.y;
        this.renderCanvas = this._originalRenderCanvas;
        renderTexture.render(this, m, true);
        renderer.context = cachedRenderTarget;
        this.renderCanvas = this._renderCachedCanvas;
        this.updateTransform = this.displayObjectUpdateTransform;
        this.getBounds = this._getCachedBounds;
        this._cachedSprite = new core.Sprite(renderTexture);
        this._cachedSprite.worldTransform = this.worldTransform;
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);
        this.updateTransform();
        this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
      };
      DisplayObject.prototype._getCachedBounds = function() {
        this._cachedSprite._currentBounds = null;
        return this._cachedSprite.getBounds();
      };
      DisplayObject.prototype._destroyCachedDisplayObject = function() {
        this._cachedSprite._texture.destroy();
        this._cachedSprite = null;
      };
      DisplayObject.prototype._cacheAsBitmapDestroy = function() {
        this.cacheAsBitmap = false;
        this._originalDestroy();
      };
    }, {"../core": 29}],
    83: [function(require, module, exports) {
      var core = require('../core');
      core.DisplayObject.prototype.name = null;
      core.Container.prototype.getChildByName = function(name) {
        for (var i = 0; i < this.children.length; i++) {
          if (this.children[i].name === name) {
            return this.children[i];
          }
        }
        return null;
      };
    }, {"../core": 29}],
    84: [function(require, module, exports) {
      var core = require('../core');
      core.DisplayObject.prototype.getGlobalPosition = function(point) {
        point = point || new core.Point();
        if (this.parent) {
          this.displayObjectUpdateTransform();
          point.x = this.worldTransform.tx;
          point.y = this.worldTransform.ty;
        } else {
          point.x = this.position.x;
          point.y = this.position.y;
        }
        return point;
      };
    }, {"../core": 29}],
    85: [function(require, module, exports) {
      require('./cacheAsBitmap');
      require('./getChildByName');
      require('./getGlobalPosition');
      module.exports = {
        MovieClip: require('./MovieClip'),
        TilingSprite: require('./TilingSprite'),
        BitmapText: require('./BitmapText')
      };
    }, {
      "./BitmapText": 79,
      "./MovieClip": 80,
      "./TilingSprite": 81,
      "./cacheAsBitmap": 82,
      "./getChildByName": 83,
      "./getGlobalPosition": 84
    }],
    86: [function(require, module, exports) {
      var core = require('../../core');
      function AsciiFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nuniform vec4 dimensions;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n    {\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy;\n\n    vec3 col = texture2D(uSampler, floor( uv / pixelSize ) * pixelSize / dimensions.xy).rgb;\n\n    float gray = (col.r + col.g + col.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    vec2 p = mod( uv / ( pixelSize * 0.5 ), 2.0) - vec2(1.0);\n    col = col * character(n, p);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", {
          dimensions: {
            type: '4fv',
            value: new Float32Array([0, 0, 0, 0])
          },
          pixelSize: {
            type: '1f',
            value: 8
          }
        });
      }
      AsciiFilter.prototype = Object.create(core.AbstractFilter.prototype);
      AsciiFilter.prototype.constructor = AsciiFilter;
      module.exports = AsciiFilter;
      Object.defineProperties(AsciiFilter.prototype, {size: {
          get: function() {
            return this.uniforms.pixelSize.value;
          },
          set: function(value) {
            this.uniforms.pixelSize.value = value;
          }
        }});
    }, {"../../core": 29}],
    87: [function(require, module, exports) {
      var core = require('../../core'),
          BlurXFilter = require('../blur/BlurXFilter'),
          BlurYFilter = require('../blur/BlurYFilter');
      function BloomFilter() {
        core.AbstractFilter.call(this);
        this.blurXFilter = new BlurXFilter();
        this.blurYFilter = new BlurYFilter();
        this.defaultFilter = new core.AbstractFilter();
      }
      BloomFilter.prototype = Object.create(core.AbstractFilter.prototype);
      BloomFilter.prototype.constructor = BloomFilter;
      module.exports = BloomFilter;
      BloomFilter.prototype.applyFilter = function(renderer, input, output) {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        this.defaultFilter.applyFilter(renderer, input, output);
        this.blurXFilter.applyFilter(renderer, input, renderTarget);
        renderer.blendModeManager.setBlendMode(core.BLEND_MODES.SCREEN);
        this.blurYFilter.applyFilter(renderer, renderTarget, output);
        renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);
        renderer.filterManager.returnRenderTarget(renderTarget);
      };
      Object.defineProperties(BloomFilter.prototype, {
        blur: {
          get: function() {
            return this.blurXFilter.blur;
          },
          set: function(value) {
            this.blurXFilter.blur = this.blurYFilter.blur = value;
          }
        },
        blurX: {
          get: function() {
            return this.blurXFilter.blur;
          },
          set: function(value) {
            this.blurXFilter.blur = value;
          }
        },
        blurY: {
          get: function() {
            return this.blurYFilter.blur;
          },
          set: function(value) {
            this.blurYFilter.blur = value;
          }
        }
      });
    }, {
      "../../core": 29,
      "../blur/BlurXFilter": 90,
      "../blur/BlurYFilter": 91
    }],
    88: [function(require, module, exports) {
      var core = require('../../core');
      function BlurDirFilter(dirX, dirY) {
        core.AbstractFilter.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform float dirX;\nuniform float dirY;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[3];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[0] = aTextureCoord + vec2( (0.004 * strength) * dirX, (0.004 * strength) * dirY );\n    vBlurTexCoords[1] = aTextureCoord + vec2( (0.008 * strength) * dirX, (0.008 * strength) * dirY );\n    vBlurTexCoords[2] = aTextureCoord + vec2( (0.012 * strength) * dirX, (0.012 * strength) * dirY );\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n", "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[3];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vTextureCoord     ) * 0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0]) * 0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1]) * 0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2]) * 0.004431848411938341;\n}\n", {
          strength: {
            type: '1f',
            value: 1
          },
          dirX: {
            type: '1f',
            value: dirX || 0
          },
          dirY: {
            type: '1f',
            value: dirY || 0
          }
        });
        this.defaultFilter = new core.AbstractFilter();
        this.passes = 1;
        this.dirX = dirX || 0;
        this.dirY = dirY || 0;
        this.strength = 4;
      }
      BlurDirFilter.prototype = Object.create(core.AbstractFilter.prototype);
      BlurDirFilter.prototype.constructor = BlurDirFilter;
      module.exports = BlurDirFilter;
      BlurDirFilter.prototype.applyFilter = function(renderer, input, output, clear) {
        var shader = this.getShader(renderer);
        this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);
        if (this.passes === 1) {
          renderer.filterManager.applyFilter(shader, input, output, clear);
        } else {
          var renderTarget = renderer.filterManager.getRenderTarget(true);
          renderer.filterManager.applyFilter(shader, input, renderTarget, clear);
          for (var i = 0; i < this.passes - 2; i++) {
            renderer.filterManager.applyFilter(shader, renderTarget, renderTarget, clear);
          }
          renderer.filterManager.applyFilter(shader, renderTarget, output, clear);
          renderer.filterManager.returnRenderTarget(renderTarget);
        }
      };
      Object.defineProperties(BlurDirFilter.prototype, {
        blur: {
          get: function() {
            return this.strength;
          },
          set: function(value) {
            this.padding = value * 0.5;
            this.strength = value;
          }
        },
        dirX: {
          get: function() {
            return this.dirX;
          },
          set: function(value) {
            this.uniforms.dirX.value = value;
          }
        },
        dirY: {
          get: function() {
            return this.dirY;
          },
          set: function(value) {
            this.uniforms.dirY.value = value;
          }
        }
      });
    }, {"../../core": 29}],
    89: [function(require, module, exports) {
      var core = require('../../core'),
          BlurXFilter = require('./BlurXFilter'),
          BlurYFilter = require('./BlurYFilter');
      function BlurFilter() {
        core.AbstractFilter.call(this);
        this.blurXFilter = new BlurXFilter();
        this.blurYFilter = new BlurYFilter();
      }
      BlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
      BlurFilter.prototype.constructor = BlurFilter;
      module.exports = BlurFilter;
      BlurFilter.prototype.applyFilter = function(renderer, input, output) {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        this.blurXFilter.applyFilter(renderer, input, renderTarget);
        this.blurYFilter.applyFilter(renderer, renderTarget, output);
        renderer.filterManager.returnRenderTarget(renderTarget);
      };
      Object.defineProperties(BlurFilter.prototype, {
        blur: {
          get: function() {
            return this.blurXFilter.blur;
          },
          set: function(value) {
            this.padding = Math.abs(value) * 0.5;
            this.blurXFilter.blur = this.blurYFilter.blur = value;
          }
        },
        passes: {
          get: function() {
            return this.blurXFilter.passes;
          },
          set: function(value) {
            this.blurXFilter.passes = this.blurYFilter.passes = value;
          }
        },
        blurX: {
          get: function() {
            return this.blurXFilter.blur;
          },
          set: function(value) {
            this.blurXFilter.blur = value;
          }
        },
        blurY: {
          get: function() {
            return this.blurYFilter.blur;
          },
          set: function(value) {
            this.blurYFilter.blur = value;
          }
        }
      });
    }, {
      "../../core": 29,
      "./BlurXFilter": 90,
      "./BlurYFilter": 91
    }],
    90: [function(require, module, exports) {
      var core = require('../../core');
      function BlurXFilter() {
        core.AbstractFilter.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n", "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n", {strength: {
            type: '1f',
            value: 1
          }});
        this.passes = 1;
        this.strength = 4;
      }
      BlurXFilter.prototype = Object.create(core.AbstractFilter.prototype);
      BlurXFilter.prototype.constructor = BlurXFilter;
      module.exports = BlurXFilter;
      BlurXFilter.prototype.applyFilter = function(renderer, input, output, clear) {
        var shader = this.getShader(renderer);
        this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);
        if (this.passes === 1) {
          renderer.filterManager.applyFilter(shader, input, output, clear);
        } else {
          var renderTarget = renderer.filterManager.getRenderTarget(true);
          var flip = input;
          var flop = renderTarget;
          for (var i = 0; i < this.passes - 1; i++) {
            renderer.filterManager.applyFilter(shader, flip, flop, true);
            var temp = flop;
            flop = flip;
            flip = temp;
          }
          renderer.filterManager.applyFilter(shader, flip, output, clear);
          renderer.filterManager.returnRenderTarget(renderTarget);
        }
      };
      Object.defineProperties(BlurXFilter.prototype, {blur: {
          get: function() {
            return this.strength;
          },
          set: function(value) {
            this.padding = Math.abs(value) * 0.5;
            this.strength = value;
          }
        }});
    }, {"../../core": 29}],
    91: [function(require, module, exports) {
      var core = require('../../core');
      function BlurYFilter() {
        core.AbstractFilter.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\n\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n", "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n", {strength: {
            type: '1f',
            value: 1
          }});
        this.passes = 1;
        this.strength = 4;
      }
      BlurYFilter.prototype = Object.create(core.AbstractFilter.prototype);
      BlurYFilter.prototype.constructor = BlurYFilter;
      module.exports = BlurYFilter;
      BlurYFilter.prototype.applyFilter = function(renderer, input, output, clear) {
        var shader = this.getShader(renderer);
        this.uniforms.strength.value = Math.abs(this.strength) / 4 / this.passes * (input.frame.height / input.size.height);
        if (this.passes === 1) {
          renderer.filterManager.applyFilter(shader, input, output, clear);
        } else {
          var renderTarget = renderer.filterManager.getRenderTarget(true);
          var flip = input;
          var flop = renderTarget;
          for (var i = 0; i < this.passes - 1; i++) {
            renderer.filterManager.applyFilter(shader, flip, flop, true);
            var temp = flop;
            flop = flip;
            flip = temp;
          }
          renderer.filterManager.applyFilter(shader, flip, output, clear);
          renderer.filterManager.returnRenderTarget(renderTarget);
        }
      };
      Object.defineProperties(BlurYFilter.prototype, {blur: {
          get: function() {
            return this.strength;
          },
          set: function(value) {
            this.padding = Math.abs(value) * 0.5;
            this.strength = value;
          }
        }});
    }, {"../../core": 29}],
    92: [function(require, module, exports) {
      var core = require('../../core');
      function SmartBlurFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 delta;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta * percent);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n", {delta: {
            type: 'v2',
            value: {
              x: 0.1,
              y: 0.0
            }
          }});
      }
      SmartBlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
      SmartBlurFilter.prototype.constructor = SmartBlurFilter;
      module.exports = SmartBlurFilter;
    }, {"../../core": 29}],
    93: [function(require, module, exports) {
      var core = require('../../core');
      function ColorMatrixFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[25];\n\nvoid main(void)\n{\n\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor.r = (m[0] * c.r);\n        gl_FragColor.r += (m[1] * c.g);\n        gl_FragColor.r += (m[2] * c.b);\n        gl_FragColor.r += (m[3] * c.a);\n        gl_FragColor.r += m[4];\n\n    gl_FragColor.g = (m[5] * c.r);\n        gl_FragColor.g += (m[6] * c.g);\n        gl_FragColor.g += (m[7] * c.b);\n        gl_FragColor.g += (m[8] * c.a);\n        gl_FragColor.g += m[9];\n\n     gl_FragColor.b = (m[10] * c.r);\n        gl_FragColor.b += (m[11] * c.g);\n        gl_FragColor.b += (m[12] * c.b);\n        gl_FragColor.b += (m[13] * c.a);\n        gl_FragColor.b += m[14];\n\n     gl_FragColor.a = (m[15] * c.r);\n        gl_FragColor.a += (m[16] * c.g);\n        gl_FragColor.a += (m[17] * c.b);\n        gl_FragColor.a += (m[18] * c.a);\n        gl_FragColor.a += m[19];\n\n}\n", {m: {
            type: '1fv',
            value: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
          }});
      }
      ColorMatrixFilter.prototype = Object.create(core.AbstractFilter.prototype);
      ColorMatrixFilter.prototype.constructor = ColorMatrixFilter;
      module.exports = ColorMatrixFilter;
      ColorMatrixFilter.prototype._loadMatrix = function(matrix, multiply) {
        multiply = !!multiply;
        var newMatrix = matrix;
        if (multiply) {
          this._multiply(newMatrix, this.uniforms.m.value, matrix);
          newMatrix = this._colorMatrix(newMatrix);
        }
        this.uniforms.m.value = newMatrix;
      };
      ColorMatrixFilter.prototype._multiply = function(out, a, b) {
        out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
        out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
        out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
        out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
        out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]);
        out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
        out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
        out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
        out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
        out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]);
        out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
        out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
        out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
        out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
        out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]);
        out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
        out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
        out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
        out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
        out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]);
        return out;
      };
      ColorMatrixFilter.prototype._colorMatrix = function(matrix) {
        var m = new Float32Array(matrix);
        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;
        return m;
      };
      ColorMatrixFilter.prototype.brightness = function(b, multiply) {
        var matrix = [b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.greyscale = function(scale, multiply) {
        var matrix = [scale, scale, scale, 0, 0, scale, scale, scale, 0, 0, scale, scale, scale, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
      ColorMatrixFilter.prototype.blackAndWhite = function(multiply) {
        var matrix = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.hue = function(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cos = Math.cos(rotation),
            sin = Math.sin(rotation);
        var lumR = 0.213,
            lumG = 0.715,
            lumB = 0.072;
        var matrix = [lumR + cos * (1 - lumR) + sin * (-lumR), lumG + cos * (-lumG) + sin * (-lumG), lumB + cos * (-lumB) + sin * (1 - lumB), 0, 0, lumR + cos * (-lumR) + sin * (0.143), lumG + cos * (1 - lumG) + sin * (0.140), lumB + cos * (-lumB) + sin * (-0.283), 0, 0, lumR + cos * (-lumR) + sin * (-(1 - lumR)), lumG + cos * (-lumG) + sin * (lumG), lumB + cos * (1 - lumB) + sin * (lumB), 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.contrast = function(amount, multiply) {
        var v = (amount || 0) + 1;
        var o = -128 * (v - 1);
        var matrix = [v, 0, 0, 0, o, 0, v, 0, 0, o, 0, 0, v, 0, o, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.saturate = function(amount, multiply) {
        var x = (amount || 0) * 2 / 3 + 1;
        var y = ((x - 1) * -0.5);
        var matrix = [x, y, y, 0, 0, y, x, y, 0, 0, y, y, x, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.desaturate = function(multiply) {
        this.saturate(-1);
      };
      ColorMatrixFilter.prototype.negative = function(multiply) {
        var matrix = [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.sepia = function(multiply) {
        var matrix = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.technicolor = function(multiply) {
        var matrix = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.polaroid = function(multiply) {
        var matrix = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.toBGR = function(multiply) {
        var matrix = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.kodachrome = function(multiply) {
        var matrix = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.browni = function(multiply) {
        var matrix = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.vintage = function(multiply) {
        var matrix = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 0xFFE580;
        darkColor = darkColor || 0x338000;
        var lR = ((lightColor >> 16) & 0xFF) / 255;
        var lG = ((lightColor >> 8) & 0xFF) / 255;
        var lB = (lightColor & 0xFF) / 255;
        var dR = ((darkColor >> 16) & 0xFF) / 255;
        var dG = ((darkColor >> 8) & 0xFF) / 255;
        var dB = (darkColor & 0xFF) / 255;
        var matrix = [0.3, 0.59, 0.11, 0, 0, lR, lG, lB, desaturation, 0, dR, dG, dB, toned, 0, lR - dR, lG - dG, lB - dB, 0, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.night = function(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [intensity * (-2.0), -intensity, 0, 0, 0, -intensity, 0, intensity, 0, 0, 0, intensity, intensity * 2.0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.predator = function(amount, multiply) {
        var matrix = [11.224130630493164 * amount, -4.794486999511719 * amount, -2.8746118545532227 * amount, 0 * amount, 0.40342438220977783 * amount, -3.6330697536468506 * amount, 9.193157196044922 * amount, -2.951810836791992 * amount, 0 * amount, -1.316135048866272 * amount, -3.2184197902679443 * amount, -4.2375030517578125 * amount, 7.476448059082031 * amount, 0 * amount, 0.8044459223747253 * amount, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.lsd = function(multiply) {
        var matrix = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter.prototype.reset = function() {
        var matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(matrix, false);
      };
      Object.defineProperties(ColorMatrixFilter.prototype, {matrix: {
          get: function() {
            return this.uniforms.m.value;
          },
          set: function(value) {
            this.uniforms.m.value = value;
          }
        }});
    }, {"../../core": 29}],
    94: [function(require, module, exports) {
      var core = require('../../core');
      function ColorStepFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float step;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    color = floor(color * step) / step;\n\n    gl_FragColor = color;\n}\n", {step: {
            type: '1f',
            value: 5
          }});
      }
      ColorStepFilter.prototype = Object.create(core.AbstractFilter.prototype);
      ColorStepFilter.prototype.constructor = ColorStepFilter;
      module.exports = ColorStepFilter;
      Object.defineProperties(ColorStepFilter.prototype, {step: {
          get: function() {
            return this.uniforms.step.value;
          },
          set: function(value) {
            this.uniforms.step.value = value;
          }
        }});
    }, {"../../core": 29}],
    95: [function(require, module, exports) {
      var core = require('../../core');
      function ConvolutionFilter(matrix, width, height) {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n", {
          matrix: {
            type: '1fv',
            value: new Float32Array(matrix)
          },
          texelSize: {
            type: 'v2',
            value: {
              x: 1 / width,
              y: 1 / height
            }
          }
        });
      }
      ConvolutionFilter.prototype = Object.create(core.AbstractFilter.prototype);
      ConvolutionFilter.prototype.constructor = ConvolutionFilter;
      module.exports = ConvolutionFilter;
      Object.defineProperties(ConvolutionFilter.prototype, {
        matrix: {
          get: function() {
            return this.uniforms.matrix.value;
          },
          set: function(value) {
            this.uniforms.matrix.value = new Float32Array(value);
          }
        },
        width: {
          get: function() {
            return 1 / this.uniforms.texelSize.value.x;
          },
          set: function(value) {
            this.uniforms.texelSize.value.x = 1 / value;
          }
        },
        height: {
          get: function() {
            return 1 / this.uniforms.texelSize.value.y;
          },
          set: function(value) {
            this.uniforms.texelSize.value.y = 1 / value;
          }
        }
      });
    }, {"../../core": 29}],
    96: [function(require, module, exports) {
      var core = require('../../core');
      function CrossHatchFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n");
      }
      CrossHatchFilter.prototype = Object.create(core.AbstractFilter.prototype);
      CrossHatchFilter.prototype.constructor = CrossHatchFilter;
      module.exports = CrossHatchFilter;
    }, {"../../core": 29}],
    97: [function(require, module, exports) {
      var core = require('../../core');
      function DisplacementFilter(sprite) {
        var maskMatrix = new core.Matrix();
        sprite.renderable = false;
        core.AbstractFilter.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMapCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vMapCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n", "precision lowp float;\n\nvarying vec2 vMapCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec2 scale;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nvoid main(void)\n{\n   vec4 original =  texture2D(uSampler, vTextureCoord);\n   vec4 map =  texture2D(mapSampler, vMapCoord);\n\n   map -= 0.5;\n   map.xy *= scale;\n\n   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y));\n}\n", {
          mapSampler: {
            type: 'sampler2D',
            value: sprite.texture
          },
          otherMatrix: {
            type: 'mat3',
            value: maskMatrix.toArray(true)
          },
          scale: {
            type: 'v2',
            value: {
              x: 1,
              y: 1
            }
          }
        });
        this.maskSprite = sprite;
        this.maskMatrix = maskMatrix;
        this.scale = new core.Point(20, 20);
      }
      DisplacementFilter.prototype = Object.create(core.AbstractFilter.prototype);
      DisplacementFilter.prototype.constructor = DisplacementFilter;
      module.exports = DisplacementFilter;
      DisplacementFilter.prototype.applyFilter = function(renderer, input, output) {
        var filterManager = renderer.filterManager;
        filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);
        this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
        this.uniforms.scale.value.x = this.scale.x * (1 / input.frame.width);
        this.uniforms.scale.value.y = this.scale.y * (1 / input.frame.height);
        var shader = this.getShader(renderer);
        filterManager.applyFilter(shader, input, output);
      };
      Object.defineProperties(DisplacementFilter.prototype, {map: {
          get: function() {
            return this.uniforms.mapSampler.value;
          },
          set: function(value) {
            this.uniforms.mapSampler.value = value;
          }
        }});
    }, {"../../core": 29}],
    98: [function(require, module, exports) {
      var core = require('../../core');
      function DotScreenFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 dimensions;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * dimensions.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n", {
          scale: {
            type: '1f',
            value: 1
          },
          angle: {
            type: '1f',
            value: 5
          },
          dimensions: {
            type: '4fv',
            value: [0, 0, 0, 0]
          }
        });
      }
      DotScreenFilter.prototype = Object.create(core.AbstractFilter.prototype);
      DotScreenFilter.prototype.constructor = DotScreenFilter;
      module.exports = DotScreenFilter;
      Object.defineProperties(DotScreenFilter.prototype, {
        scale: {
          get: function() {
            return this.uniforms.scale.value;
          },
          set: function(value) {
            this.uniforms.scale.value = value;
          }
        },
        angle: {
          get: function() {
            return this.uniforms.angle.value;
          },
          set: function(value) {
            this.uniforms.angle.value = value;
          }
        }
      });
    }, {"../../core": 29}],
    99: [function(require, module, exports) {
      var core = require('../../core');
      function BlurYTintFilter() {
        core.AbstractFilter.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform vec2 offset;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition+offset), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\n\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n", "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform vec3 color;\nuniform float alpha;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    vec4 sum = vec4(0.0);\n\n    sum += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    sum += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    sum += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    sum += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    sum += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    sum += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    sum += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n\n    gl_FragColor = vec4( color.rgb * sum.a * alpha, sum.a * alpha );\n}\n", {
          blur: {
            type: '1f',
            value: 1 / 512
          },
          color: {
            type: 'c',
            value: [0, 0, 0]
          },
          alpha: {
            type: '1f',
            value: 0.7
          },
          offset: {
            type: '2f',
            value: [5, 5]
          },
          strength: {
            type: '1f',
            value: 1
          }
        });
        this.passes = 1;
        this.strength = 4;
      }
      BlurYTintFilter.prototype = Object.create(core.AbstractFilter.prototype);
      BlurYTintFilter.prototype.constructor = BlurYTintFilter;
      module.exports = BlurYTintFilter;
      BlurYTintFilter.prototype.applyFilter = function(renderer, input, output, clear) {
        var shader = this.getShader(renderer);
        this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.height / input.size.height);
        if (this.passes === 1) {
          renderer.filterManager.applyFilter(shader, input, output, clear);
        } else {
          var renderTarget = renderer.filterManager.getRenderTarget(true);
          var flip = input;
          var flop = renderTarget;
          for (var i = 0; i < this.passes - 1; i++) {
            renderer.filterManager.applyFilter(shader, flip, flop, clear);
            var temp = flop;
            flop = flip;
            flip = temp;
          }
          renderer.filterManager.applyFilter(shader, flip, output, clear);
          renderer.filterManager.returnRenderTarget(renderTarget);
        }
      };
      Object.defineProperties(BlurYTintFilter.prototype, {blur: {
          get: function() {
            return this.strength;
          },
          set: function(value) {
            this.padding = value * 0.5;
            this.strength = value;
          }
        }});
    }, {"../../core": 29}],
    100: [function(require, module, exports) {
      var core = require('../../core'),
          BlurXFilter = require('../blur/BlurXFilter'),
          BlurYTintFilter = require('./BlurYTintFilter');
      function DropShadowFilter() {
        core.AbstractFilter.call(this);
        this.blurXFilter = new BlurXFilter();
        this.blurYTintFilter = new BlurYTintFilter();
        this.defaultFilter = new core.AbstractFilter();
        this.padding = 30;
        this._dirtyPosition = true;
        this._angle = 45 * Math.PI / 180;
        this._distance = 10;
        this.alpha = 0.75;
        this.hideObject = false;
        this.blendMode = core.BLEND_MODES.MULTIPLY;
      }
      DropShadowFilter.prototype = Object.create(core.AbstractFilter.prototype);
      DropShadowFilter.prototype.constructor = DropShadowFilter;
      module.exports = DropShadowFilter;
      DropShadowFilter.prototype.applyFilter = function(renderer, input, output) {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        if (this._dirtyPosition) {
          this._dirtyPosition = false;
          this.blurYTintFilter.uniforms.offset.value[0] = Math.sin(this._angle) * this._distance;
          this.blurYTintFilter.uniforms.offset.value[1] = Math.cos(this._angle) * this._distance;
        }
        this.blurXFilter.applyFilter(renderer, input, renderTarget);
        renderer.blendModeManager.setBlendMode(this.blendMode);
        this.blurYTintFilter.applyFilter(renderer, renderTarget, output);
        renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);
        if (!this.hideObject) {
          this.defaultFilter.applyFilter(renderer, input, output);
        }
        renderer.filterManager.returnRenderTarget(renderTarget);
      };
      Object.defineProperties(DropShadowFilter.prototype, {
        blur: {
          get: function() {
            return this.blurXFilter.blur;
          },
          set: function(value) {
            this.blurXFilter.blur = this.blurYTintFilter.blur = value;
          }
        },
        blurX: {
          get: function() {
            return this.blurXFilter.blur;
          },
          set: function(value) {
            this.blurXFilter.blur = value;
          }
        },
        blurY: {
          get: function() {
            return this.blurYTintFilter.blur;
          },
          set: function(value) {
            this.blurYTintFilter.blur = value;
          }
        },
        color: {
          get: function() {
            return core.utils.rgb2hex(this.blurYTintFilter.uniforms.color.value);
          },
          set: function(value) {
            this.blurYTintFilter.uniforms.color.value = core.utils.hex2rgb(value);
          }
        },
        alpha: {
          get: function() {
            return this.blurYTintFilter.uniforms.alpha.value;
          },
          set: function(value) {
            this.blurYTintFilter.uniforms.alpha.value = value;
          }
        },
        distance: {
          get: function() {
            return this._distance;
          },
          set: function(value) {
            this._dirtyPosition = true;
            this._distance = value;
          }
        },
        angle: {
          get: function() {
            return this._angle;
          },
          set: function(value) {
            this._dirtyPosition = true;
            this._angle = value;
          }
        }
      });
    }, {
      "../../core": 29,
      "../blur/BlurXFilter": 90,
      "./BlurYTintFilter": 99
    }],
    101: [function(require, module, exports) {
      var core = require('../../core');
      function GrayFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float gray;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);\n}\n", {gray: {
            type: '1f',
            value: 1
          }});
      }
      GrayFilter.prototype = Object.create(core.AbstractFilter.prototype);
      GrayFilter.prototype.constructor = GrayFilter;
      module.exports = GrayFilter;
      Object.defineProperties(GrayFilter.prototype, {gray: {
          get: function() {
            return this.uniforms.gray.value;
          },
          set: function(value) {
            this.uniforms.gray.value = value;
          }
        }});
    }, {"../../core": 29}],
    102: [function(require, module, exports) {
      module.exports = {
        AsciiFilter: require('./ascii/AsciiFilter'),
        BloomFilter: require('./bloom/BloomFilter'),
        BlurFilter: require('./blur/BlurFilter'),
        BlurXFilter: require('./blur/BlurXFilter'),
        BlurYFilter: require('./blur/BlurYFilter'),
        BlurDirFilter: require('./blur/BlurDirFilter'),
        ColorMatrixFilter: require('./color/ColorMatrixFilter'),
        ColorStepFilter: require('./color/ColorStepFilter'),
        ConvolutionFilter: require('./convolution/ConvolutionFilter'),
        CrossHatchFilter: require('./crosshatch/CrossHatchFilter'),
        DisplacementFilter: require('./displacement/DisplacementFilter'),
        DotScreenFilter: require('./dot/DotScreenFilter'),
        GrayFilter: require('./gray/GrayFilter'),
        DropShadowFilter: require('./dropshadow/DropShadowFilter'),
        InvertFilter: require('./invert/InvertFilter'),
        NoiseFilter: require('./noise/NoiseFilter'),
        NormalMapFilter: require('./normal/NormalMapFilter'),
        PixelateFilter: require('./pixelate/PixelateFilter'),
        RGBSplitFilter: require('./rgb/RGBSplitFilter'),
        ShockwaveFilter: require('./shockwave/ShockwaveFilter'),
        SepiaFilter: require('./sepia/SepiaFilter'),
        SmartBlurFilter: require('./blur/SmartBlurFilter'),
        TiltShiftFilter: require('./tiltshift/TiltShiftFilter'),
        TiltShiftXFilter: require('./tiltshift/TiltShiftXFilter'),
        TiltShiftYFilter: require('./tiltshift/TiltShiftYFilter'),
        TwistFilter: require('./twist/TwistFilter')
      };
    }, {
      "./ascii/AsciiFilter": 86,
      "./bloom/BloomFilter": 87,
      "./blur/BlurDirFilter": 88,
      "./blur/BlurFilter": 89,
      "./blur/BlurXFilter": 90,
      "./blur/BlurYFilter": 91,
      "./blur/SmartBlurFilter": 92,
      "./color/ColorMatrixFilter": 93,
      "./color/ColorStepFilter": 94,
      "./convolution/ConvolutionFilter": 95,
      "./crosshatch/CrossHatchFilter": 96,
      "./displacement/DisplacementFilter": 97,
      "./dot/DotScreenFilter": 98,
      "./dropshadow/DropShadowFilter": 100,
      "./gray/GrayFilter": 101,
      "./invert/InvertFilter": 103,
      "./noise/NoiseFilter": 104,
      "./normal/NormalMapFilter": 105,
      "./pixelate/PixelateFilter": 106,
      "./rgb/RGBSplitFilter": 107,
      "./sepia/SepiaFilter": 108,
      "./shockwave/ShockwaveFilter": 109,
      "./tiltshift/TiltShiftFilter": 111,
      "./tiltshift/TiltShiftXFilter": 112,
      "./tiltshift/TiltShiftYFilter": 113,
      "./twist/TwistFilter": 114
    }],
    103: [function(require, module, exports) {
      var core = require('../../core');
      function InvertFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform float invert;\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);\n}\n", {invert: {
            type: '1f',
            value: 1
          }});
      }
      InvertFilter.prototype = Object.create(core.AbstractFilter.prototype);
      InvertFilter.prototype.constructor = InvertFilter;
      module.exports = InvertFilter;
      Object.defineProperties(InvertFilter.prototype, {invert: {
          get: function() {
            return this.uniforms.invert.value;
          },
          set: function(value) {
            this.uniforms.invert.value = value;
          }
        }});
    }, {"../../core": 29}],
    104: [function(require, module, exports) {
      var core = require('../../core');
      function NoiseFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float noise;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    float diff = (rand(vTextureCoord) - 0.5) * noise;\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    gl_FragColor = color;\n}\n", {noise: {
            type: '1f',
            value: 0.5
          }});
      }
      NoiseFilter.prototype = Object.create(core.AbstractFilter.prototype);
      NoiseFilter.prototype.constructor = NoiseFilter;
      module.exports = NoiseFilter;
      Object.defineProperties(NoiseFilter.prototype, {noise: {
          get: function() {
            return this.uniforms.noise.value;
          },
          set: function(value) {
            this.uniforms.noise.value = value;
          }
        }});
    }, {"../../core": 29}],
    105: [function(require, module, exports) {
      var core = require('../../core');
      function NormalMapFilter(texture) {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D displacementMap;\nuniform sampler2D uSampler;\n\nuniform vec4 dimensions;\n\nconst vec2 Resolution = vec2(1.0,1.0);      //resolution of screen\nuniform vec3 LightPos;    //light position, normalized\nconst vec4 LightColor = vec4(1.0, 1.0, 1.0, 1.0);      //light RGBA -- alpha is intensity\nconst vec4 AmbientColor = vec4(1.0, 1.0, 1.0, 0.5);    //ambient RGBA -- alpha is intensity\nconst vec3 Falloff = vec3(0.0, 1.0, 0.2);         //attenuation coefficients\n\nuniform vec3 LightDir; // = vec3(1.0, 0.0, 1.0);\n\nuniform vec2 mapDimensions; // = vec2(256.0, 256.0);\n\n\nvoid main(void)\n{\n    vec2 mapCords = vTextureCoord.xy;\n\n    vec4 color = texture2D(uSampler, vTextureCoord.st);\n    vec3 nColor = texture2D(displacementMap, vTextureCoord.st).rgb;\n\n\n    mapCords *= vec2(dimensions.x/512.0, dimensions.y/512.0);\n\n    mapCords.y *= -1.0;\n    mapCords.y += 1.0;\n\n    // RGBA of our diffuse color\n    vec4 DiffuseColor = texture2D(uSampler, vTextureCoord);\n\n    // RGB of our normal map\n    vec3 NormalMap = texture2D(displacementMap, mapCords).rgb;\n\n    // The delta position of light\n    // vec3 LightDir = vec3(LightPos.xy - (gl_FragCoord.xy / Resolution.xy), LightPos.z);\n    vec3 LightDir = vec3(LightPos.xy - (mapCords.xy), LightPos.z);\n\n    // Correct for aspect ratio\n    // LightDir.x *= Resolution.x / Resolution.y;\n\n    // Determine distance (used for attenuation) BEFORE we normalize our LightDir\n    float D = length(LightDir);\n\n    // normalize our vectors\n    vec3 N = normalize(NormalMap * 2.0 - 1.0);\n    vec3 L = normalize(LightDir);\n\n    // Pre-multiply light color with intensity\n    // Then perform 'N dot L' to determine our diffuse term\n    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);\n\n    // pre-multiply ambient color with intensity\n    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;\n\n    // calculate attenuation\n    float Attenuation = 1.0 / ( Falloff.x + (Falloff.y*D) + (Falloff.z*D*D) );\n\n    // the calculation which brings it all together\n    vec3 Intensity = Ambient + Diffuse * Attenuation;\n    vec3 FinalColor = DiffuseColor.rgb * Intensity;\n    gl_FragColor = vColor * vec4(FinalColor, DiffuseColor.a);\n\n    // gl_FragColor = vec4(1.0, 0.0, 0.0, Attenuation); // vColor * vec4(FinalColor, DiffuseColor.a);\n\n/*\n    // normalise color\n    vec3 normal = normalize(nColor * 2.0 - 1.0);\n\n    vec3 deltaPos = vec3( (light.xy - gl_FragCoord.xy) / resolution.xy, light.z );\n\n    float lambert = clamp(dot(normal, lightDir), 0.0, 1.0);\n\n    float d = sqrt(dot(deltaPos, deltaPos));\n    float att = 1.0 / ( attenuation.x + (attenuation.y*d) + (attenuation.z*d*d) );\n\n    vec3 result = (ambientColor * ambientIntensity) + (lightColor.rgb * lambert) * att;\n    result *= color.rgb;\n\n    gl_FragColor = vec4(result, 1.0);\n*/\n}\n", {
          displacementMap: {
            type: 'sampler2D',
            value: texture
          },
          scale: {
            type: '2f',
            value: {
              x: 15,
              y: 15
            }
          },
          offset: {
            type: '2f',
            value: {
              x: 0,
              y: 0
            }
          },
          mapDimensions: {
            type: '2f',
            value: {
              x: 1,
              y: 1
            }
          },
          dimensions: {
            type: '4f',
            value: [0, 0, 0, 0]
          },
          LightPos: {
            type: '3f',
            value: [0, 1, 0]
          }
        });
        texture.baseTexture._powerOf2 = true;
        if (texture.baseTexture.hasLoaded) {
          this.onTextureLoaded();
        } else {
          texture.baseTexture.once('loaded', this.onTextureLoaded, this);
        }
      }
      NormalMapFilter.prototype = Object.create(core.AbstractFilter.prototype);
      NormalMapFilter.prototype.constructor = NormalMapFilter;
      module.exports = NormalMapFilter;
      NormalMapFilter.prototype.onTextureLoaded = function() {
        this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width;
        this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height;
      };
      Object.defineProperties(NormalMapFilter.prototype, {
        map: {
          get: function() {
            return this.uniforms.displacementMap.value;
          },
          set: function(value) {
            this.uniforms.displacementMap.value = value;
          }
        },
        scale: {
          get: function() {
            return this.uniforms.scale.value;
          },
          set: function(value) {
            this.uniforms.scale.value = value;
          }
        },
        offset: {
          get: function() {
            return this.uniforms.offset.value;
          },
          set: function(value) {
            this.uniforms.offset.value = value;
          }
        }
      });
    }, {"../../core": 29}],
    106: [function(require, module, exports) {
      var core = require('../../core');
      function PixelateFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 dimensions;\nuniform vec2 pixelSize;\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord;\n\n    vec2 size = dimensions.xy / pixelSize;\n\n    vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;\n\n    gl_FragColor = texture2D(uSampler, color);\n}\n", {
          dimensions: {
            type: '4fv',
            value: new Float32Array([0, 0, 0, 0])
          },
          pixelSize: {
            type: 'v2',
            value: {
              x: 10,
              y: 10
            }
          }
        });
      }
      PixelateFilter.prototype = Object.create(core.AbstractFilter.prototype);
      PixelateFilter.prototype.constructor = PixelateFilter;
      module.exports = PixelateFilter;
      Object.defineProperties(PixelateFilter.prototype, {size: {
          get: function() {
            return this.uniforms.pixelSize.value;
          },
          set: function(value) {
            this.uniforms.pixelSize.value = value;
          }
        }});
    }, {"../../core": 29}],
    107: [function(require, module, exports) {
      var core = require('../../core');
      function RGBSplitFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 dimensions;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n", {
          red: {
            type: 'v2',
            value: {
              x: 20,
              y: 20
            }
          },
          green: {
            type: 'v2',
            value: {
              x: -20,
              y: 20
            }
          },
          blue: {
            type: 'v2',
            value: {
              x: 20,
              y: -20
            }
          },
          dimensions: {
            type: '4fv',
            value: [0, 0, 0, 0]
          }
        });
      }
      RGBSplitFilter.prototype = Object.create(core.AbstractFilter.prototype);
      RGBSplitFilter.prototype.constructor = RGBSplitFilter;
      module.exports = RGBSplitFilter;
      Object.defineProperties(RGBSplitFilter.prototype, {
        red: {
          get: function() {
            return this.uniforms.red.value;
          },
          set: function(value) {
            this.uniforms.red.value = value;
          }
        },
        green: {
          get: function() {
            return this.uniforms.green.value;
          },
          set: function(value) {
            this.uniforms.green.value = value;
          }
        },
        blue: {
          get: function() {
            return this.uniforms.blue.value;
          },
          set: function(value) {
            this.uniforms.blue.value = value;
          }
        }
      });
    }, {"../../core": 29}],
    108: [function(require, module, exports) {
      var core = require('../../core');
      function SepiaFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float sepia;\n\nconst mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);\n}\n", {sepia: {
            type: '1f',
            value: 1
          }});
      }
      SepiaFilter.prototype = Object.create(core.AbstractFilter.prototype);
      SepiaFilter.prototype.constructor = SepiaFilter;
      module.exports = SepiaFilter;
      Object.defineProperties(SepiaFilter.prototype, {sepia: {
          get: function() {
            return this.uniforms.sepia.value;
          },
          set: function(value) {
            this.uniforms.sepia.value = value;
          }
        }});
    }, {"../../core": 29}],
    109: [function(require, module, exports) {
      var core = require('../../core');
      function ShockwaveFilter() {
        core.AbstractFilter.call(this, null, "precision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nuniform vec2 center;\nuniform vec3 params; // 10.0, 0.8, 0.1\nuniform float time;\n\nvoid main()\n{\n    vec2 uv = vTextureCoord;\n    vec2 texCoord = uv;\n\n    float dist = distance(uv, center);\n\n    if ( (dist <= (time + params.z)) && (dist >= (time - params.z)) )\n    {\n        float diff = (dist - time);\n        float powDiff = 1.0 - pow(abs(diff*params.x), params.y);\n\n        float diffTime = diff  * powDiff;\n        vec2 diffUV = normalize(uv - center);\n        texCoord = uv + (diffUV * diffTime);\n    }\n\n    gl_FragColor = texture2D(uSampler, texCoord);\n}\n", {
          center: {
            type: 'v2',
            value: {
              x: 0.5,
              y: 0.5
            }
          },
          params: {
            type: 'v3',
            value: {
              x: 10,
              y: 0.8,
              z: 0.1
            }
          },
          time: {
            type: '1f',
            value: 0
          }
        });
      }
      ShockwaveFilter.prototype = Object.create(core.AbstractFilter.prototype);
      ShockwaveFilter.prototype.constructor = ShockwaveFilter;
      module.exports = ShockwaveFilter;
      Object.defineProperties(ShockwaveFilter.prototype, {
        center: {
          get: function() {
            return this.uniforms.center.value;
          },
          set: function(value) {
            this.uniforms.center.value = value;
          }
        },
        params: {
          get: function() {
            return this.uniforms.params.value;
          },
          set: function(value) {
            this.uniforms.params.value = value;
          }
        },
        time: {
          get: function() {
            return this.uniforms.time.value;
          },
          set: function(value) {
            this.uniforms.time.value = value;
          }
        }
      });
    }, {"../../core": 29}],
    110: [function(require, module, exports) {
      var core = require('../../core');
      function TiltShiftAxisFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n", {
          blur: {
            type: '1f',
            value: 100
          },
          gradientBlur: {
            type: '1f',
            value: 600
          },
          start: {
            type: 'v2',
            value: {
              x: 0,
              y: window.innerHeight / 2
            }
          },
          end: {
            type: 'v2',
            value: {
              x: 600,
              y: window.innerHeight / 2
            }
          },
          delta: {
            type: 'v2',
            value: {
              x: 30,
              y: 30
            }
          },
          texSize: {
            type: 'v2',
            value: {
              x: window.innerWidth,
              y: window.innerHeight
            }
          }
        });
        this.updateDelta();
      }
      TiltShiftAxisFilter.prototype = Object.create(core.AbstractFilter.prototype);
      TiltShiftAxisFilter.prototype.constructor = TiltShiftAxisFilter;
      module.exports = TiltShiftAxisFilter;
      TiltShiftAxisFilter.prototype.updateDelta = function() {
        this.uniforms.delta.value.x = 0;
        this.uniforms.delta.value.y = 0;
      };
      Object.defineProperties(TiltShiftAxisFilter.prototype, {
        blur: {
          get: function() {
            return this.uniforms.blur.value;
          },
          set: function(value) {
            this.uniforms.blur.value = value;
          }
        },
        gradientBlur: {
          get: function() {
            return this.uniforms.gradientBlur.value;
          },
          set: function(value) {
            this.uniforms.gradientBlur.value = value;
          }
        },
        start: {
          get: function() {
            return this.uniforms.start.value;
          },
          set: function(value) {
            this.uniforms.start.value = value;
            this.updateDelta();
          }
        },
        end: {
          get: function() {
            return this.uniforms.end.value;
          },
          set: function(value) {
            this.uniforms.end.value = value;
            this.updateDelta();
          }
        }
      });
    }, {"../../core": 29}],
    111: [function(require, module, exports) {
      var core = require('../../core'),
          TiltShiftXFilter = require('./TiltShiftXFilter'),
          TiltShiftYFilter = require('./TiltShiftYFilter');
      function TiltShiftFilter() {
        core.AbstractFilter.call(this);
        this.tiltShiftXFilter = new TiltShiftXFilter();
        this.tiltShiftYFilter = new TiltShiftYFilter();
      }
      TiltShiftFilter.prototype = Object.create(core.AbstractFilter.prototype);
      TiltShiftFilter.prototype.constructor = TiltShiftFilter;
      module.exports = TiltShiftFilter;
      TiltShiftFilter.prototype.applyFilter = function(renderer, input, output) {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        this.tiltShiftXFilter.applyFilter(renderer, input, renderTarget);
        this.tiltShiftYFilter.applyFilter(renderer, renderTarget, output);
        renderer.filterManager.returnRenderTarget(renderTarget);
      };
      Object.defineProperties(TiltShiftFilter.prototype, {
        blur: {
          get: function() {
            return this.tiltShiftXFilter.blur;
          },
          set: function(value) {
            this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = value;
          }
        },
        gradientBlur: {
          get: function() {
            return this.tiltShiftXFilter.gradientBlur;
          },
          set: function(value) {
            this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = value;
          }
        },
        start: {
          get: function() {
            return this.tiltShiftXFilter.start;
          },
          set: function(value) {
            this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = value;
          }
        },
        end: {
          get: function() {
            return this.tiltShiftXFilter.end;
          },
          set: function(value) {
            this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = value;
          }
        }
      });
    }, {
      "../../core": 29,
      "./TiltShiftXFilter": 112,
      "./TiltShiftYFilter": 113
    }],
    112: [function(require, module, exports) {
      var TiltShiftAxisFilter = require('./TiltShiftAxisFilter');
      function TiltShiftXFilter() {
        TiltShiftAxisFilter.call(this);
      }
      TiltShiftXFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
      TiltShiftXFilter.prototype.constructor = TiltShiftXFilter;
      module.exports = TiltShiftXFilter;
      TiltShiftXFilter.prototype.updateDelta = function() {
        var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
        var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
        var d = Math.sqrt(dx * dx + dy * dy);
        this.uniforms.delta.value.x = dx / d;
        this.uniforms.delta.value.y = dy / d;
      };
    }, {"./TiltShiftAxisFilter": 110}],
    113: [function(require, module, exports) {
      var TiltShiftAxisFilter = require('./TiltShiftAxisFilter');
      function TiltShiftYFilter() {
        TiltShiftAxisFilter.call(this);
      }
      TiltShiftYFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
      TiltShiftYFilter.prototype.constructor = TiltShiftYFilter;
      module.exports = TiltShiftYFilter;
      TiltShiftYFilter.prototype.updateDelta = function() {
        var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
        var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
        var d = Math.sqrt(dx * dx + dy * dy);
        this.uniforms.delta.value.x = -dy / d;
        this.uniforms.delta.value.y = dx / d;
      };
    }, {"./TiltShiftAxisFilter": 110}],
    114: [function(require, module, exports) {
      var core = require('../../core');
      function TwistFilter() {
        core.AbstractFilter.call(this, null, "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\n\nvoid main(void)\n{\n   vec2 coord = vTextureCoord - offset;\n   float dist = length(coord);\n\n   if (dist < radius)\n   {\n       float ratio = (radius - dist) / radius;\n       float angleMod = ratio * ratio * angle;\n       float s = sin(angleMod);\n       float c = cos(angleMod);\n       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n   }\n\n   gl_FragColor = texture2D(uSampler, coord+offset);\n}\n", {
          radius: {
            type: '1f',
            value: 0.5
          },
          angle: {
            type: '1f',
            value: 5
          },
          offset: {
            type: 'v2',
            value: {
              x: 0.5,
              y: 0.5
            }
          }
        });
      }
      TwistFilter.prototype = Object.create(core.AbstractFilter.prototype);
      TwistFilter.prototype.constructor = TwistFilter;
      module.exports = TwistFilter;
      Object.defineProperties(TwistFilter.prototype, {
        offset: {
          get: function() {
            return this.uniforms.offset.value;
          },
          set: function(value) {
            this.uniforms.offset.value = value;
          }
        },
        radius: {
          get: function() {
            return this.uniforms.radius.value;
          },
          set: function(value) {
            this.uniforms.radius.value = value;
          }
        },
        angle: {
          get: function() {
            return this.uniforms.angle.value;
          },
          set: function(value) {
            this.uniforms.angle.value = value;
          }
        }
      });
    }, {"../../core": 29}],
    115: [function(require, module, exports) {
      var core = require('../core');
      function InteractionData() {
        this.global = new core.Point();
        this.target = null;
        this.originalEvent = null;
      }
      InteractionData.prototype.constructor = InteractionData;
      module.exports = InteractionData;
      InteractionData.prototype.getLocalPosition = function(displayObject, point, globalPos) {
        var worldTransform = displayObject.worldTransform;
        var global = globalPos ? globalPos : this.global;
        var a00 = worldTransform.a,
            a01 = worldTransform.c,
            a02 = worldTransform.tx,
            a10 = worldTransform.b,
            a11 = worldTransform.d,
            a12 = worldTransform.ty,
            id = 1 / (a00 * a11 + a01 * -a10);
        point = point || new core.Point();
        point.x = a11 * id * global.x + -a01 * id * global.x + (a12 * a01 - a02 * a11) * id;
        point.y = a00 * id * global.y + -a10 * id * global.y + (-a12 * a00 + a02 * a10) * id;
        return point;
      };
    }, {"../core": 29}],
    116: [function(require, module, exports) {
      var core = require('../core'),
          InteractionData = require('./InteractionData');
      Object.assign(core.DisplayObject.prototype, require('./interactiveTarget'));
      function InteractionManager(renderer, options) {
        options = options || {};
        this.renderer = renderer;
        this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;
        this.interactionFrequency = options.interactionFrequency || 10;
        this.mouse = new InteractionData();
        this.eventData = {
          stopped: false,
          target: null,
          type: null,
          data: this.mouse,
          stopPropagation: function() {
            this.stopped = true;
          }
        };
        this.interactiveDataPool = [];
        this.interactionDOMElement = null;
        this.eventsAdded = false;
        this.onMouseUp = this.onMouseUp.bind(this);
        this.processMouseUp = this.processMouseUp.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.processMouseDown = this.processMouseDown.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.processMouseMove = this.processMouseMove.bind(this);
        this.onMouseOut = this.onMouseOut.bind(this);
        this.processMouseOverOut = this.processMouseOverOut.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.processTouchStart = this.processTouchStart.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.processTouchEnd = this.processTouchEnd.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this);
        this.processTouchMove = this.processTouchMove.bind(this);
        this.last = 0;
        this.currentCursorStyle = 'inherit';
        this._tempPoint = new core.Point();
        this.resolution = 1;
        this.setTargetElement(this.renderer.view, this.renderer.resolution);
      }
      InteractionManager.prototype.constructor = InteractionManager;
      module.exports = InteractionManager;
      InteractionManager.prototype.setTargetElement = function(element, resolution) {
        this.removeEvents();
        this.interactionDOMElement = element;
        this.resolution = resolution || 1;
        this.addEvents();
      };
      InteractionManager.prototype.addEvents = function() {
        if (!this.interactionDOMElement) {
          return;
        }
        core.ticker.shared.add(this.update, this);
        if (window.navigator.msPointerEnabled) {
          this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
          this.interactionDOMElement.style['-ms-touch-action'] = 'none';
        }
        window.document.addEventListener('mousemove', this.onMouseMove, true);
        this.interactionDOMElement.addEventListener('mousedown', this.onMouseDown, true);
        this.interactionDOMElement.addEventListener('mouseout', this.onMouseOut, true);
        this.interactionDOMElement.addEventListener('touchstart', this.onTouchStart, true);
        this.interactionDOMElement.addEventListener('touchend', this.onTouchEnd, true);
        this.interactionDOMElement.addEventListener('touchmove', this.onTouchMove, true);
        window.addEventListener('mouseup', this.onMouseUp, true);
        this.eventsAdded = true;
      };
      InteractionManager.prototype.removeEvents = function() {
        if (!this.interactionDOMElement) {
          return;
        }
        core.ticker.shared.remove(this.update);
        if (window.navigator.msPointerEnabled) {
          this.interactionDOMElement.style['-ms-content-zooming'] = '';
          this.interactionDOMElement.style['-ms-touch-action'] = '';
        }
        window.document.removeEventListener('mousemove', this.onMouseMove, true);
        this.interactionDOMElement.removeEventListener('mousedown', this.onMouseDown, true);
        this.interactionDOMElement.removeEventListener('mouseout', this.onMouseOut, true);
        this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
        this.interactionDOMElement.removeEventListener('touchend', this.onTouchEnd, true);
        this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);
        this.interactionDOMElement = null;
        window.removeEventListener('mouseup', this.onMouseUp, true);
        this.eventsAdded = false;
      };
      InteractionManager.prototype.update = function(deltaTime) {
        this._deltaTime += deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        if (!this.interactionDOMElement) {
          return;
        }
        if (this.didMove) {
          this.didMove = false;
          return;
        }
        this.cursor = 'inherit';
        this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, true);
        if (this.currentCursorStyle !== this.cursor) {
          this.currentCursorStyle = this.cursor;
          this.interactionDOMElement.style.cursor = this.cursor;
        }
      };
      InteractionManager.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
        if (!eventData.stopped) {
          eventData.target = displayObject;
          eventData.type = eventString;
          displayObject.emit(eventString, eventData);
          if (displayObject[eventString]) {
            displayObject[eventString](eventData);
          }
        }
      };
      InteractionManager.prototype.mapPositionToPoint = function(point, x, y) {
        var rect = this.interactionDOMElement.getBoundingClientRect();
        point.x = ((x - rect.left) * (this.interactionDOMElement.width / rect.width)) / this.resolution;
        point.y = ((y - rect.top) * (this.interactionDOMElement.height / rect.height)) / this.resolution;
      };
      InteractionManager.prototype.processInteractive = function(point, displayObject, func, hitTest, interactive) {
        if (!displayObject.visible) {
          return false;
        }
        var children = displayObject.children;
        var hit = false;
        interactive = interactive || displayObject.interactive;
        if (displayObject.interactiveChildren) {
          for (var i = children.length - 1; i >= 0; i--) {
            if (!hit && hitTest) {
              hit = this.processInteractive(point, children[i], func, true, interactive);
            } else {
              this.processInteractive(point, children[i], func, false, false);
            }
          }
        }
        if (interactive) {
          if (hitTest) {
            if (displayObject.hitArea) {
              displayObject.worldTransform.applyInverse(point, this._tempPoint);
              hit = displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y);
            } else if (displayObject.containsPoint) {
              hit = displayObject.containsPoint(point);
            }
          }
          if (displayObject.interactive) {
            func(displayObject, hit);
          }
        }
        return hit;
      };
      InteractionManager.prototype.onMouseDown = function(event) {
        this.mouse.originalEvent = event;
        this.eventData.data = this.mouse;
        this.eventData.stopped = false;
        this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);
        if (this.autoPreventDefault) {
          this.mouse.originalEvent.preventDefault();
        }
        this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, true);
      };
      InteractionManager.prototype.processMouseDown = function(displayObject, hit) {
        var e = this.mouse.originalEvent;
        var isRightButton = e.button === 2 || e.which === 3;
        if (hit) {
          displayObject[isRightButton ? '_isRightDown' : '_isLeftDown'] = true;
          this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', this.eventData);
        }
      };
      InteractionManager.prototype.onMouseUp = function(event) {
        this.mouse.originalEvent = event;
        this.eventData.data = this.mouse;
        this.eventData.stopped = false;
        this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);
        this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, true);
      };
      InteractionManager.prototype.processMouseUp = function(displayObject, hit) {
        var e = this.mouse.originalEvent;
        var isRightButton = e.button === 2 || e.which === 3;
        var isDown = isRightButton ? '_isRightDown' : '_isLeftDown';
        if (hit) {
          this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', this.eventData);
          if (displayObject[isDown]) {
            displayObject[isDown] = false;
            this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', this.eventData);
          }
        } else {
          if (displayObject[isDown]) {
            displayObject[isDown] = false;
            this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', this.eventData);
          }
        }
      };
      InteractionManager.prototype.onMouseMove = function(event) {
        this.mouse.originalEvent = event;
        this.eventData.data = this.mouse;
        this.eventData.stopped = false;
        this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);
        this.didMove = true;
        this.cursor = 'inherit';
        this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, true);
        if (this.currentCursorStyle !== this.cursor) {
          this.currentCursorStyle = this.cursor;
          this.interactionDOMElement.style.cursor = this.cursor;
        }
      };
      InteractionManager.prototype.processMouseMove = function(displayObject, hit) {
        this.dispatchEvent(displayObject, 'mousemove', this.eventData);
        this.processMouseOverOut(displayObject, hit);
      };
      InteractionManager.prototype.onMouseOut = function(event) {
        this.mouse.originalEvent = event;
        this.eventData.stopped = false;
        this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);
        this.interactionDOMElement.style.cursor = 'inherit';
        this.mapPositionToPoint(this.mouse.global, event.clientX, event.clientY);
        this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, false);
      };
      InteractionManager.prototype.processMouseOverOut = function(displayObject, hit) {
        if (hit) {
          if (!displayObject._over) {
            displayObject._over = true;
            this.dispatchEvent(displayObject, 'mouseover', this.eventData);
          }
          if (displayObject.buttonMode) {
            this.cursor = displayObject.defaultCursor;
          }
        } else {
          if (displayObject._over) {
            displayObject._over = false;
            this.dispatchEvent(displayObject, 'mouseout', this.eventData);
          }
        }
      };
      InteractionManager.prototype.onTouchStart = function(event) {
        if (this.autoPreventDefault) {
          event.preventDefault();
        }
        var changedTouches = event.changedTouches;
        var cLength = changedTouches.length;
        for (var i = 0; i < cLength; i++) {
          var touchEvent = changedTouches[i];
          var touchData = this.getTouchData(touchEvent);
          touchData.originalEvent = event;
          this.eventData.data = touchData;
          this.eventData.stopped = false;
          this.processInteractive(touchData.global, this.renderer._lastObjectRendered, this.processTouchStart, true);
          this.returnTouchData(touchData);
        }
      };
      InteractionManager.prototype.processTouchStart = function(displayObject, hit) {
        if (hit) {
          displayObject._touchDown = true;
          this.dispatchEvent(displayObject, 'touchstart', this.eventData);
        }
      };
      InteractionManager.prototype.onTouchEnd = function(event) {
        if (this.autoPreventDefault) {
          event.preventDefault();
        }
        var changedTouches = event.changedTouches;
        var cLength = changedTouches.length;
        for (var i = 0; i < cLength; i++) {
          var touchEvent = changedTouches[i];
          var touchData = this.getTouchData(touchEvent);
          touchData.originalEvent = event;
          this.eventData.data = touchData;
          this.eventData.stopped = false;
          this.processInteractive(touchData.global, this.renderer._lastObjectRendered, this.processTouchEnd, true);
          this.returnTouchData(touchData);
        }
      };
      InteractionManager.prototype.processTouchEnd = function(displayObject, hit) {
        if (hit) {
          this.dispatchEvent(displayObject, 'touchend', this.eventData);
          if (displayObject._touchDown) {
            displayObject._touchDown = false;
            this.dispatchEvent(displayObject, 'tap', this.eventData);
          }
        } else {
          if (displayObject._touchDown) {
            displayObject._touchDown = false;
            this.dispatchEvent(displayObject, 'touchendoutside', this.eventData);
          }
        }
      };
      InteractionManager.prototype.onTouchMove = function(event) {
        if (this.autoPreventDefault) {
          event.preventDefault();
        }
        var changedTouches = event.changedTouches;
        var cLength = changedTouches.length;
        for (var i = 0; i < cLength; i++) {
          var touchEvent = changedTouches[i];
          var touchData = this.getTouchData(touchEvent);
          touchData.originalEvent = event;
          this.eventData.data = touchData;
          this.eventData.stopped = false;
          this.processInteractive(touchData.global, this.renderer._lastObjectRendered, this.processTouchMove, false);
          this.returnTouchData(touchData);
        }
      };
      InteractionManager.prototype.processTouchMove = function(displayObject, hit) {
        hit = hit;
        this.dispatchEvent(displayObject, 'touchmove', this.eventData);
      };
      InteractionManager.prototype.getTouchData = function(touchEvent) {
        var touchData = this.interactiveDataPool.pop();
        if (!touchData) {
          touchData = new InteractionData();
        }
        touchData.identifier = touchEvent.identifier;
        this.mapPositionToPoint(touchData.global, touchEvent.clientX, touchEvent.clientY);
        if (navigator.isCocoonJS) {
          touchData.global.x = touchData.global.x / this.resolution;
          touchData.global.y = touchData.global.y / this.resolution;
        }
        touchEvent.globalX = touchData.global.x;
        touchEvent.globalY = touchData.global.y;
        return touchData;
      };
      InteractionManager.prototype.returnTouchData = function(touchData) {
        this.interactiveDataPool.push(touchData);
      };
      InteractionManager.prototype.destroy = function() {
        this.removeEvents();
        this.renderer = null;
        this.mouse = null;
        this.eventData = null;
        this.interactiveDataPool = null;
        this.interactionDOMElement = null;
        this.onMouseUp = null;
        this.processMouseUp = null;
        this.onMouseDown = null;
        this.processMouseDown = null;
        this.onMouseMove = null;
        this.processMouseMove = null;
        this.onMouseOut = null;
        this.processMouseOverOut = null;
        this.onTouchStart = null;
        this.processTouchStart = null;
        this.onTouchEnd = null;
        this.processTouchEnd = null;
        this.onTouchMove = null;
        this.processTouchMove = null;
        this._tempPoint = null;
      };
      core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
      core.CanvasRenderer.registerPlugin('interaction', InteractionManager);
    }, {
      "../core": 29,
      "./InteractionData": 115,
      "./interactiveTarget": 118
    }],
    117: [function(require, module, exports) {
      module.exports = {
        InteractionData: require('./InteractionData'),
        InteractionManager: require('./InteractionManager'),
        interactiveTarget: require('./interactiveTarget')
      };
    }, {
      "./InteractionData": 115,
      "./InteractionManager": 116,
      "./interactiveTarget": 118
    }],
    118: [function(require, module, exports) {
      var interactiveTarget = {
        interactive: false,
        buttonMode: false,
        interactiveChildren: true,
        defaultCursor: 'pointer',
        _over: false,
        _touchDown: false
      };
      module.exports = interactiveTarget;
    }, {}],
    119: [function(require, module, exports) {
      var Resource = require('resource-loader').Resource,
          core = require('../core'),
          extras = require('../extras'),
          path = require('path');
      function parse(resource, texture) {
        var data = {};
        var info = resource.data.getElementsByTagName('info')[0];
        var common = resource.data.getElementsByTagName('common')[0];
        data.font = info.getAttribute('face');
        data.size = parseInt(info.getAttribute('size'), 10);
        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
        data.chars = {};
        var letters = resource.data.getElementsByTagName('char');
        for (var i = 0; i < letters.length; i++) {
          var charCode = parseInt(letters[i].getAttribute('id'), 10);
          var textureRect = new core.Rectangle(parseInt(letters[i].getAttribute('x'), 10) + texture.frame.x, parseInt(letters[i].getAttribute('y'), 10) + texture.frame.y, parseInt(letters[i].getAttribute('width'), 10), parseInt(letters[i].getAttribute('height'), 10));
          data.chars[charCode] = {
            xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
            yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
            xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
            kerning: {},
            texture: new core.Texture(texture.baseTexture, textureRect)
          };
        }
        var kernings = resource.data.getElementsByTagName('kerning');
        for (i = 0; i < kernings.length; i++) {
          var first = parseInt(kernings[i].getAttribute('first'), 10);
          var second = parseInt(kernings[i].getAttribute('second'), 10);
          var amount = parseInt(kernings[i].getAttribute('amount'), 10);
          data.chars[second].kerning[first] = amount;
        }
        resource.bitmapFont = data;
        extras.BitmapText.fonts[data.font] = data;
      }
      module.exports = function() {
        return function(resource, next) {
          if (!resource.data || !resource.isXml) {
            return next();
          }
          if (resource.data.getElementsByTagName('page').length === 0 || resource.data.getElementsByTagName('info').length === 0 || resource.data.getElementsByTagName('info')[0].getAttribute('face') === null) {
            return next();
          }
          var xmlUrl = path.dirname(resource.url);
          if (xmlUrl === '.') {
            xmlUrl = '';
          }
          if (this.baseUrl && xmlUrl) {
            if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') {
              xmlUrl += '/';
            }
            xmlUrl = xmlUrl.replace(this.baseUrl, '');
          }
          if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') {
            xmlUrl += '/';
          }
          var textureUrl = xmlUrl + resource.data.getElementsByTagName('page')[0].getAttribute('file');
          if (core.utils.TextureCache[textureUrl]) {
            parse(resource, core.utils.TextureCache[textureUrl]);
            next();
          } else {
            var loadOptions = {
              crossOrigin: resource.crossOrigin,
              loadType: Resource.LOAD_TYPE.IMAGE
            };
            this.add(resource.name + '_image', textureUrl, loadOptions, function(res) {
              parse(resource, res.texture);
              next();
            });
          }
        };
      };
    }, {
      "../core": 29,
      "../extras": 85,
      path: 3,
      "resource-loader": 18
    }],
    120: [function(require, module, exports) {
      module.exports = {
        Loader: require('./loader'),
        bitmapFontParser: require('./bitmapFontParser'),
        spritesheetParser: require('./spritesheetParser'),
        textureParser: require('./textureParser'),
        Resource: require('resource-loader').Resource
      };
    }, {
      "./bitmapFontParser": 119,
      "./loader": 121,
      "./spritesheetParser": 122,
      "./textureParser": 123,
      "resource-loader": 18
    }],
    121: [function(require, module, exports) {
      var ResourceLoader = require('resource-loader'),
          textureParser = require('./textureParser'),
          spritesheetParser = require('./spritesheetParser'),
          bitmapFontParser = require('./bitmapFontParser');
      function Loader(baseUrl, concurrency) {
        ResourceLoader.call(this, baseUrl, concurrency);
        for (var i = 0; i < Loader._pixiMiddleware.length; ++i) {
          this.use(Loader._pixiMiddleware[i]());
        }
      }
      Loader.prototype = Object.create(ResourceLoader.prototype);
      Loader.prototype.constructor = Loader;
      module.exports = Loader;
      Loader._pixiMiddleware = [ResourceLoader.middleware.parsing.blob, textureParser, spritesheetParser, bitmapFontParser];
      Loader.addPixiMiddleware = function(fn) {
        Loader._pixiMiddleware.push(fn);
      };
      var Resource = ResourceLoader.Resource;
      Resource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);
    }, {
      "./bitmapFontParser": 119,
      "./spritesheetParser": 122,
      "./textureParser": 123,
      "resource-loader": 18
    }],
    122: [function(require, module, exports) {
      var Resource = require('resource-loader').Resource,
          path = require('path'),
          core = require('../core');
      module.exports = function() {
        return function(resource, next) {
          if (!resource.data || !resource.isJson || !resource.data.frames) {
            return next();
          }
          var loadOptions = {
            crossOrigin: resource.crossOrigin,
            loadType: Resource.LOAD_TYPE.IMAGE
          };
          var route = path.dirname(resource.url.replace(this.baseUrl, ''));
          var resolution = core.utils.getResolutionOfUrl(resource.url);
          this.add(resource.name + '_image', route + '/' + resource.data.meta.image, loadOptions, function(res) {
            resource.textures = {};
            var frames = resource.data.frames;
            for (var i in frames) {
              var rect = frames[i].frame;
              if (rect) {
                var size = null;
                var trim = null;
                if (frames[i].rotated) {
                  size = new core.Rectangle(rect.x, rect.y, rect.h, rect.w);
                } else {
                  size = new core.Rectangle(rect.x, rect.y, rect.w, rect.h);
                }
                if (frames[i].trimmed) {
                  trim = new core.Rectangle(frames[i].spriteSourceSize.x / resolution, frames[i].spriteSourceSize.y / resolution, frames[i].sourceSize.w / resolution, frames[i].sourceSize.h / resolution);
                }
                if (frames[i].rotated) {
                  var temp = size.width;
                  size.width = size.height;
                  size.height = temp;
                }
                size.x /= resolution;
                size.y /= resolution;
                size.width /= resolution;
                size.height /= resolution;
                resource.textures[i] = new core.Texture(res.texture.baseTexture, size, size.clone(), trim, frames[i].rotated);
                core.utils.TextureCache[i] = resource.textures[i];
              }
            }
            next();
          });
        };
      };
    }, {
      "../core": 29,
      path: 3,
      "resource-loader": 18
    }],
    123: [function(require, module, exports) {
      var core = require('../core');
      module.exports = function() {
        return function(resource, next) {
          if (resource.data && resource.isImage) {
            resource.texture = new core.Texture(new core.BaseTexture(resource.data, null, core.utils.getResolutionOfUrl(resource.url)));
            core.utils.TextureCache[resource.url] = resource.texture;
          }
          next();
        };
      };
    }, {"../core": 29}],
    124: [function(require, module, exports) {
      var core = require('../core'),
          tempPoint = new core.Point(),
          tempPolygon = new core.Polygon();
      function Mesh(texture, vertices, uvs, indices, drawMode) {
        core.Container.call(this);
        this._texture = null;
        this.uvs = uvs || new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]);
        this.vertices = vertices || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);
        this.indices = indices || new Uint16Array([0, 1, 2, 3]);
        this.dirty = true;
        this.blendMode = core.BLEND_MODES.NORMAL;
        this.canvasPadding = 0;
        this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;
        this.texture = texture;
      }
      Mesh.prototype = Object.create(core.Container.prototype);
      Mesh.prototype.constructor = Mesh;
      module.exports = Mesh;
      Object.defineProperties(Mesh.prototype, {texture: {
          get: function() {
            return this._texture;
          },
          set: function(value) {
            if (this._texture === value) {
              return;
            }
            this._texture = value;
            if (value) {
              if (value.baseTexture.hasLoaded) {
                this._onTextureUpdate();
              } else {
                value.once('update', this._onTextureUpdate, this);
              }
            }
          }
        }});
      Mesh.prototype._renderWebGL = function(renderer) {
        renderer.setObjectRenderer(renderer.plugins.mesh);
        renderer.plugins.mesh.render(this);
      };
      Mesh.prototype._renderCanvas = function(renderer) {
        var context = renderer.context;
        var transform = this.worldTransform;
        if (renderer.roundPixels) {
          context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx | 0, transform.ty | 0);
        } else {
          context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
        }
        if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH) {
          this._renderCanvasTriangleMesh(context);
        } else {
          this._renderCanvasTriangles(context);
        }
      };
      Mesh.prototype._renderCanvasTriangleMesh = function(context) {
        var vertices = this.vertices;
        var uvs = this.uvs;
        var length = vertices.length / 2;
        for (var i = 0; i < length - 2; i++) {
          var index = i * 2;
          this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4));
        }
      };
      Mesh.prototype._renderCanvasTriangles = function(context) {
        var vertices = this.vertices;
        var uvs = this.uvs;
        var indices = this.indices;
        var length = indices.length;
        for (var i = 0; i < length; i += 3) {
          var index0 = indices[i] * 2,
              index1 = indices[i + 1] * 2,
              index2 = indices[i + 2] * 2;
          this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);
        }
      };
      Mesh.prototype._renderCanvasDrawTriangle = function(context, vertices, uvs, index0, index1, index2) {
        var textureSource = this._texture.baseTexture.source;
        var textureWidth = this._texture.baseTexture.width;
        var textureHeight = this._texture.baseTexture.height;
        var x0 = vertices[index0],
            x1 = vertices[index1],
            x2 = vertices[index2];
        var y0 = vertices[index0 + 1],
            y1 = vertices[index1 + 1],
            y2 = vertices[index2 + 1];
        var u0 = uvs[index0] * textureWidth,
            u1 = uvs[index1] * textureWidth,
            u2 = uvs[index2] * textureWidth;
        var v0 = uvs[index0 + 1] * textureHeight,
            v1 = uvs[index1 + 1] * textureHeight,
            v2 = uvs[index2 + 1] * textureHeight;
        if (this.canvasPadding > 0) {
          var paddingX = this.canvasPadding / this.worldTransform.a;
          var paddingY = this.canvasPadding / this.worldTransform.d;
          var centerX = (x0 + x1 + x2) / 3;
          var centerY = (y0 + y1 + y2) / 3;
          var normX = x0 - centerX;
          var normY = y0 - centerY;
          var dist = Math.sqrt(normX * normX + normY * normY);
          x0 = centerX + (normX / dist) * (dist + paddingX);
          y0 = centerY + (normY / dist) * (dist + paddingY);
          normX = x1 - centerX;
          normY = y1 - centerY;
          dist = Math.sqrt(normX * normX + normY * normY);
          x1 = centerX + (normX / dist) * (dist + paddingX);
          y1 = centerY + (normY / dist) * (dist + paddingY);
          normX = x2 - centerX;
          normY = y2 - centerY;
          dist = Math.sqrt(normX * normX + normY * normY);
          x2 = centerX + (normX / dist) * (dist + paddingX);
          y2 = centerY + (normY / dist) * (dist + paddingY);
        }
        context.save();
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.closePath();
        context.clip();
        var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
        var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
        var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
        var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
        var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
        var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
        var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
        context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
        context.drawImage(textureSource, 0, 0);
        context.restore();
      };
      Mesh.prototype.renderMeshFlat = function(Mesh) {
        var context = this.context;
        var vertices = Mesh.vertices;
        var length = vertices.length / 2;
        context.beginPath();
        for (var i = 1; i < length - 2; i++) {
          var index = i * 2;
          var x0 = vertices[index],
              x1 = vertices[index + 2],
              x2 = vertices[index + 4];
          var y0 = vertices[index + 1],
              y1 = vertices[index + 3],
              y2 = vertices[index + 5];
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
          context.lineTo(x2, y2);
        }
        context.fillStyle = '#FF0000';
        context.fill();
        context.closePath();
      };
      Mesh.prototype._onTextureUpdate = function() {
        this.updateFrame = true;
      };
      Mesh.prototype.getBounds = function(matrix) {
        if (!this._currentBounds) {
          var worldTransform = matrix || this.worldTransform;
          var a = worldTransform.a;
          var b = worldTransform.b;
          var c = worldTransform.c;
          var d = worldTransform.d;
          var tx = worldTransform.tx;
          var ty = worldTransform.ty;
          var maxX = -Infinity;
          var maxY = -Infinity;
          var minX = Infinity;
          var minY = Infinity;
          var vertices = this.vertices;
          for (var i = 0,
              n = vertices.length; i < n; i += 2) {
            var rawX = vertices[i],
                rawY = vertices[i + 1];
            var x = (a * rawX) + (c * rawY) + tx;
            var y = (d * rawY) + (b * rawX) + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
          }
          if (minX === -Infinity || maxY === Infinity) {
            return core.Rectangle.EMPTY;
          }
          var bounds = this._bounds;
          bounds.x = minX;
          bounds.width = maxX - minX;
          bounds.y = minY;
          bounds.height = maxY - minY;
          this._currentBounds = bounds;
        }
        return this._currentBounds;
      };
      Mesh.prototype.containsPoint = function(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
          return false;
        }
        this.worldTransform.applyInverse(point, tempPoint);
        var vertices = this.vertices;
        var points = tempPolygon.points;
        var i,
            len;
        if (this.drawMode === Mesh.DRAW_MODES.TRIANGLES) {
          var indices = this.indices;
          len = this.indices.length;
          for (i = 0; i < len; i += 3) {
            var ind0 = indices[i] * 2,
                ind1 = indices[i + 1] * 2,
                ind2 = indices[i + 2] * 2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];
            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
              return true;
            }
          }
        } else {
          len = vertices.length;
          for (i = 0; i < len; i += 6) {
            points[0] = vertices[i];
            points[1] = vertices[i + 1];
            points[2] = vertices[i + 2];
            points[3] = vertices[i + 3];
            points[4] = vertices[i + 4];
            points[5] = vertices[i + 5];
            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
              return true;
            }
          }
        }
        return false;
      };
      Mesh.DRAW_MODES = {
        TRIANGLE_MESH: 0,
        TRIANGLES: 1
      };
    }, {"../core": 29}],
    125: [function(require, module, exports) {
      var Mesh = require('./Mesh');
      var core = require('../core');
      function Rope(texture, points) {
        Mesh.call(this, texture);
        this.points = points;
        this.vertices = new Float32Array(points.length * 4);
        this.uvs = new Float32Array(points.length * 4);
        this.colors = new Float32Array(points.length * 2);
        this.indices = new Uint16Array(points.length * 2);
        this._ready = true;
        this.refresh();
      }
      Rope.prototype = Object.create(Mesh.prototype);
      Rope.prototype.constructor = Rope;
      module.exports = Rope;
      Rope.prototype.refresh = function() {
        var points = this.points;
        if (points.length < 1 || !this._texture._uvs) {
          return;
        }
        var uvs = this.uvs;
        var indices = this.indices;
        var colors = this.colors;
        var textureUvs = this._texture._uvs;
        var offset = new core.Point(textureUvs.x0, textureUvs.y0);
        var factor = new core.Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);
        uvs[0] = 0 + offset.x;
        uvs[1] = 0 + offset.y;
        uvs[2] = 0 + offset.x;
        uvs[3] = 1 * factor.y + offset.y;
        colors[0] = 1;
        colors[1] = 1;
        indices[0] = 0;
        indices[1] = 1;
        var total = points.length,
            point,
            index,
            amount;
        for (var i = 1; i < total; i++) {
          point = points[i];
          index = i * 4;
          amount = i / (total - 1);
          uvs[index] = amount * factor.x + offset.x;
          uvs[index + 1] = 0 + offset.y;
          uvs[index + 2] = amount * factor.x + offset.x;
          uvs[index + 3] = 1 * factor.y + offset.y;
          index = i * 2;
          colors[index] = 1;
          colors[index + 1] = 1;
          index = i * 2;
          indices[index] = index;
          indices[index + 1] = index + 1;
        }
        this.dirty = true;
      };
      Rope.prototype._onTextureUpdate = function() {
        Mesh.prototype._onTextureUpdate.call(this);
        if (this._ready) {
          this.refresh();
        }
      };
      Rope.prototype.updateTransform = function() {
        var points = this.points;
        if (points.length < 1) {
          return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        var vertices = this.vertices;
        var total = points.length,
            point,
            index,
            ratio,
            perpLength,
            num;
        for (var i = 0; i < total; i++) {
          point = points[i];
          index = i * 4;
          if (i < points.length - 1) {
            nextPoint = points[i + 1];
          } else {
            nextPoint = point;
          }
          perpY = -(nextPoint.x - lastPoint.x);
          perpX = nextPoint.y - lastPoint.y;
          ratio = (1 - (i / (total - 1))) * 10;
          if (ratio > 1) {
            ratio = 1;
          }
          perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
          num = this._texture.height / 2;
          perpX /= perpLength;
          perpY /= perpLength;
          perpX *= num;
          perpY *= num;
          vertices[index] = point.x + perpX;
          vertices[index + 1] = point.y + perpY;
          vertices[index + 2] = point.x - perpX;
          vertices[index + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.containerUpdateTransform();
      };
    }, {
      "../core": 29,
      "./Mesh": 124
    }],
    126: [function(require, module, exports) {
      module.exports = {
        Mesh: require('./Mesh'),
        Rope: require('./Rope'),
        MeshRenderer: require('./webgl/MeshRenderer'),
        MeshShader: require('./webgl/MeshShader')
      };
    }, {
      "./Mesh": 124,
      "./Rope": 125,
      "./webgl/MeshRenderer": 127,
      "./webgl/MeshShader": 128
    }],
    127: [function(require, module, exports) {
      var core = require('../../core'),
          Mesh = require('../Mesh');
      function MeshRenderer(renderer) {
        core.ObjectRenderer.call(this, renderer);
        this.indices = new Uint16Array(15000);
        for (var i = 0,
            j = 0; i < 15000; i += 6, j += 4) {
          this.indices[i + 0] = j + 0;
          this.indices[i + 1] = j + 1;
          this.indices[i + 2] = j + 2;
          this.indices[i + 3] = j + 0;
          this.indices[i + 4] = j + 2;
          this.indices[i + 5] = j + 3;
        }
      }
      MeshRenderer.prototype = Object.create(core.ObjectRenderer.prototype);
      MeshRenderer.prototype.constructor = MeshRenderer;
      module.exports = MeshRenderer;
      core.WebGLRenderer.registerPlugin('mesh', MeshRenderer);
      MeshRenderer.prototype.onContextChange = function() {};
      MeshRenderer.prototype.render = function(mesh) {
        if (!mesh._vertexBuffer) {
          this._initWebGL(mesh);
        }
        var renderer = this.renderer,
            gl = renderer.gl,
            texture = mesh._texture.baseTexture,
            shader = renderer.shaderManager.plugins.meshShader;
        var drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;
        renderer.blendModeManager.setBlendMode(mesh.blendMode);
        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, mesh.worldTransform.toArray(true));
        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, renderer.currentRenderTarget.projectionMatrix.toArray(true));
        gl.uniform1f(shader.uniforms.alpha._location, mesh.worldAlpha);
        if (!mesh.dirty) {
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, mesh.vertices);
          gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
          gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
          gl.activeTexture(gl.TEXTURE0);
          if (!texture._glTextures[gl.id]) {
            this.renderer.updateTexture(texture);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
          }
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
          gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, mesh.indices);
        } else {
          mesh.dirty = false;
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);
          gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs, gl.STATIC_DRAW);
          gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
          gl.activeTexture(gl.TEXTURE0);
          if (!texture._glTextures[gl.id]) {
            this.renderer.updateTexture(texture);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
          }
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
        }
        gl.drawElements(drawMode, mesh.indices.length, gl.UNSIGNED_SHORT, 0);
      };
      MeshRenderer.prototype._initWebGL = function(mesh) {
        var gl = this.renderer.gl;
        mesh._vertexBuffer = gl.createBuffer();
        mesh._indexBuffer = gl.createBuffer();
        mesh._uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs, gl.STATIC_DRAW);
        if (mesh.colors) {
          mesh._colorBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh._colorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, mesh.colors, gl.STATIC_DRAW);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
      };
      MeshRenderer.prototype.flush = function() {};
      MeshRenderer.prototype.start = function() {
        var shader = this.renderer.shaderManager.plugins.meshShader;
        this.renderer.shaderManager.setShader(shader);
      };
      MeshRenderer.prototype.destroy = function() {};
    }, {
      "../../core": 29,
      "../Mesh": 124
    }],
    128: [function(require, module, exports) {
      var core = require('../../core');
      function StripShader(shaderManager) {
        core.Shader.call(this, shaderManager, ['precision lowp float;', 'attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'varying vec2 vTextureCoord;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '}'].join('\n'), ['precision lowp float;', 'varying vec2 vTextureCoord;', 'uniform float alpha;', 'uniform sampler2D uSampler;', 'void main(void){', '   gl_FragColor = texture2D(uSampler, vTextureCoord) * alpha ;', '}'].join('\n'), {
          alpha: {
            type: '1f',
            value: 0
          },
          translationMatrix: {
            type: 'mat3',
            value: new Float32Array(9)
          },
          projectionMatrix: {
            type: 'mat3',
            value: new Float32Array(9)
          }
        }, {
          aVertexPosition: 0,
          aTextureCoord: 0
        });
      }
      StripShader.prototype = Object.create(core.Shader.prototype);
      StripShader.prototype.constructor = StripShader;
      module.exports = StripShader;
      core.ShaderManager.registerPlugin('meshShader', StripShader);
    }, {"../../core": 29}],
    129: [function(require, module, exports) {
      if (!Object.assign) {
        Object.assign = require('object-assign');
      }
    }, {"object-assign": 12}],
    130: [function(require, module, exports) {
      require('./Object.assign');
      require('./requestAnimationFrame');
    }, {
      "./Object.assign": 129,
      "./requestAnimationFrame": 131
    }],
    131: [function(require, module, exports) {
      (function(global) {
        if (!(Date.now && Date.prototype.getTime)) {
          Date.now = function now() {
            return new Date().getTime();
          };
        }
        if (!(global.performance && global.performance.now)) {
          var startTime = Date.now();
          if (!global.performance) {
            global.performance = {};
          }
          global.performance.now = function() {
            return Date.now() - startTime;
          };
        }
        var lastTime = Date.now();
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
          global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
          global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] || global[vendors[x] + 'CancelRequestAnimationFrame'];
        }
        if (!global.requestAnimationFrame) {
          global.requestAnimationFrame = function(callback) {
            if (typeof callback !== 'function') {
              throw new TypeError(callback + 'is not a function');
            }
            var currentTime = Date.now(),
                delay = 16 + lastTime - currentTime;
            if (delay < 0) {
              delay = 0;
            }
            lastTime = currentTime;
            return setTimeout(function() {
              lastTime = Date.now();
              callback(performance.now());
            }, delay);
          };
        }
        if (!global.cancelAnimationFrame) {
          global.cancelAnimationFrame = function(id) {
            clearTimeout(id);
          };
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}]
  }, {}, [1])(1);
});

_removeDefine();
})();
System.registerDynamic("assets/lib/hamsterjs/hamster.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    (function(window, document) {
      'use strict';
      var Hamster = function(element) {
        return new Hamster.Instance(element);
      };
      Hamster.SUPPORT = 'wheel';
      Hamster.ADD_EVENT = 'addEventListener';
      Hamster.REMOVE_EVENT = 'removeEventListener';
      Hamster.PREFIX = '';
      Hamster.READY = false;
      Hamster.Instance = function(element) {
        if (!Hamster.READY) {
          Hamster.normalise.browser();
          Hamster.READY = true;
        }
        this.element = element;
        this.handlers = [];
        return this;
      };
      Hamster.Instance.prototype = {
        wheel: function onEvent(handler, useCapture) {
          Hamster.event.add(this, Hamster.SUPPORT, handler, useCapture);
          if (Hamster.SUPPORT === 'DOMMouseScroll') {
            Hamster.event.add(this, 'MozMousePixelScroll', handler, useCapture);
          }
          return this;
        },
        unwheel: function offEvent(handler, useCapture) {
          if (handler === undefined && (handler = this.handlers.slice(-1)[0])) {
            handler = handler.original;
          }
          Hamster.event.remove(this, Hamster.SUPPORT, handler, useCapture);
          if (Hamster.SUPPORT === 'DOMMouseScroll') {
            Hamster.event.remove(this, 'MozMousePixelScroll', handler, useCapture);
          }
          return this;
        }
      };
      Hamster.event = {
        add: function add(hamster, eventName, handler, useCapture) {
          var originalHandler = handler;
          handler = function(originalEvent) {
            if (!originalEvent) {
              originalEvent = window.event;
            }
            var event = Hamster.normalise.event(originalEvent),
                delta = Hamster.normalise.delta(originalEvent);
            return originalHandler(event, delta[0], delta[1], delta[2]);
          };
          hamster.element[Hamster.ADD_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);
          hamster.handlers.push({
            original: originalHandler,
            normalised: handler
          });
        },
        remove: function remove(hamster, eventName, handler, useCapture) {
          var originalHandler = handler,
              lookup = {},
              handlers;
          for (var i = 0,
              len = hamster.handlers.length; i < len; ++i) {
            lookup[hamster.handlers[i].original] = hamster.handlers[i];
          }
          handlers = lookup[originalHandler];
          handler = handlers.normalised;
          hamster.element[Hamster.REMOVE_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);
          for (var h in hamster.handlers) {
            if (hamster.handlers[h] == handlers) {
              hamster.handlers.splice(h, 1);
              break;
            }
          }
        }
      };
      var lowestDelta,
          lowestDeltaXY;
      Hamster.normalise = {
        browser: function normaliseBrowser() {
          if (!('onwheel' in document || document.documentMode >= 9)) {
            Hamster.SUPPORT = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';
          }
          if (!window.addEventListener) {
            Hamster.ADD_EVENT = 'attachEvent';
            Hamster.REMOVE_EVENT = 'detachEvent';
            Hamster.PREFIX = 'on';
          }
        },
        event: function normaliseEvent(originalEvent) {
          var event = {
            originalEvent: originalEvent,
            target: originalEvent.target || originalEvent.srcElement,
            type: 'wheel',
            deltaMode: originalEvent.type === 'MozMousePixelScroll' ? 0 : 1,
            deltaX: 0,
            delatZ: 0,
            preventDefault: function() {
              if (originalEvent.preventDefault) {
                originalEvent.preventDefault();
              } else {
                originalEvent.returnValue = false;
              }
            },
            stopPropagation: function() {
              if (originalEvent.stopPropagation) {
                originalEvent.stopPropagation();
              } else {
                originalEvent.cancelBubble = false;
              }
            }
          };
          if (originalEvent.wheelDelta) {
            event.deltaY = -1 / 40 * originalEvent.wheelDelta;
          }
          if (originalEvent.wheelDeltaX) {
            event.deltaX = -1 / 40 * originalEvent.wheelDeltaX;
          }
          if (originalEvent.detail) {
            event.deltaY = originalEvent.detail;
          }
          return event;
        },
        delta: function normaliseDelta(originalEvent) {
          var delta = 0,
              deltaX = 0,
              deltaY = 0,
              absDelta = 0,
              absDeltaXY = 0,
              fn;
          if (originalEvent.deltaY) {
            deltaY = originalEvent.deltaY * -1;
            delta = deltaY;
          }
          if (originalEvent.deltaX) {
            deltaX = originalEvent.deltaX;
            delta = deltaX * -1;
          }
          if (originalEvent.wheelDelta) {
            delta = originalEvent.wheelDelta;
          }
          if (originalEvent.wheelDeltaY) {
            deltaY = originalEvent.wheelDeltaY;
          }
          if (originalEvent.wheelDeltaX) {
            deltaX = originalEvent.wheelDeltaX * -1;
          }
          if (originalEvent.detail) {
            delta = originalEvent.detail * -1;
          }
          absDelta = Math.abs(delta);
          if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;
          }
          absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
          if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
            lowestDeltaXY = absDeltaXY;
          }
          fn = delta > 0 ? 'floor' : 'ceil';
          delta = Math[fn](delta / lowestDelta);
          deltaX = Math[fn](deltaX / lowestDeltaXY);
          deltaY = Math[fn](deltaY / lowestDeltaXY);
          return [delta, deltaX, deltaY];
        }
      };
      window.Hamster = Hamster;
      if (typeof window.define === 'function' && window.define.amd) {
        window.define('hamster', [], function() {
          return Hamster;
        });
      }
    })(window, window.document);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("assets/lib/polyfills/es6StringPoly/es6StringPoly.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    if (!String.prototype.repeat) {
      (function() {
        'use strict';
        var defineProperty = (function() {
          try {
            var object = {};
            var $defineProperty = Object.defineProperty;
            var result = $defineProperty(object, object, object) && $defineProperty;
          } catch (error) {}
          return result;
        }());
        var repeat = function(count) {
          if (this == null) {
            throw TypeError();
          }
          var string = String(this);
          var n = count ? Number(count) : 0;
          if (n != n) {
            n = 0;
          }
          if (n < 0 || n == Infinity) {
            throw RangeError();
          }
          var result = '';
          while (n) {
            if (n % 2 == 1) {
              result += string;
            }
            if (n > 1) {
              string += string;
            }
            n >>= 1;
          }
          return result;
        };
        if (defineProperty) {
          defineProperty(String.prototype, 'repeat', {
            'value': repeat,
            'configurable': true,
            'writable': true
          });
        } else {
          String.prototype.repeat = repeat;
        }
      }());
    }
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.object.keys.js", ["npm:core-js@1.1.4/library/modules/$.to-object.js", "npm:core-js@1.1.4/library/modules/$.object-sap.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('npm:core-js@1.1.4/library/modules/$.to-object.js');
  $__require('npm:core-js@1.1.4/library/modules/$.object-sap.js')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/fn/object/keys.js", ["npm:core-js@1.1.4/library/modules/es6.object.keys.js", "npm:core-js@1.1.4/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.1.4/library/modules/es6.object.keys.js');
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.core.js').Object.keys;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/core-js/object/keys.js", ["npm:core-js@1.1.4/library/fn/object/keys.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.1.4/library/fn/object/keys.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register('components/map/core/utils/dataManipulation.js', ['npm:babel-runtime@5.8.24/core-js/object/keys.js'], function (_export) {
  var _Object$keys, dataManipulation;

  /*---------------------
  -------- PUBLIC -------
  ----------------------*/
  /**
   * These are utils for manipulating the data, that our classes and functions use.
   *
   * @class utils.dataManipulation
   * @return {Object}      mapObjectsToArray, flattenArrayBy1Level
   */
  function setupDataManipulation() {
    /*---------------------
    ------- API ----------
    --------------------*/
    return {
      mapObjectsToArray: mapObjectsToArray,
      flattenArrayBy1Level: flattenArrayBy1Level
    };

    /*----------------------
    ------- PUBLIC ---------
    ----------------------*/
    /**
     * Changes the data from e.g. getting objects from the map based on coordinate. The data is like this normally:
     * {
     *   units: [{
     *     {... the objects datas ...}
     *   }]
     * }
     * We change it to this:
     * [
     *   [{
     *     {... the objects datas ...}
     *   }]
     * ]
     *
     * @method mapObjectsToArray
     * @param  {Object} objects       Object that holds objects
     * @return {Array}                Returns the transformed array
     */
    function mapObjectsToArray(objects) {
      return _Object$keys(objects).map(function (objGroup) {
        return objects[objGroup];
      });
    }
    /**
     * @method flattenArrayBy1Level
     * @param  {Array} objects
     */
    function flattenArrayBy1Level(objects) {
      var merged = [];

      return merged.concat.apply(merged, objects);
    }
  }
  return {
    setters: [function (_npmBabelRuntime5824CoreJsObjectKeysJs) {
      _Object$keys = _npmBabelRuntime5824CoreJsObjectKeysJs['default'];
    }],
    execute: function () {
      'use strict';

      /*---------------------
      --------- API ---------
      ----------------------*/
      dataManipulation = setupDataManipulation();

      _export('dataManipulation', dataManipulation);
    }
  };
});
System.register("components/map/core/utils/effects.js", [], function (_export) {
  'use strict';

  /*---------------------
  --------- API ---------
  ----------------------*/
  var effects;

  /*---------------------
  -------- PUBLIC -------
  ----------------------*/
  /**
   * This module will hold the most common graphical effects used in the map. It is still very stub as the development
   * hasn't proceeded to this stage yet.
   *
   * @class utils.effects
   * @return {Object}      init, _startDragListener
   */
  function setupEffects() {
    /*---------------------
    ------- API ----------
    --------------------*/
    return {
      dropShadow: dropShadow
    };

    /*----------------------
    ------- PUBLIC ---------
    ----------------------*/
    /**
     * @method dropShadow
     * @param  {Object} options
     */
    function dropShadow() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? { color: "#000000", distance: 5, alpha: 0.5, amgöe: 45, blur: 5 } : arguments[0];

      var shadow = new PIXI.filters.DropShadowFilter();

      shadow.color = options.color;
      shadow.distance = options.distance;
      shadow.alpha = options.alpha;
      shadow.angle = options.angle;
      shadow.blur = options.blur;

      this.filters = [shadow];
    }
  }
  return {
    setters: [],
    execute: function () {
      effects = setupEffects();

      _export("effects", effects);
    }
  };
});
System.register("components/map/core/utils/utils.js", [], function (_export) {
  'use strict';

  /*---------------------
  --------- API ---------
  ----------------------*/
  var mouse, resize, environmentDetection, general;

  /**
   * @class utils.mouse
   * @return {Object}      isRightClick, eventData.getPointerCoords, eventData.getHAMMERPointerCoords, eventMouseCoords
   */
  function setupMouseUtils() {
    return {
      isRightClick: isRightClick,
      eventData: {
        getPointerCoords: getPointerCoords,
        getHAMMERPointerCoords: getHAMMERPointerCoords
      },
      eventMouseCoords: eventMouseCoords
    };

    /**
     * Detects if the mouse click has been the right mouse button
     *
     * @method isRightClick
     * @param {Event} event The event where the click occured
     */
    function isRightClick(event) {
      var rightclick;

      event = event ? event : window.event; /* For IE. */
      if (event.buttons) {
        rightclick = +event.buttons === 2;
      } else if (event.which) {
        rightclick = +event.which === 3;
      } else if (event.button) {
        rightclick = +event.button === 2;
      }

      if (rightclick) {
        return true;
      }

      return false;
    }
    /**
     * @method getPointerCoords
     * @param  {Event} e    Event object
     * @return {Object}
     */
    function getPointerCoords(e) {
      return {
        x: e.offsetX,
        y: e.offsetY
      };
    }
    /**
     * @method getHAMMERPointerCoords
     * @param  {Event} e    Event object
     * @return {Object}
     */
    function getHAMMERPointerCoords(e) {
      return e.center;
    }
    /**
     * @method eventMouseCoords
     * @param  {Event} e    Event object
     * @return {Object}
     */
    function eventMouseCoords(e) {
      var pos = {
        x: 0,
        y: 0
      };

      if (!e) {
        e = window.event;
      }
      if (e.pageX || e.pageY) {
        pos.x = e.pageX;
        pos.y = e.pageY;
      } else if (e.clientX || e.clientY) {
        pos.x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        pos.y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }
      // posx and posy contain the mouse position relative to the document
      // Do something with this information
      return pos;
    }
  }
  /**
   * @class utils.resize
   * @return {Object}      toggleFullScreen, setToFullSize, getWindowSize
   */
  function setupResizeUtils() {
    return {
      toggleFullScreen: toggleFullScreen,
      setToFullSize: setToFullSize,
      getWindowSize: getWindowSize
    };

    /**
     * @method toggleFullScreen
     */
    function toggleFullScreen() {
      var elem = document.body; // Make the body go full screen.
      var isInFullScreen = document.fullScreenElement && document.fullScreenElement !== null || (document.mozFullScreen || document.webkitIsFullScreen);

      /* jshint expr: true */
      isInFullScreen ? cancelFullScreen(document) : requestFullScreen(elem);

      return false;

      /*-------------------------
      --------- PRIVATE ---------
      -------------------------*/
      /* global ActiveXObject */
      function cancelFullScreen(el) {
        var requestMethod = el.cancelFullScreen || el.webkitCancelFullScreen || el.mozCancelFullScreen || el.exitFullscreen;
        if (requestMethod) {
          // cancel full screen.
          requestMethod.call(el);
        } else if (typeof window.ActiveXObject !== "undefined") {
          // Older IE.
          var wscript = new ActiveXObject("WScript.Shell");
          wscript !== null && wscript.SendKeys("{F11}");
        }
      }
      function requestFullScreen(el) {
        // Supports most browsers and their versions.
        var requestMethod = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullScreen;

        if (requestMethod) {
          // Native full screen.
          requestMethod.call(el);
        } else if (typeof window.ActiveXObject !== "undefined") {
          // Older IE.
          var wscript = new ActiveXObject("WScript.Shell");
          wscript !== null && wscript.SendKeys("{F11}");
        }
        return false;
      }
    }
    /**
     * Sets canvas size to maximum width and height on the browser, not using fullscreen
     *
     * @method setToFullSize
     * @param {HTMLElement} context        DOMElement Canvas context
     */
    function setToFullSize(context) {
      return function fullSize() {
        var size = getWindowSize();

        context.canvas.width = size.x;
        context.canvas.height = size.y;
      };
    }
    /**
     * Get browser windows size
     *
     * @method getWindowSize
     * @param {HTMLElement} context        DOMElement Canvas context
     */
    function getWindowSize() {
      return {
        x: window.innerWidth,
        y: window.innerHeight
      };
    }
  }
  /**
   * @class utils.environment
   * @return {Object}      getPixelRatio
   */
  function setupEnvironmentDetection() {
    return {
      getPixelRatio: getPixelRatio //,
      // isMobile,
      // isMobile_detectUserAgent
    };

    /**
     * @method getPixelRatio
     * @requires Canvas element in the DOM. This needs to be found
     * @param  {HTMLElement} canvasElement       HTML canvas element
     * @return {Number}
     */
    function getPixelRatio(canvasElement) {
      var DPR = window.devicePixelRatio || 1;
      var ctx = canvasElement && canvasElement.getContext("2d") || document.createElement('canvas').getContext("2d");
      var bsr = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;

      return DPR / bsr;
    }
  }
  /**
   * @class utils.general
   * @return {Object}      pixelEpsilonEquality
   */
  function setupGeneral() {
    var PIXEL_EPSILON = 0.01;

    return {
      pixelEpsilonEquality: epsilonEquality
    };

    /**
     * @method epsilonEquality
     * @param  {Number} x
     * @param  {Number} y
     */
    function epsilonEquality(x, y) {
      return Math.abs(x) - Math.abs(y) < PIXEL_EPSILON;
    }
  }
  return {
    setters: [],
    execute: function () {
      mouse = setupMouseUtils();

      _export("mouse", mouse);

      resize = setupResizeUtils();

      _export("resize", resize);

      environmentDetection = setupEnvironmentDetection();

      _export("environmentDetection", environmentDetection);

      general = setupGeneral();

      _export("general", general);
    }
  };
});
System.register('components/map/core/utils/index.js', ['components/map/core/utils/dataManipulation.js', 'components/map/core/utils/effects.js', 'components/map/core/utils/utils.js'], function (_export) {

  /* Bundle utils in utils-parent and export them */
  'use strict';var dataManipulation, effects, mouse, resize, environmentDetection, general, utils;
  return {
    setters: [function (_componentsMapCoreUtilsDataManipulationJs) {
      dataManipulation = _componentsMapCoreUtilsDataManipulationJs.dataManipulation;
    }, function (_componentsMapCoreUtilsEffectsJs) {
      effects = _componentsMapCoreUtilsEffectsJs.effects;
    }, function (_componentsMapCoreUtilsUtilsJs) {
      mouse = _componentsMapCoreUtilsUtilsJs.mouse;
      resize = _componentsMapCoreUtilsUtilsJs.resize;
      environmentDetection = _componentsMapCoreUtilsUtilsJs.environmentDetection;
      general = _componentsMapCoreUtilsUtilsJs.general;
    }],
    execute: function () {
      utils = {
        dataManipulation: dataManipulation,
        effects: effects,
        mouse: mouse, resize: resize, environmentDetection: environmentDetection, general: general
      };

      _export('utils', utils);
    }
  };
});
System.register('components/map/core/Objects.js', ['npm:babel-runtime@5.8.24/helpers/get.js', 'npm:babel-runtime@5.8.24/helpers/inherits.js', 'npm:babel-runtime@5.8.24/helpers/create-class.js', 'npm:babel-runtime@5.8.24/helpers/class-call-check.js', 'npm:babel-runtime@5.8.24/core-js/object/assign.js', 'bundles/strippedCoreBundle.js'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, _Object$assign, utils, Object_sprite, ObjectSpriteTerrain, ObjectSpriteUnit;

  return {
    setters: [function (_npmBabelRuntime5824HelpersGetJs) {
      _get = _npmBabelRuntime5824HelpersGetJs['default'];
    }, function (_npmBabelRuntime5824HelpersInheritsJs) {
      _inherits = _npmBabelRuntime5824HelpersInheritsJs['default'];
    }, function (_npmBabelRuntime5824HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5824HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs['default'];
    }, function (_npmBabelRuntime5824CoreJsObjectAssignJs) {
      _Object$assign = _npmBabelRuntime5824CoreJsObjectAssignJs['default'];
    }, function (_bundlesStrippedCoreBundleJs) {
      utils = _bundlesStrippedCoreBundleJs.utils;
    }],
    execute: function () {

      /*-----------------------
      ---------- API ----------
      -----------------------*/
      'use strict';

      /*-----------------------
      --------- IMPORT --------
      -----------------------*/

      Object_sprite = (function (_PIXI$Sprite) {
        _inherits(Object_sprite, _PIXI$Sprite);

        /**
         * The base class of all sprite objects
         *
         * @class Object_sprite
         * @constructor
         * @extends PIXI.Sprite
         * @param {PIXI.Point} coords                         the coordinate where the object is located at, relative to it's parent
         * @param {Object} data                               objects data, that will be used in the game. It will not actually be mainly used in graphical but rather things  like unit-data and city-data presentations etc.
         * @param {Object} options.currFrame       currFrame the current frames number. This is basically the initial image, we can change it later for animation or such
         */

        function Object_sprite() {
          var coord = arguments.length <= 0 || arguments[0] === undefined ? { x: 0, y: 0 } : arguments[0];
          var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
          var options = arguments.length <= 2 || arguments[2] === undefined ? { currentFrame: {} } : arguments[2];

          _classCallCheck(this, Object_sprite);

          var currentFrame = options.currentFrame;

          _get(Object.getPrototypeOf(Object_sprite.prototype), 'constructor', this).call(this, currentFrame);

          /* We need to round the numbers. If there are decimal values, the graphics will get blurry */
          var exactCoords = {
            x: Math.round(coord.x),
            y: Math.round(coord.y)
          };
          this.position.set(exactCoords.x, exactCoords.y);
          /**
           * Name of the object. Used mostly for debugging
           *
           * @attribute
           * @type {String}
           */
          this.name = "Objects_sprite_" + this.id;
          /**
           * Type of the object. Can be used for filtering, ordering or finding correct objects.
           *
           * @attribute
           * @type {String}
           */
          this.type = "None";
          /**
           * Is the object highligtable.
           *
           * @attribute
           * @type {Boolean}
           */
          this.highlightable = true;
          /**
           * Objects custom data. Holds unit statistics and most data. Like unit movement speed etc.
           *
           * @attribute
           * @type {Object}
           */
          this.data = data;
          /**
           * Current frame (from spritesheet) we are showing.
           *
           * @attribute
           * @type {Number}
           */
          this.currentFrame = currentFrame;
          /**
           * Object area width in pixels.
           *
           * @attribute
           * @type {Number}
           */
          this.areaWidth = this.width;
          /**
           * Object area height in pixels.
           *
           * @attribute
           * @type {Number}
           */
          this.areaHeight = this.height;
        }

        /**
         * Drawing the object
         *
         * @method innerDraw
         * @param {Number} x coordinate x
         * @param {Number} y coordinate y
         * @return this object instance
         */

        _createClass(Object_sprite, [{
          key: 'innerDraw',
          value: function innerDraw(x, y) {
            this.fromFrame(this.currentFrame);
            this.x = x;
            this.y = y;

            return this;
          }

          /**
           * Draws new frame to animate or such
           *
           * @method drawNewFrame
           * @param {Number} x                coordinate x
           * @param {Number} y                coordinate y
           * @param {Number} newFrame         New frame number to animate to
           * @return this object instance
           */
        }, {
          key: 'drawNewFrame',
          value: function drawNewFrame(x, y, newFrame) {
            this.currentFrame = newFrame;

            return this.innerDraw(x, y);
          }

          /**
           * Get the area that is reserved for the graphical presenation of this object as a rectangle.
           *
           * @method getGraphicalArea
           * @param  {Object} options       toGlobal: Boolean. Should the method return global coordinates or local (movableLayer)
           * @return {AreaSize}               { x: Number, y: Number, width: Number, height: Number}
           */
        }, {
          key: 'getGraphicalArea',
          value: function getGraphicalArea() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? { toGlobal: true } : arguments[0];

            var coordinates;

            coordinates = options.toGlobal ? this.toGlobal(new PIXI.Point(0, 0)) : this;

            return {
              x: Math.round(coordinates.x),
              y: Math.round(coordinates.y),
              width: Math.round(this.width),
              height: Math.round(this.height)
            };
          }

          /**
           * Coordinate conversion: localToLocal
           *
           * @method localToLocal
           * @param  {Number} x                  X coordinate
           * @param  {Number} y                  Y coordinate
           * @param  {Object} target             PIXI.DisplayObject. The DisplayObject where we should target the coordinates for
           * @return  {{PIXI.Point}} point       PIXI.Point. Coordinates.
           * @return {Coordinates}
           */
        }, {
          key: 'localToLocal',
          value: function localToLocal(x, y, target) {
            var globalCoords = this.toGlobal({ x: x, y: y });
            var targetLocalCoords = target.toLocal(globalCoords);

            return targetLocalCoords;
          }

          /**
           * Clone object
           *
           * @method clone
           * @param  {Object} renderer              PIXI renderer
           * @param  {Object} options               position: Boolean, anchor: Boolean
           * @return {Object}                       cloned object
           */
        }, {
          key: 'clone',
          value: function clone(renderer) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? { position: false, anchor: false } : arguments[1];

            var newSprite = new PIXI.Sprite();

            newSprite.texture = this.generateTexture(renderer);

            if (options.anchor) {
              newSprite.anchor = _Object$assign({}, this.anchor);
            }
            if (options.position) {
              newSprite.position = _Object$assign({}, this.position);
            }

            return newSprite;
          }
        }]);

        return Object_sprite;
      })(PIXI.Sprite);

      _export('Object_sprite', Object_sprite);

      ObjectSpriteTerrain = (function (_Object_sprite) {
        _inherits(ObjectSpriteTerrain, _Object_sprite);

        /**
         * Terrain tile like desert or mountain, non-movable and cacheable. Normally, but not necessarily, these are
         * inherited, depending on the map type. For example you might want to add some click area for these
         *
         * @class ObjectSpriteTerrain
         * @constructor
         * @extends Object_sprite
         * @param {Coordinates} coords        format: {x: Number, y: Number}. Coordinates for the object relative to it's parent
         * @param {object} data               This units custom data
         * @param {object} options            other specific options for constructing this terrain
         */

        function ObjectSpriteTerrain(coords, data, options) {
          _classCallCheck(this, ObjectSpriteTerrain);

          _get(Object.getPrototypeOf(ObjectSpriteTerrain.prototype), 'constructor', this).call(this, coords, data, options);

          this.name = "DefaultTerrainObject";
          this.type = "terrain";
          this.highlightable = false;
        }

        return ObjectSpriteTerrain;
      })(Object_sprite);

      _export('ObjectSpriteTerrain', ObjectSpriteTerrain);

      ObjectSpriteUnit = (function (_Object_sprite2) {
        _inherits(ObjectSpriteUnit, _Object_sprite2);

        /**
         * Map unit like infantry or worker, usually something with actions or movable. Usually these are extended, depending on the map type. For example you might want to add some click area for these (e.g. hexagon)
         *
         * @class ObjectSpriteUnit
         * @constructor
         * @extends Object_sprite
         * @requires graphics
         * @param {Object} coords               Coordinates for the object relative to it's parent
         * @param {Integer} coords.x            X coordinate
         * @param {Integer} coords.y            Y coordinate
         * @param {object} data                 This units data
         * @param {object} options              other specific options for constructing this unit, like options.throwShadow
         * @param {object} options.throwShadow  Can we throw a shadow under this object
         */

        function ObjectSpriteUnit(coords, data, options) {
          _classCallCheck(this, ObjectSpriteUnit);

          _get(Object.getPrototypeOf(ObjectSpriteUnit.prototype), 'constructor', this).call(this, coords, data, options);

          this.name = "DefaultUnitObjects";
          this.type = "unit";
          /**
           * actions bound to this object. @todo THIS HAS NOT BEEN IMPLEMENTED YET!
           *
           * @attribute actions
           * @type {Object}
           */
          this.actions = {
            move: [],
            attack: []
          };
        }

        /**
         * Execute action on units (move, attack etc.). @todo THIS HAS NOT BEEN IMPLEMENTED YET!
         *
         * @method  doAction
         * @param {String} type
         */

        _createClass(ObjectSpriteUnit, [{
          key: 'doAction',
          value: function doAction(type) {
            this.actions[type].forEach(function (action) {
              action();
            });
          }

          /**
           * Add certain action type. @todo THIS HAS NOT BEEN IMPLEMENTED YET!
           *
           * @method addActionType
           * @param {String} type
           */
        }, {
          key: 'addActionType',
          value: function addActionType(type) {
            this.actions[type] = this.actions[type] || [];
          }

          /**
           * Attach callback for the certain action type. @todo THIS HAS NOT BEEN IMPLEMENTED YET!
           *
           * @method addCallbackToAction
           * @param {String} type
           * @param {Function} cb
           */
        }, {
          key: 'addCallbackToAction',
          value: function addCallbackToAction(type, cb) {
            this.actions[type].push(cb);
          }

          /**
           * @method dropShadow
           */
        }, {
          key: 'dropShadow',
          value: function dropShadow() {
            var _utils$effects;

            return (_utils$effects = utils.effects).dropShadow.apply(_utils$effects, arguments);
          }
        }]);

        return ObjectSpriteUnit;
      })(Object_sprite);

      _export('ObjectSpriteUnit', ObjectSpriteUnit);
    }
  };
});
System.register('components/map/core/eventlisteners.js', ['npm:babel-runtime@5.8.24/core-js/set.js', 'bundles/strippedCoreBundle.js'], function (_export) {
  var _Set, mapEvents, stateOfEvents, activeEventListeners, detectors, eventListeners;

  /*-----------------------
  -------- PUBLIC ---------
  -----------------------*/
  /**
   * This keeps all the event listeners and detectors in one class. You add detectors / event listener types with addDetector and you add event listeners with on.
   *
   * @class eventListeners
   */
  function eventListenersModule() {
    /*---------------------------
    ------------ API ------------
    ---------------------------*/
    return {
      on: on,
      off: off,
      isOn: isOn,
      setActivityState: setActivityState,
      getActivityState: getActivityState,
      setDetector: setDetector,
      clearDetector: clearDetector
    };

    /*---------------------------
    ----------- PUBLIC ----------
    ---------------------------*/
    /**
     * Activates the eventListener.
     *
     * @method on
     * @event Event that consists of "Map" + the given event type, like such: "MapDrag"
     * @throws {Error} General error, if detector for this event type has not been set.
     * @param  {String}  type REQUIRED. The type of event. This type has been created with setDetector.
     * @param  {Boolean} cb   REQUIRED. Callback to do it's eventlistener magic.
     */
    function on() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
      var cb = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      if (!detectors[type] && !detectors[type].size) {
        throw new Error("eventlisteners.on needs to have detector set with this event type!");
      }
      detectors[type].on(_createWrapper("Map" + type, cb));
      activeEventListeners[type] = activeEventListeners[type] || new _Set();
      activeEventListeners[type].add(cb);
    }
    /**
     * Deactivates the eventListener. Callback is optional. If is not provided will remove all this types eventListeners
     *
     * @method off
     * @param  {String}  type REQUIRED. The type of event. This type has been created with setDetector.
     * @param  {Boolean} cb   Callback to do it's eventlistener magic.
     */
    function off() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
      var cb = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      detectors[type].off(cb);
      cb ? activeEventListeners[type]['delete'](cb) : delete activeEventListeners[type];
    }
    /**
     * Activates the eventListener. Callback is optional. If is not provided will check if the eventlistener type has any listeners active.
     *
     * @method isOn
     * @param  {String}  type REQUIRED. The type of event. This type has been created with setDetector.
     * @param  {Boolean} cb   Callback to do it's eventlistener magic.
     */
    function isOn() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
      var cb = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      var answer;

      answer = cb ? activeEventListeners[type].has(cb) : !!activeEventListeners[type].size;

      return answer;
    }
    /**
     * Sets the state of the event. State is very important e.g. for fluent dragging and selecting. When we start to drag, we avoid selecting units and vice versa, when we keep an event state tracking through this.
     *
     * @method setActivityState
     * @param {String} type     EventType
     * @param {[type]} newState [description]
     */
    function setActivityState(type, newState) {
      if (type === undefined) type = "";

      stateOfEvents[type] = newState;
    }
    /**
     * get activity state of the event
     *
     * @method getActivityState
     * @param  {String} type EventType
     * @return {Boolean}
     */
    function getActivityState() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];

      return stateOfEvents[type];
    }
    /**
     * Set event detector. If there is already detector of this type, we overwrite it.
     *
     * @method setDetector
     * @param {String}   type  Event type
     * @param {Function} cbOn  Callback which sets activates the detector
     * @param {Function} cbOff Callback which sets deactivates the detector
     */
    function setDetector() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
      var cbOn = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];
      var cbOff = arguments.length <= 2 || arguments[2] === undefined ? function () {} : arguments[2];

      detectors[type] = {};
      detectors[type] = {
        on: cbOn,
        off: cbOff
      };
    }
    /**
     * Clear event detector. We also remove all possible eventlisteners set on this event type.
     *
     * @method clearDetector
     * @param {String}   type  Event type
     */
    function clearDetector() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];

      /* remove all event listeners before we empty the data */
      activeEventListeners[type].forEach(function (cb) {
        detectors[type].cbOff(cb);
      });

      /* remove all data / references to event listeners and detector */
      delete activeEventListeners[type];
      delete detectors[type];
    }

    /*-----------------------------
    ----------- PRIVATE -----------
    ------------------------------*/
    /**
     * This creates a wrapper for callback. The idea is to send map events from this wrapper for all events.
     *
     * @method _createWrapper
     * @private
     * @static
     * @param  {String}   type Event type
     * @param  {Function} cb   Event callback
     */
    function _createWrapper(type, cb) {
      /* NOTE! There can be more than one arguments in an event. E.g. Hamster.js */
      return function () {
        mapEvents.publish(type);
        cb.apply(undefined, arguments);
      };
    }
  }
  return {
    setters: [function (_npmBabelRuntime5824CoreJsSetJs) {
      _Set = _npmBabelRuntime5824CoreJsSetJs['default'];
    }, function (_bundlesStrippedCoreBundleJs) {
      mapEvents = _bundlesStrippedCoreBundleJs.mapEvents;
    }],
    execute: function () {
      /* global Hammer, Hamster */

      /*-----------------------
      ---------- API ----------
      -----------------------*/
      'use strict';

      /*-----------------------
      ------- VARIABLES -------
      -----------------------*/

      /*-----------------------
      --------- IMPORT --------
      -----------------------*/
      stateOfEvents = {};
      activeEventListeners = {};
      detectors = {};
      eventListeners = eventListenersModule();

      _export('eventListeners', eventListeners);
    }
  };
});
System.registerDynamic("npm:core-js@1.1.4/library/modules/$.collection-strong.js", ["npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/$.hide.js", "npm:core-js@1.1.4/library/modules/$.ctx.js", "npm:core-js@1.1.4/library/modules/$.species.js", "npm:core-js@1.1.4/library/modules/$.strict-new.js", "npm:core-js@1.1.4/library/modules/$.defined.js", "npm:core-js@1.1.4/library/modules/$.for-of.js", "npm:core-js@1.1.4/library/modules/$.iter-step.js", "npm:core-js@1.1.4/library/modules/$.uid.js", "npm:core-js@1.1.4/library/modules/$.has.js", "npm:core-js@1.1.4/library/modules/$.is-object.js", "npm:core-js@1.1.4/library/modules/$.support-desc.js", "npm:core-js@1.1.4/library/modules/$.mix.js", "npm:core-js@1.1.4/library/modules/$.iter-define.js", "npm:core-js@1.1.4/library/modules/$.core.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js'),
      hide = $__require('npm:core-js@1.1.4/library/modules/$.hide.js'),
      ctx = $__require('npm:core-js@1.1.4/library/modules/$.ctx.js'),
      species = $__require('npm:core-js@1.1.4/library/modules/$.species.js'),
      strictNew = $__require('npm:core-js@1.1.4/library/modules/$.strict-new.js'),
      defined = $__require('npm:core-js@1.1.4/library/modules/$.defined.js'),
      forOf = $__require('npm:core-js@1.1.4/library/modules/$.for-of.js'),
      step = $__require('npm:core-js@1.1.4/library/modules/$.iter-step.js'),
      ID = $__require('npm:core-js@1.1.4/library/modules/$.uid.js')('id'),
      $has = $__require('npm:core-js@1.1.4/library/modules/$.has.js'),
      isObject = $__require('npm:core-js@1.1.4/library/modules/$.is-object.js'),
      isExtensible = Object.isExtensible || isObject,
      SUPPORT_DESC = $__require('npm:core-js@1.1.4/library/modules/$.support-desc.js'),
      SIZE = SUPPORT_DESC ? '_s' : 'size',
      id = 0;
  var fastKey = function(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      $__require('npm:core-js@1.1.4/library/modules/$.mix.js')(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that._i,
              entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments[1], 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (SUPPORT_DESC)
        $.setDesc(C.prototype, 'size', {get: function() {
            return defined(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      $__require('npm:core-js@1.1.4/library/modules/$.iter-define.js')(C, NAME, function(iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function() {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      species(C);
      species($__require('npm:core-js@1.1.4/library/modules/$.core.js')[NAME]);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.collection.js", ["npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/$.def.js", "npm:core-js@1.1.4/library/modules/$.hide.js", "npm:core-js@1.1.4/library/modules/$.for-of.js", "npm:core-js@1.1.4/library/modules/$.strict-new.js", "npm:core-js@1.1.4/library/modules/$.global.js", "npm:core-js@1.1.4/library/modules/$.support-desc.js", "npm:core-js@1.1.4/library/modules/$.fails.js", "npm:core-js@1.1.4/library/modules/$.mix.js", "npm:core-js@1.1.4/library/modules/$.tag.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js'),
      $def = $__require('npm:core-js@1.1.4/library/modules/$.def.js'),
      hide = $__require('npm:core-js@1.1.4/library/modules/$.hide.js'),
      forOf = $__require('npm:core-js@1.1.4/library/modules/$.for-of.js'),
      strictNew = $__require('npm:core-js@1.1.4/library/modules/$.strict-new.js');
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = $__require('npm:core-js@1.1.4/library/modules/$.global.js')[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    if (!$__require('npm:core-js@1.1.4/library/modules/$.support-desc.js') || typeof C != 'function' || !(IS_WEAK || proto.forEach && !$__require('npm:core-js@1.1.4/library/modules/$.fails.js')(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      $__require('npm:core-js@1.1.4/library/modules/$.mix.js')(C.prototype, methods);
    } else {
      C = wrapper(function(target, iterable) {
        strictNew(target, C, NAME);
        target._c = new Base;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, target[ADDER], target);
      });
      $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','), function(KEY) {
        var chain = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear'))
          hide(C.prototype, KEY, function(a, b) {
            var result = this._c[KEY](a === 0 ? 0 : a, b);
            return chain ? this : result;
          });
      });
      if ('size' in proto)
        $.setDesc(C.prototype, 'size', {get: function() {
            return this._c.size;
          }});
    }
    $__require('npm:core-js@1.1.4/library/modules/$.tag.js')(C, NAME);
    O[NAME] = C;
    $def($def.G + $def.W + $def.F, O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.set.js", ["npm:core-js@1.1.4/library/modules/$.collection-strong.js", "npm:core-js@1.1.4/library/modules/$.collection.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var strong = $__require('npm:core-js@1.1.4/library/modules/$.collection-strong.js');
  $__require('npm:core-js@1.1.4/library/modules/$.collection.js')('Set', function(get) {
    return function Set() {
      return get(this, arguments[0]);
    };
  }, {add: function add(value) {
      return strong.def(this, value = value === 0 ? 0 : value, value);
    }}, strong);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.collection-to-json.js", ["npm:core-js@1.1.4/library/modules/$.for-of.js", "npm:core-js@1.1.4/library/modules/$.classof.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var forOf = $__require('npm:core-js@1.1.4/library/modules/$.for-of.js'),
      classof = $__require('npm:core-js@1.1.4/library/modules/$.classof.js');
  module.exports = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es7.set.to-json.js", ["npm:core-js@1.1.4/library/modules/$.def.js", "npm:core-js@1.1.4/library/modules/$.collection-to-json.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.1.4/library/modules/$.def.js');
  $def($def.P, 'Set', {toJSON: $__require('npm:core-js@1.1.4/library/modules/$.collection-to-json.js')('Set')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/fn/set.js", ["npm:core-js@1.1.4/library/modules/es6.object.to-string.js", "npm:core-js@1.1.4/library/modules/es6.string.iterator.js", "npm:core-js@1.1.4/library/modules/web.dom.iterable.js", "npm:core-js@1.1.4/library/modules/es6.set.js", "npm:core-js@1.1.4/library/modules/es7.set.to-json.js", "npm:core-js@1.1.4/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.1.4/library/modules/es6.object.to-string.js');
  $__require('npm:core-js@1.1.4/library/modules/es6.string.iterator.js');
  $__require('npm:core-js@1.1.4/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.1.4/library/modules/es6.set.js');
  $__require('npm:core-js@1.1.4/library/modules/es7.set.to-json.js');
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.core.js').Set;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/core-js/set.js", ["npm:core-js@1.1.4/library/fn/set.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.1.4/library/fn/set.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.object.to-string.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.string-at.js", ["npm:core-js@1.1.4/library/modules/$.to-integer.js", "npm:core-js@1.1.4/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.1.4/library/modules/$.to-integer.js'),
      defined = $__require('npm:core-js@1.1.4/library/modules/$.defined.js');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.string.iterator.js", ["npm:core-js@1.1.4/library/modules/$.string-at.js", "npm:core-js@1.1.4/library/modules/$.iter-define.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('npm:core-js@1.1.4/library/modules/$.string-at.js')(true);
  $__require('npm:core-js@1.1.4/library/modules/$.iter-define.js')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.unscope.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.iter-step.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.iter-create.js", ["npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/$.hide.js", "npm:core-js@1.1.4/library/modules/$.wks.js", "npm:core-js@1.1.4/library/modules/$.property-desc.js", "npm:core-js@1.1.4/library/modules/$.tag.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js'),
      IteratorPrototype = {};
  $__require('npm:core-js@1.1.4/library/modules/$.hide.js')(IteratorPrototype, $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: $__require('npm:core-js@1.1.4/library/modules/$.property-desc.js')(1, next)});
    $__require('npm:core-js@1.1.4/library/modules/$.tag.js')(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.iter-define.js", ["npm:core-js@1.1.4/library/modules/$.library.js", "npm:core-js@1.1.4/library/modules/$.def.js", "npm:core-js@1.1.4/library/modules/$.redef.js", "npm:core-js@1.1.4/library/modules/$.hide.js", "npm:core-js@1.1.4/library/modules/$.has.js", "npm:core-js@1.1.4/library/modules/$.wks.js", "npm:core-js@1.1.4/library/modules/$.iterators.js", "npm:core-js@1.1.4/library/modules/$.iter-create.js", "npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/$.tag.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('npm:core-js@1.1.4/library/modules/$.library.js'),
      $def = $__require('npm:core-js@1.1.4/library/modules/$.def.js'),
      $redef = $__require('npm:core-js@1.1.4/library/modules/$.redef.js'),
      hide = $__require('npm:core-js@1.1.4/library/modules/$.hide.js'),
      has = $__require('npm:core-js@1.1.4/library/modules/$.has.js'),
      SYMBOL_ITERATOR = $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('iterator'),
      Iterators = $__require('npm:core-js@1.1.4/library/modules/$.iterators.js'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE) {
    $__require('npm:core-js@1.1.4/library/modules/$.iter-create.js')(Constructor, NAME, next);
    var createMethod = function(kind) {
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        proto = Base.prototype,
        _native = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        _default = _native || createMethod(DEFAULT),
        methods,
        key;
    if (_native) {
      var IteratorPrototype = $__require('npm:core-js@1.1.4/library/modules/$.js').getProto(_default.call(new Base));
      $__require('npm:core-js@1.1.4/library/modules/$.tag.js')(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
    }
    if (!LIBRARY || FORCE)
      hide(proto, SYMBOL_ITERATOR, _default);
    Iterators[NAME] = _default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        keys: IS_SET ? _default : createMethod(KEYS),
        values: DEFAULT == VALUES ? _default : createMethod(VALUES),
        entries: DEFAULT != VALUES ? _default : createMethod('entries')
      };
      if (FORCE)
        for (key in methods) {
          if (!(key in proto))
            $redef(proto, key, methods[key]);
        }
      else
        $def($def.P + $def.F * BUGGY, NAME, methods);
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.array.iterator.js", ["npm:core-js@1.1.4/library/modules/$.unscope.js", "npm:core-js@1.1.4/library/modules/$.iter-step.js", "npm:core-js@1.1.4/library/modules/$.iterators.js", "npm:core-js@1.1.4/library/modules/$.to-iobject.js", "npm:core-js@1.1.4/library/modules/$.iter-define.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var setUnscope = $__require('npm:core-js@1.1.4/library/modules/$.unscope.js'),
      step = $__require('npm:core-js@1.1.4/library/modules/$.iter-step.js'),
      Iterators = $__require('npm:core-js@1.1.4/library/modules/$.iterators.js'),
      toIObject = $__require('npm:core-js@1.1.4/library/modules/$.to-iobject.js');
  $__require('npm:core-js@1.1.4/library/modules/$.iter-define.js')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  setUnscope('keys');
  setUnscope('values');
  setUnscope('entries');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/web.dom.iterable.js", ["npm:core-js@1.1.4/library/modules/es6.array.iterator.js", "npm:core-js@1.1.4/library/modules/$.iterators.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.1.4/library/modules/es6.array.iterator.js');
  var Iterators = $__require('npm:core-js@1.1.4/library/modules/$.iterators.js');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.library.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.strict-new.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.iter-call.js", ["npm:core-js@1.1.4/library/modules/$.an-object.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.1.4/library/modules/$.an-object.js');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.is-array-iter.js", ["npm:core-js@1.1.4/library/modules/$.iterators.js", "npm:core-js@1.1.4/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('npm:core-js@1.1.4/library/modules/$.iterators.js'),
      ITERATOR = $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('iterator');
  module.exports = function(it) {
    return (Iterators.Array || Array.prototype[ITERATOR]) === it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.to-integer.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.to-length.js", ["npm:core-js@1.1.4/library/modules/$.to-integer.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.1.4/library/modules/$.to-integer.js'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.classof.js", ["npm:core-js@1.1.4/library/modules/$.cof.js", "npm:core-js@1.1.4/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.1.4/library/modules/$.cof.js'),
      TAG = $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.iterators.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/core.get-iterator-method.js", ["npm:core-js@1.1.4/library/modules/$.classof.js", "npm:core-js@1.1.4/library/modules/$.wks.js", "npm:core-js@1.1.4/library/modules/$.iterators.js", "npm:core-js@1.1.4/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.1.4/library/modules/$.classof.js'),
      ITERATOR = $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('iterator'),
      Iterators = $__require('npm:core-js@1.1.4/library/modules/$.iterators.js');
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.core.js').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.for-of.js", ["npm:core-js@1.1.4/library/modules/$.ctx.js", "npm:core-js@1.1.4/library/modules/$.iter-call.js", "npm:core-js@1.1.4/library/modules/$.is-array-iter.js", "npm:core-js@1.1.4/library/modules/$.an-object.js", "npm:core-js@1.1.4/library/modules/$.to-length.js", "npm:core-js@1.1.4/library/modules/core.get-iterator-method.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('npm:core-js@1.1.4/library/modules/$.ctx.js'),
      call = $__require('npm:core-js@1.1.4/library/modules/$.iter-call.js'),
      isArrayIter = $__require('npm:core-js@1.1.4/library/modules/$.is-array-iter.js'),
      anObject = $__require('npm:core-js@1.1.4/library/modules/$.an-object.js'),
      toLength = $__require('npm:core-js@1.1.4/library/modules/$.to-length.js'),
      getIterFn = $__require('npm:core-js@1.1.4/library/modules/core.get-iterator-method.js');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.same.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.species.js", ["npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/$.wks.js", "npm:core-js@1.1.4/library/modules/$.support-desc.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js'),
      SPECIES = $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('species');
  module.exports = function(C) {
    if ($__require('npm:core-js@1.1.4/library/modules/$.support-desc.js') && !(SPECIES in C))
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.invoke.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.html.js", ["npm:core-js@1.1.4/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.global.js').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.dom-create.js", ["npm:core-js@1.1.4/library/modules/$.is-object.js", "npm:core-js@1.1.4/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.1.4/library/modules/$.is-object.js'),
      document = $__require('npm:core-js@1.1.4/library/modules/$.global.js').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.task.js", ["npm:core-js@1.1.4/library/modules/$.ctx.js", "npm:core-js@1.1.4/library/modules/$.invoke.js", "npm:core-js@1.1.4/library/modules/$.html.js", "npm:core-js@1.1.4/library/modules/$.dom-create.js", "npm:core-js@1.1.4/library/modules/$.global.js", "npm:core-js@1.1.4/library/modules/$.cof.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ctx = $__require('npm:core-js@1.1.4/library/modules/$.ctx.js'),
        invoke = $__require('npm:core-js@1.1.4/library/modules/$.invoke.js'),
        html = $__require('npm:core-js@1.1.4/library/modules/$.html.js'),
        cel = $__require('npm:core-js@1.1.4/library/modules/$.dom-create.js'),
        global = $__require('npm:core-js@1.1.4/library/modules/$.global.js'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('npm:core-js@1.1.4/library/modules/$.cof.js')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScript) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('github:jspm/nodelibs-process@0.1.1.js'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.microtask.js", ["npm:core-js@1.1.4/library/modules/$.global.js", "npm:core-js@1.1.4/library/modules/$.task.js", "npm:core-js@1.1.4/library/modules/$.cof.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = $__require('npm:core-js@1.1.4/library/modules/$.global.js'),
        macrotask = $__require('npm:core-js@1.1.4/library/modules/$.task.js').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        isNode = $__require('npm:core-js@1.1.4/library/modules/$.cof.js')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        if (domain)
          domain.enter();
        head.fn.call();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('github:jspm/nodelibs-process@0.1.1.js'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.redef.js", ["npm:core-js@1.1.4/library/modules/$.hide.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.hide.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.mix.js", ["npm:core-js@1.1.4/library/modules/$.redef.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $redef = $__require('npm:core-js@1.1.4/library/modules/$.redef.js');
  module.exports = function(target, src) {
    for (var key in src)
      $redef(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.has.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.property-desc.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.support-desc.js", ["npm:core-js@1.1.4/library/modules/$.fails.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('npm:core-js@1.1.4/library/modules/$.fails.js')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.hide.js", ["npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/$.property-desc.js", "npm:core-js@1.1.4/library/modules/$.support-desc.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js'),
      createDesc = $__require('npm:core-js@1.1.4/library/modules/$.property-desc.js');
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.support-desc.js') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.tag.js", ["npm:core-js@1.1.4/library/modules/$.has.js", "npm:core-js@1.1.4/library/modules/$.hide.js", "npm:core-js@1.1.4/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var has = $__require('npm:core-js@1.1.4/library/modules/$.has.js'),
      hide = $__require('npm:core-js@1.1.4/library/modules/$.hide.js'),
      TAG = $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      hide(it, TAG, tag);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.shared.js", ["npm:core-js@1.1.4/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.1.4/library/modules/$.global.js'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.uid.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.wks.js", ["npm:core-js@1.1.4/library/modules/$.shared.js", "npm:core-js@1.1.4/library/modules/$.global.js", "npm:core-js@1.1.4/library/modules/$.uid.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('npm:core-js@1.1.4/library/modules/$.shared.js')('wks'),
      Symbol = $__require('npm:core-js@1.1.4/library/modules/$.global.js').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || $__require('npm:core-js@1.1.4/library/modules/$.uid.js'))('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.iter-detect.js", ["npm:core-js@1.1.4/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var SYMBOL_ITERATOR = $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][SYMBOL_ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec) {
    if (!SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[SYMBOL_ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[SYMBOL_ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.10.1/browser.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.10.1.js", ["npm:process@0.10.1/browser.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.10.1/browser.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.1/index.js", ["npm:process@0.10.1.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.10.1.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.1.js", ["github:jspm/nodelibs-process@0.1.1/index.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.1/index.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.promise.js", ["npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/$.library.js", "npm:core-js@1.1.4/library/modules/$.global.js", "npm:core-js@1.1.4/library/modules/$.ctx.js", "npm:core-js@1.1.4/library/modules/$.classof.js", "npm:core-js@1.1.4/library/modules/$.def.js", "npm:core-js@1.1.4/library/modules/$.is-object.js", "npm:core-js@1.1.4/library/modules/$.an-object.js", "npm:core-js@1.1.4/library/modules/$.a-function.js", "npm:core-js@1.1.4/library/modules/$.strict-new.js", "npm:core-js@1.1.4/library/modules/$.for-of.js", "npm:core-js@1.1.4/library/modules/$.set-proto.js", "npm:core-js@1.1.4/library/modules/$.same.js", "npm:core-js@1.1.4/library/modules/$.species.js", "npm:core-js@1.1.4/library/modules/$.wks.js", "npm:core-js@1.1.4/library/modules/$.uid.js", "npm:core-js@1.1.4/library/modules/$.microtask.js", "npm:core-js@1.1.4/library/modules/$.support-desc.js", "npm:core-js@1.1.4/library/modules/$.mix.js", "npm:core-js@1.1.4/library/modules/$.tag.js", "npm:core-js@1.1.4/library/modules/$.core.js", "npm:core-js@1.1.4/library/modules/$.iter-detect.js", "github:jspm/nodelibs-process@0.1.1.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = $__require('npm:core-js@1.1.4/library/modules/$.js'),
        LIBRARY = $__require('npm:core-js@1.1.4/library/modules/$.library.js'),
        global = $__require('npm:core-js@1.1.4/library/modules/$.global.js'),
        ctx = $__require('npm:core-js@1.1.4/library/modules/$.ctx.js'),
        classof = $__require('npm:core-js@1.1.4/library/modules/$.classof.js'),
        $def = $__require('npm:core-js@1.1.4/library/modules/$.def.js'),
        isObject = $__require('npm:core-js@1.1.4/library/modules/$.is-object.js'),
        anObject = $__require('npm:core-js@1.1.4/library/modules/$.an-object.js'),
        aFunction = $__require('npm:core-js@1.1.4/library/modules/$.a-function.js'),
        strictNew = $__require('npm:core-js@1.1.4/library/modules/$.strict-new.js'),
        forOf = $__require('npm:core-js@1.1.4/library/modules/$.for-of.js'),
        setProto = $__require('npm:core-js@1.1.4/library/modules/$.set-proto.js').set,
        same = $__require('npm:core-js@1.1.4/library/modules/$.same.js'),
        species = $__require('npm:core-js@1.1.4/library/modules/$.species.js'),
        SPECIES = $__require('npm:core-js@1.1.4/library/modules/$.wks.js')('species'),
        RECORD = $__require('npm:core-js@1.1.4/library/modules/$.uid.js')('record'),
        asap = $__require('npm:core-js@1.1.4/library/modules/$.microtask.js'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var useNative = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('npm:core-js@1.1.4/library/modules/$.support-desc.js')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var isPromise = function(it) {
      return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
    };
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(react) {
          var cb = ok ? react.ok : react.fail,
              ret,
              then;
          try {
            if (cb) {
              if (!ok)
                record.h = true;
              ret = cb === true ? value : cb(value);
              if (ret === react.P) {
                react.rej(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(ret)) {
                then.call(ret, react.res, react.rej);
              } else
                react.res(ret);
            } else
              react.rej(value);
          } catch (err) {
            react.rej(err);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            if (isUnhandled(record.p)) {
              if (isNode) {
                process.emit('unhandledRejection', value, record.p);
              } else if (global.console && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise[RECORD],
          chain = record.a || record.c,
          i = 0,
          react;
      if (record.h)
        return false;
      while (chain.length > i) {
        react = chain[i++];
        if (react.fail || !isUnhandled(react.P))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!useNative) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        this[RECORD] = record;
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('npm:core-js@1.1.4/library/modules/$.mix.js')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var S = anObject(anObject(this).constructor)[SPECIES];
          var react = {
            ok: typeof onFulfilled == 'function' ? onFulfilled : true,
            fail: typeof onRejected == 'function' ? onRejected : false
          };
          var promise = react.P = new (S != undefined ? S : P)(function(res, rej) {
            react.res = aFunction(res);
            react.rej = aFunction(rej);
          });
          var record = this[RECORD];
          record.c.push(react);
          if (record.a)
            record.a.push(react);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $def($def.G + $def.W + $def.F * !useNative, {Promise: P});
    $__require('npm:core-js@1.1.4/library/modules/$.tag.js')(P, PROMISE);
    species(P);
    species(Wrapper = $__require('npm:core-js@1.1.4/library/modules/$.core.js')[PROMISE]);
    $def($def.S + $def.F * !useNative, PROMISE, {reject: function reject(r) {
        return new this(function(res, rej) {
          rej(r);
        });
      }});
    $def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        return isPromise(x) && sameConstructor(x.constructor, this) ? x : new this(function(res) {
          res(x);
        });
      }});
    $def($def.S + $def.F * !(useNative && $__require('npm:core-js@1.1.4/library/modules/$.iter-detect.js')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            values = [];
        return new C(function(res, rej) {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              C.resolve(promise).then(function(value) {
                results[index] = value;
                --remaining || res(results);
              }, rej);
            });
          else
            res(results);
        });
      },
      race: function race(iterable) {
        var C = getConstructor(this);
        return new C(function(res, rej) {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(res, rej);
          });
        });
      }
    });
  })($__require('github:jspm/nodelibs-process@0.1.1.js'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/fn/promise.js", ["npm:core-js@1.1.4/library/modules/es6.object.to-string.js", "npm:core-js@1.1.4/library/modules/es6.string.iterator.js", "npm:core-js@1.1.4/library/modules/web.dom.iterable.js", "npm:core-js@1.1.4/library/modules/es6.promise.js", "npm:core-js@1.1.4/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.1.4/library/modules/es6.object.to-string.js');
  $__require('npm:core-js@1.1.4/library/modules/es6.string.iterator.js');
  $__require('npm:core-js@1.1.4/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.1.4/library/modules/es6.promise.js');
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.core.js').Promise;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/core-js/promise.js", ["npm:core-js@1.1.4/library/fn/promise.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.1.4/library/fn/promise.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2.js", ["npm:process@0.11.2/browser.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.11.2/browser.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index.js", ["npm:process@0.11.2.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.2.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2.js", ["github:jspm/nodelibs-process@0.1.2/index.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:q@1.4.1/q.js", ["github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function(definition) {
      "use strict";
      if (typeof bootstrap === "function") {
        bootstrap("promise", definition);
      } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();
      } else if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
          return;
        } else {
          ses.makeQ = definition;
        }
      } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        var global = typeof window !== "undefined" ? window : self;
        var previousQ = global.Q;
        global.Q = definition();
        global.Q.noConflict = function() {
          global.Q = previousQ;
          return this;
        };
      } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
      }
    })(function() {
      "use strict";
      var hasStacks = false;
      try {
        throw new Error();
      } catch (e) {
        hasStacks = !!e.stack;
      }
      var qStartingLine = captureLine();
      var qFileName;
      var noop = function() {};
      var nextTick = (function() {
        var head = {
          task: void 0,
          next: null
        };
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        var laterQueue = [];
        function flush() {
          var task,
              domain;
          while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;
            if (domain) {
              head.domain = void 0;
              domain.enter();
            }
            runSingle(task, domain);
          }
          while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
          }
          flushing = false;
        }
        function runSingle(task, domain) {
          try {
            task();
          } catch (e) {
            if (isNodeJS) {
              if (domain) {
                domain.exit();
              }
              setTimeout(flush, 0);
              if (domain) {
                domain.enter();
              }
              throw e;
            } else {
              setTimeout(function() {
                throw e;
              }, 0);
            }
          }
          if (domain) {
            domain.exit();
          }
        }
        nextTick = function(task) {
          tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
          };
          if (!flushing) {
            flushing = true;
            requestTick();
          }
        };
        if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
          isNodeJS = true;
          requestTick = function() {
            process.nextTick(flush);
          };
        } else if (typeof setImmediate === "function") {
          if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
          } else {
            requestTick = function() {
              setImmediate(flush);
            };
          }
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          channel.port1.onmessage = function() {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
          };
          var requestPortTick = function() {
            channel.port2.postMessage(0);
          };
          requestTick = function() {
            setTimeout(flush, 0);
            requestPortTick();
          };
        } else {
          requestTick = function() {
            setTimeout(flush, 0);
          };
        }
        nextTick.runAfter = function(task) {
          laterQueue.push(task);
          if (!flushing) {
            flushing = true;
            requestTick();
          }
        };
        return nextTick;
      })();
      var call = Function.call;
      function uncurryThis(f) {
        return function() {
          return call.apply(f, arguments);
        };
      }
      var array_slice = uncurryThis(Array.prototype.slice);
      var array_reduce = uncurryThis(Array.prototype.reduce || function(callback, basis) {
        var index = 0,
            length = this.length;
        if (arguments.length === 1) {
          do {
            if (index in this) {
              basis = this[index++];
              break;
            }
            if (++index >= length) {
              throw new TypeError();
            }
          } while (1);
        }
        for (; index < length; index++) {
          if (index in this) {
            basis = callback(basis, this[index], index);
          }
        }
        return basis;
      });
      var array_indexOf = uncurryThis(Array.prototype.indexOf || function(value) {
        for (var i = 0; i < this.length; i++) {
          if (this[i] === value) {
            return i;
          }
        }
        return -1;
      });
      var array_map = uncurryThis(Array.prototype.map || function(callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function(undefined, value, index) {
          collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
      });
      var object_create = Object.create || function(prototype) {
        function Type() {}
        Type.prototype = prototype;
        return new Type();
      };
      var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var object_keys = Object.keys || function(object) {
        var keys = [];
        for (var key in object) {
          if (object_hasOwnProperty(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      var object_toString = uncurryThis(Object.prototype.toString);
      function isObject(value) {
        return value === Object(value);
      }
      function isStopIteration(exception) {
        return (object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue);
      }
      var QReturnValue;
      if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
      } else {
        QReturnValue = function(value) {
          this.value = value;
        };
      }
      var STACK_JUMP_SEPARATOR = "From previous event:";
      function makeStackTraceLong(error, promise) {
        if (hasStacks && promise.stack && typeof error === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          var stacks = [];
          for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
              stacks.unshift(p.stack);
            }
          }
          stacks.unshift(error.stack);
          var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
          error.stack = filterStackString(concatedStacks);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join("\n");
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
      }
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];
        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
      }
      function captureLine() {
        if (!hasStacks) {
          return;
        }
        try {
          throw new Error();
        } catch (e) {
          var lines = e.stack.split("\n");
          var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return;
          }
          qFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      function deprecate(callback, name, alternative) {
        return function() {
          if (typeof console !== "undefined" && typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
          }
          return callback.apply(callback, arguments);
        };
      }
      function Q(value) {
        if (value instanceof Promise) {
          return value;
        }
        if (isPromiseAlike(value)) {
          return coerce(value);
        } else {
          return fulfill(value);
        }
      }
      Q.resolve = Q;
      Q.nextTick = nextTick;
      Q.longStackSupport = false;
      if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
      }
      Q.defer = defer;
      function defer() {
        var messages = [],
            progressListeners = [],
            resolvedPromise;
        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);
        promise.promiseDispatch = function(resolve, op, operands) {
          var args = array_slice(arguments);
          if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) {
              progressListeners.push(operands[1]);
            }
          } else {
            Q.nextTick(function() {
              resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
          }
        };
        promise.valueOf = function() {
          if (messages) {
            return promise;
          }
          var nearerValue = nearer(resolvedPromise);
          if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue;
          }
          return nearerValue;
        };
        promise.inspect = function() {
          if (!resolvedPromise) {
            return {state: "pending"};
          }
          return resolvedPromise.inspect();
        };
        if (Q.longStackSupport && hasStacks) {
          try {
            throw new Error();
          } catch (e) {
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
          }
        }
        function become(newPromise) {
          resolvedPromise = newPromise;
          promise.source = newPromise;
          array_reduce(messages, function(undefined, message) {
            Q.nextTick(function() {
              newPromise.promiseDispatch.apply(newPromise, message);
            });
          }, void 0);
          messages = void 0;
          progressListeners = void 0;
        }
        deferred.promise = promise;
        deferred.resolve = function(value) {
          if (resolvedPromise) {
            return;
          }
          become(Q(value));
        };
        deferred.fulfill = function(value) {
          if (resolvedPromise) {
            return;
          }
          become(fulfill(value));
        };
        deferred.reject = function(reason) {
          if (resolvedPromise) {
            return;
          }
          become(reject(reason));
        };
        deferred.notify = function(progress) {
          if (resolvedPromise) {
            return;
          }
          array_reduce(progressListeners, function(undefined, progressListener) {
            Q.nextTick(function() {
              progressListener(progress);
            });
          }, void 0);
        };
        return deferred;
      }
      defer.prototype.makeNodeResolver = function() {
        var self = this;
        return function(error, value) {
          if (error) {
            self.reject(error);
          } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
          } else {
            self.resolve(value);
          }
        };
      };
      Q.Promise = promise;
      Q.promise = promise;
      function promise(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
          resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
          deferred.reject(reason);
        }
        return deferred.promise;
      }
      promise.race = race;
      promise.all = all;
      promise.reject = reject;
      promise.resolve = Q;
      Q.passByCopy = function(object) {
        return object;
      };
      Promise.prototype.passByCopy = function() {
        return this;
      };
      Q.join = function(x, y) {
        return Q(x).join(y);
      };
      Promise.prototype.join = function(that) {
        return Q([this, that]).spread(function(x, y) {
          if (x === y) {
            return x;
          } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
          }
        });
      };
      Q.race = race;
      function race(answerPs) {
        return promise(function(resolve, reject) {
          for (var i = 0,
              len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
          }
        });
      }
      Promise.prototype.race = function() {
        return this.then(Q.race);
      };
      Q.makePromise = Promise;
      function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
          fallback = function(op) {
            return reject(new Error("Promise does not support operation: " + op));
          };
        }
        if (inspect === void 0) {
          inspect = function() {
            return {state: "unknown"};
          };
        }
        var promise = object_create(Promise.prototype);
        promise.promiseDispatch = function(resolve, op, args) {
          var result;
          try {
            if (descriptor[op]) {
              result = descriptor[op].apply(promise, args);
            } else {
              result = fallback.call(promise, op, args);
            }
          } catch (exception) {
            result = reject(exception);
          }
          if (resolve) {
            resolve(result);
          }
        };
        promise.inspect = inspect;
        if (inspect) {
          var inspected = inspect();
          if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
          }
          promise.valueOf = function() {
            var inspected = inspect();
            if (inspected.state === "pending" || inspected.state === "rejected") {
              return promise;
            }
            return inspected.value;
          };
        }
        return promise;
      }
      Promise.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise.prototype.then = function(fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false;
        function _fulfilled(value) {
          try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
          } catch (exception) {
            return reject(exception);
          }
        }
        function _rejected(exception) {
          if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
              return rejected(exception);
            } catch (newException) {
              return reject(newException);
            }
          }
          return reject(exception);
        }
        function _progressed(value) {
          return typeof progressed === "function" ? progressed(value) : value;
        }
        Q.nextTick(function() {
          self.promiseDispatch(function(value) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_fulfilled(value));
          }, "when", [function(exception) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_rejected(exception));
          }]);
        });
        self.promiseDispatch(void 0, "when", [void 0, function(value) {
          var newValue;
          var threw = false;
          try {
            newValue = _progressed(value);
          } catch (e) {
            threw = true;
            if (Q.onerror) {
              Q.onerror(e);
            } else {
              throw e;
            }
          }
          if (!threw) {
            deferred.notify(newValue);
          }
        }]);
        return deferred.promise;
      };
      Q.tap = function(promise, callback) {
        return Q(promise).tap(callback);
      };
      Promise.prototype.tap = function(callback) {
        callback = Q(callback);
        return this.then(function(value) {
          return callback.fcall(value).thenResolve(value);
        });
      };
      Q.when = when;
      function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
      }
      Promise.prototype.thenResolve = function(value) {
        return this.then(function() {
          return value;
        });
      };
      Q.thenResolve = function(promise, value) {
        return Q(promise).thenResolve(value);
      };
      Promise.prototype.thenReject = function(reason) {
        return this.then(function() {
          throw reason;
        });
      };
      Q.thenReject = function(promise, reason) {
        return Q(promise).thenReject(reason);
      };
      Q.nearer = nearer;
      function nearer(value) {
        if (isPromise(value)) {
          var inspected = value.inspect();
          if (inspected.state === "fulfilled") {
            return inspected.value;
          }
        }
        return value;
      }
      Q.isPromise = isPromise;
      function isPromise(object) {
        return object instanceof Promise;
      }
      Q.isPromiseAlike = isPromiseAlike;
      function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
      }
      Q.isPending = isPending;
      function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
      }
      Promise.prototype.isPending = function() {
        return this.inspect().state === "pending";
      };
      Q.isFulfilled = isFulfilled;
      function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
      }
      Promise.prototype.isFulfilled = function() {
        return this.inspect().state === "fulfilled";
      };
      Q.isRejected = isRejected;
      function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
      }
      Promise.prototype.isRejected = function() {
        return this.inspect().state === "rejected";
      };
      var unhandledReasons = [];
      var unhandledRejections = [];
      var reportedUnhandledRejections = [];
      var trackUnhandledRejections = true;
      function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;
        if (!trackUnhandledRejections) {
          trackUnhandledRejections = true;
        }
      }
      function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
          return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
          Q.nextTick.runAfter(function() {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
              process.emit("unhandledRejection", reason, promise);
              reportedUnhandledRejections.push(promise);
            }
          });
        }
        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
          unhandledReasons.push(reason.stack);
        } else {
          unhandledReasons.push("(no stack) " + reason);
        }
      }
      function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
          return;
        }
        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
          if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function() {
              var atReport = array_indexOf(reportedUnhandledRejections, promise);
              if (atReport !== -1) {
                process.emit("rejectionHandled", unhandledReasons[at], promise);
                reportedUnhandledRejections.splice(atReport, 1);
              }
            });
          }
          unhandledRejections.splice(at, 1);
          unhandledReasons.splice(at, 1);
        }
      }
      Q.resetUnhandledRejections = resetUnhandledRejections;
      Q.getUnhandledReasons = function() {
        return unhandledReasons.slice();
      };
      Q.stopUnhandledRejectionTracking = function() {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
      };
      resetUnhandledRejections();
      Q.reject = reject;
      function reject(reason) {
        var rejection = Promise({"when": function(rejected) {
            if (rejected) {
              untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
          }}, function fallback() {
          return this;
        }, function inspect() {
          return {
            state: "rejected",
            reason: reason
          };
        });
        trackRejection(rejection, reason);
        return rejection;
      }
      Q.fulfill = fulfill;
      function fulfill(value) {
        return Promise({
          "when": function() {
            return value;
          },
          "get": function(name) {
            return value[name];
          },
          "set": function(name, rhs) {
            value[name] = rhs;
          },
          "delete": function(name) {
            delete value[name];
          },
          "post": function(name, args) {
            if (name === null || name === void 0) {
              return value.apply(void 0, args);
            } else {
              return value[name].apply(value, args);
            }
          },
          "apply": function(thisp, args) {
            return value.apply(thisp, args);
          },
          "keys": function() {
            return object_keys(value);
          }
        }, void 0, function inspect() {
          return {
            state: "fulfilled",
            value: value
          };
        });
      }
      function coerce(promise) {
        var deferred = defer();
        Q.nextTick(function() {
          try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
          } catch (exception) {
            deferred.reject(exception);
          }
        });
        return deferred.promise;
      }
      Q.master = master;
      function master(object) {
        return Promise({"isDef": function() {}}, function fallback(op, args) {
          return dispatch(object, op, args);
        }, function() {
          return Q(object).inspect();
        });
      }
      Q.spread = spread;
      function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
      }
      Promise.prototype.spread = function(fulfilled, rejected) {
        return this.all().then(function(array) {
          return fulfilled.apply(void 0, array);
        }, rejected);
      };
      Q.async = async;
      function async(makeGenerator) {
        return function() {
          function continuer(verb, arg) {
            var result;
            if (typeof StopIteration === "undefined") {
              try {
                result = generator[verb](arg);
              } catch (exception) {
                return reject(exception);
              }
              if (result.done) {
                return Q(result.value);
              } else {
                return when(result.value, callback, errback);
              }
            } else {
              try {
                result = generator[verb](arg);
              } catch (exception) {
                if (isStopIteration(exception)) {
                  return Q(exception.value);
                } else {
                  return reject(exception);
                }
              }
              return when(result, callback, errback);
            }
          }
          var generator = makeGenerator.apply(this, arguments);
          var callback = continuer.bind(continuer, "next");
          var errback = continuer.bind(continuer, "throw");
          return callback();
        };
      }
      Q.spawn = spawn;
      function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
      }
      Q["return"] = _return;
      function _return(value) {
        throw new QReturnValue(value);
      }
      Q.promised = promised;
      function promised(callback) {
        return function() {
          return spread([this, all(arguments)], function(self, args) {
            return callback.apply(self, args);
          });
        };
      }
      Q.dispatch = dispatch;
      function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
      }
      Promise.prototype.dispatch = function(op, args) {
        var self = this;
        var deferred = defer();
        Q.nextTick(function() {
          self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
      };
      Q.get = function(object, key) {
        return Q(object).dispatch("get", [key]);
      };
      Promise.prototype.get = function(key) {
        return this.dispatch("get", [key]);
      };
      Q.set = function(object, key, value) {
        return Q(object).dispatch("set", [key, value]);
      };
      Promise.prototype.set = function(key, value) {
        return this.dispatch("set", [key, value]);
      };
      Q.del = Q["delete"] = function(object, key) {
        return Q(object).dispatch("delete", [key]);
      };
      Promise.prototype.del = Promise.prototype["delete"] = function(key) {
        return this.dispatch("delete", [key]);
      };
      Q.mapply = Q.post = function(object, name, args) {
        return Q(object).dispatch("post", [name, args]);
      };
      Promise.prototype.mapply = Promise.prototype.post = function(name, args) {
        return this.dispatch("post", [name, args]);
      };
      Q.send = Q.mcall = Q.invoke = function(object, name) {
        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
      };
      Promise.prototype.send = Promise.prototype.mcall = Promise.prototype.invoke = function(name) {
        return this.dispatch("post", [name, array_slice(arguments, 1)]);
      };
      Q.fapply = function(object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
      };
      Promise.prototype.fapply = function(args) {
        return this.dispatch("apply", [void 0, args]);
      };
      Q["try"] = Q.fcall = function(object) {
        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
      };
      Promise.prototype.fcall = function() {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
      };
      Q.fbind = function(object) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
          return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
        };
      };
      Promise.prototype.fbind = function() {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
          return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
        };
      };
      Q.keys = function(object) {
        return Q(object).dispatch("keys", []);
      };
      Promise.prototype.keys = function() {
        return this.dispatch("keys", []);
      };
      Q.all = all;
      function all(promises) {
        return when(promises, function(promises) {
          var pendingCount = 0;
          var deferred = defer();
          array_reduce(promises, function(undefined, promise, index) {
            var snapshot;
            if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
              promises[index] = snapshot.value;
            } else {
              ++pendingCount;
              when(promise, function(value) {
                promises[index] = value;
                if (--pendingCount === 0) {
                  deferred.resolve(promises);
                }
              }, deferred.reject, function(progress) {
                deferred.notify({
                  index: index,
                  value: progress
                });
              });
            }
          }, void 0);
          if (pendingCount === 0) {
            deferred.resolve(promises);
          }
          return deferred.promise;
        });
      }
      Promise.prototype.all = function() {
        return all(this);
      };
      Q.any = any;
      function any(promises) {
        if (promises.length === 0) {
          return Q.resolve();
        }
        var deferred = Q.defer();
        var pendingCount = 0;
        array_reduce(promises, function(prev, current, index) {
          var promise = promises[index];
          pendingCount++;
          when(promise, onFulfilled, onRejected, onProgress);
          function onFulfilled(result) {
            deferred.resolve(result);
          }
          function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
              deferred.reject(new Error("Can't get fulfillment value from any promise, all " + "promises were rejected."));
            }
          }
          function onProgress(progress) {
            deferred.notify({
              index: index,
              value: progress
            });
          }
        }, undefined);
        return deferred.promise;
      }
      Promise.prototype.any = function() {
        return any(this);
      };
      Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
      function allResolved(promises) {
        return when(promises, function(promises) {
          promises = array_map(promises, Q);
          return when(all(array_map(promises, function(promise) {
            return when(promise, noop, noop);
          })), function() {
            return promises;
          });
        });
      }
      Promise.prototype.allResolved = function() {
        return allResolved(this);
      };
      Q.allSettled = allSettled;
      function allSettled(promises) {
        return Q(promises).allSettled();
      }
      Promise.prototype.allSettled = function() {
        return this.then(function(promises) {
          return all(array_map(promises, function(promise) {
            promise = Q(promise);
            function regardless() {
              return promise.inspect();
            }
            return promise.then(regardless, regardless);
          }));
        });
      };
      Q.fail = Q["catch"] = function(object, rejected) {
        return Q(object).then(void 0, rejected);
      };
      Promise.prototype.fail = Promise.prototype["catch"] = function(rejected) {
        return this.then(void 0, rejected);
      };
      Q.progress = progress;
      function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
      }
      Promise.prototype.progress = function(progressed) {
        return this.then(void 0, void 0, progressed);
      };
      Q.fin = Q["finally"] = function(object, callback) {
        return Q(object)["finally"](callback);
      };
      Promise.prototype.fin = Promise.prototype["finally"] = function(callback) {
        callback = Q(callback);
        return this.then(function(value) {
          return callback.fcall().then(function() {
            return value;
          });
        }, function(reason) {
          return callback.fcall().then(function() {
            throw reason;
          });
        });
      };
      Q.done = function(object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
      };
      Promise.prototype.done = function(fulfilled, rejected, progress) {
        var onUnhandledError = function(error) {
          Q.nextTick(function() {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
              Q.onerror(error);
            } else {
              throw error;
            }
          });
        };
        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;
        if (typeof process === "object" && process && process.domain) {
          onUnhandledError = process.domain.bind(onUnhandledError);
        }
        promise.then(void 0, onUnhandledError);
      };
      Q.timeout = function(object, ms, error) {
        return Q(object).timeout(ms, error);
      };
      Promise.prototype.timeout = function(ms, error) {
        var deferred = defer();
        var timeoutId = setTimeout(function() {
          if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
          }
          deferred.reject(error);
        }, ms);
        this.then(function(value) {
          clearTimeout(timeoutId);
          deferred.resolve(value);
        }, function(exception) {
          clearTimeout(timeoutId);
          deferred.reject(exception);
        }, deferred.notify);
        return deferred.promise;
      };
      Q.delay = function(object, timeout) {
        if (timeout === void 0) {
          timeout = object;
          object = void 0;
        }
        return Q(object).delay(timeout);
      };
      Promise.prototype.delay = function(timeout) {
        return this.then(function(value) {
          var deferred = defer();
          setTimeout(function() {
            deferred.resolve(value);
          }, timeout);
          return deferred.promise;
        });
      };
      Q.nfapply = function(callback, args) {
        return Q(callback).nfapply(args);
      };
      Promise.prototype.nfapply = function(args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nfcall = function(callback) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
      };
      Promise.prototype.nfcall = function() {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nfbind = Q.denodeify = function(callback) {
        var baseArgs = array_slice(arguments, 1);
        return function() {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          Q(callback).fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      };
      Promise.prototype.nfbind = Promise.prototype.denodeify = function() {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q.denodeify.apply(void 0, args);
      };
      Q.nbind = function(callback, thisp) {
        var baseArgs = array_slice(arguments, 2);
        return function() {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          function bound() {
            return callback.apply(thisp, arguments);
          }
          Q(bound).fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      };
      Promise.prototype.nbind = function() {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
      };
      Q.nmapply = Q.npost = function(object, name, args) {
        return Q(object).npost(name, args);
      };
      Promise.prototype.nmapply = Promise.prototype.npost = function(name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nsend = Q.nmcall = Q.ninvoke = function(object, name) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Promise.prototype.nsend = Promise.prototype.nmcall = Promise.prototype.ninvoke = function(name) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nodeify = nodeify;
      function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
      }
      Promise.prototype.nodeify = function(nodeback) {
        if (nodeback) {
          this.then(function(value) {
            Q.nextTick(function() {
              nodeback(null, value);
            });
          }, function(error) {
            Q.nextTick(function() {
              nodeback(error);
            });
          });
        } else {
          return this;
        }
      };
      Q.noConflict = function() {
        throw new Error("Q.noConflict only works when Q is used as a global");
      };
      var qEndingLine = captureLine();
      return Q;
    });
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:q@1.4.1.js", ["npm:q@1.4.1/q.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:q@1.4.1/q.js');
  global.define = __define;
  return module.exports;
});

System.register('components/map/core/Map.js', ['npm:babel-runtime@5.8.24/helpers/create-class.js', 'npm:babel-runtime@5.8.24/helpers/class-call-check.js', 'npm:babel-runtime@5.8.24/core-js/set.js', 'npm:babel-runtime@5.8.24/core-js/object/assign.js', 'npm:babel-runtime@5.8.24/core-js/promise.js', 'bundles/strippedCoreBundle.js', 'npm:q@1.4.1.js'], function (_export) {
  var _createClass, _classCallCheck, _Set, _Object$assign, _Promise, MapLayer, MapLayerParent, ObjectManager, mapEvents, utils, MapDataManipulator, Q, LAYER_TYPE_STATIC, LAYER_TYPE_MOVABLE, _drawMapOnNextTick, isMapReadyPromises, _staticLayer, _movableLayer, _renderer, ParentLayerConstructor, Map;

  /*---------------------
  ------- PRIVATE -------
  ----------------------*/
  /**
   * cacheLayers
   *
   * @method cacheLayers
   * @private
   * @static
   * @param  {Boolean}  cacheOrNot        Do you want to cache or uncache?
   * @param  {Boolean} hasSubcontainers   Does the map have subcontainers activated?
   */
  function cacheLayers(cacheOrNot, hasSubcontainers) {
    if (hasSubcontainers) {
      _movableLayer.children.forEach(function (child) {
        if (!child.isCached()) {
          return false;
        }
        var subcontainers = child.getSubcontainers();

        subcontainers.forEach(function (subcontainer) {
          subcontainer.setCache(cacheOrNot);
        });
      });
    } else {
      _movableLayer.children.forEach(function (child) {
        if (!child.isCached()) {
          return false;
        }

        child.setCache(cacheOrNot);
      });
    }
  }
  return {
    setters: [function (_npmBabelRuntime5824HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5824HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs['default'];
    }, function (_npmBabelRuntime5824CoreJsSetJs) {
      _Set = _npmBabelRuntime5824CoreJsSetJs['default'];
    }, function (_npmBabelRuntime5824CoreJsObjectAssignJs) {
      _Object$assign = _npmBabelRuntime5824CoreJsObjectAssignJs['default'];
    }, function (_npmBabelRuntime5824CoreJsPromiseJs) {
      _Promise = _npmBabelRuntime5824CoreJsPromiseJs['default'];
    }, function (_bundlesStrippedCoreBundleJs) {
      MapLayer = _bundlesStrippedCoreBundleJs.MapLayer;
      MapLayerParent = _bundlesStrippedCoreBundleJs.MapLayerParent;
      ObjectManager = _bundlesStrippedCoreBundleJs.ObjectManager;
      mapEvents = _bundlesStrippedCoreBundleJs.mapEvents;
      utils = _bundlesStrippedCoreBundleJs.utils;
      MapDataManipulator = _bundlesStrippedCoreBundleJs.MapDataManipulator;
    }, function (_npmQ141Js) {
      Q = _npmQ141Js;
    }],
    execute: function () {
      /* global System, Q */

      /*---------------------
      ------ VARIABLES ------
      ----------------------*/
      'use strict';

      /*---------------------
      ------- IMPORT --------
      ----------------------*/
      LAYER_TYPE_STATIC = 0;
      LAYER_TYPE_MOVABLE = 1;
      _drawMapOnNextTick = false;
      isMapReadyPromises = [];

      /*---------------------
      --------- API ---------
      ----------------------*/

      Map = (function () {
        /**
         * #Main class for the engine
         *
         * Initializes the whole structure and plugins and is used as primary API for all operations. This class is e.g. passed to every plugin that get initialized with their init-method.
         *
         * You use the class by instantiating it (new) and then finishing initialization with init-method. Please see examples below.
         *
         * The biggest part of creating the map, is the data structure. There is a clear data structure that you can see from the tests/data-folder, but the factory is responsible for creating the objects, so you can use your own factory implementation. So to understand more, please see e.g. factories.horizontalHexaFactory.
         *
         * The map consists of layer on top of each other. The example is best understood when thinking typical war strategy game. The structure is this:
         * 1. StaticLayer: Handles things like scaling / zooming the map
         * 2. MovableLayer: Obviously handles movement of the map. Also is a good place to get map coordinates. Since getting global coordinates won't help you much, half of the time.
         * 3. Different layers: like units, terrain, fog of war, UIs etc. Can also contains special layers like dynamically changed UIlayers.
         * 4. possible subcontainers (used for optimized object selection and map movement). Can also contains special layers like dynamically changed UIlayers.
         * 5. Individual objects, like units, terrains, cities etc...
         *
         * Plugins can be added with activatePlugins-method by sending them to the class. Plugins must always implement init-method, which receives Map instance. Plugins are not yet restricted what they can do and can add functionality without touching map or can modify objects or their prototypes through access to Map instance.
         *
         * @example
         *     var map = new Map(divContainer, mapOptions );
         *     promises = map.init( gameData.pluginsToActivate, mapData.startPoint );
         *
         * @class Map
         * @constructor
         * @requires PIXI.JS framework in global namespace
         * @requires Canvas (webGL support recommended) HTML5-element supported.
         * @requires Hammer for touch events
         * @requires Hamster for mouse scroll events
         *
         * @param {HTMLElement} canvasContainer                 HTML element which will be container for the created canvas element. REQUIRED
         * @param {Object} props                                Extra properties
         * @param {Object} props.bounds                         Bounds of the map / mapSize
         * @param {Integer} props.bounds.width                  Bound width
         * @param {Integer} props.bounds.height                 Bound height
         * @param {Object} props.rendererOptions                Renderer options passed to PIXI.autoDetectRenderer
         * @param {Object} props.subcontainers                  Subcontainers size in pixels. If given, will activate subcontainers. If not given or false, subcontainers are not used.area.
         * @param {Integer} props.subcontainers.width           Subcontainer width
         * @param {Integer} props.subcontainers.height          Subcontainer height
         * @param {FPSCallback} trackFPSCB                      Callback function for tracking FPS in renderer. So this is used for debugging and optimizing.
         *
         * @return {Object}                                      New Map instance
         */

        function Map() {
          var canvasContainer = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
          var props = arguments.length <= 1 || arguments[1] === undefined ? {
            bounds: { width: 0, height: 0 },
            rendererOptions: { refreshEventListeners: true },
            subcontainers: false,
            cache: false,
            trackFPSCB: false } : arguments[1];

          _classCallCheck(this, Map);

          var bounds = props.bounds;
          var rendererOptions = props.rendererOptions;
          var subcontainers = props.subcontainers;
          var trackFPSCB = props.trackFPSCB;
          var cache = props.cache;

          /* Check for the required parameters! */
          if (!canvasContainer) {
            throw new Error(this.constructor.name + " needs canvasContainer!");
          }
          /* If the constructor was passed canvasContainer as a string and not as an Element, we get the element */
          if (typeof canvasContainer === "string") {
            canvasContainer = document.querySelector(canvasContainer);
          }

          /* Create PIXI renderer. Practically PIXI creates its own canvas and does its magic to it */
          _renderer = PIXI.autoDetectRenderer(bounds.width, bounds.height, rendererOptions);
          /* We handle all the events ourselves through addEventListeners-method on canvas, so destroy pixi native method */
          _renderer.plugins.interaction.destroy();
          /* Make sure the canvasContainer is empty. So there are no nasty surprises */
          canvasContainer.innerHTML = "";
          /* Add the canvas Element PIXI created inside the given canvasContainer */
          canvasContainer.appendChild(_renderer.view, canvasContainer);
          /* This defines which MapLayer class we use to generate layers on the map. Under movableLayer. These are layers like: Units, terrain, fog of war, UIs etc. */
          ParentLayerConstructor = subcontainers ? MapLayerParent : MapLayer;

          /* These are the 2 topmost layers on the map:
           * - staticLayer: Keeps at the same coordinates always and is responsible for holding map scale value and possible
           * objects that do not move with the map. StaticLayer has only one child: _movableLayer
           * - movableLayer: Moves the map, when the user commands. Can hold e.g. UI objects that move with the map. Like
           * graphics that show which area or object is currently selected. */
          _staticLayer = new MapLayer({ name: "staticLayer", coord: { x: 0, y: 0 } });
          _movableLayer = new MapLayer({ name: "movableLayer", coord: { x: 0, y: 0 } });
          _staticLayer.addChild(_movableLayer);

          /* needed to make the canvas fullsize canvas with PIXI */
          _renderer.view.style.position = "absolute";
          _renderer.view.style.display = "block";
          _renderer.view.style.left = "0px";
          _renderer.view.style.top = "0px";
          /* stop scrollbars of showing */
          document.getElementsByTagName("body")[0].style.overflow = "hidden";

          /**
           * canvas element that was generated and is being used by this new generated Map instance.
           *
           * @attribute canvas
           * @type {HTMLElement}
           * @required
           **/
          this.canvas = _renderer.view;
          /**
           * list of plugins that the map uses and are initialized
           * @see Map.activatePlugins
           *
           * @attribute plugins
           * @type {Set}
           **/
          this.plugins = new _Set();
          /**
           * Subcontainers size that we want to generate, when layers use subcontainers
           *
           * @attribute subcontainersConfig
           * @type {{width: Integer, height: Int}}
           **/
          this.subcontainersConfig = subcontainers;
          /**
           * Callback function that gets the current FPS on the map and shows it in DOM
           *
           * @attribute trackFPSCB
           * @type {Function}
           **/
          this.trackFPSCB = trackFPSCB;
          /**
           * ObjectManager instance. Responsible for retrieving the objects from the map, on desired occasions. Like when the player clicks the map to select some object. This uses subcontainers when present.
           *
           * @attribute objectManager
           * @type {ObjectManager}
           **/
          this.objectManager = new ObjectManager(new PIXI.interaction.InteractionManager(_renderer));
          /**
           * Is cache activated for this map at all. This is set for individual layers with a property, but without activating the cache for the whole map, the layers cache property is ignored.
           *
           * @attribute objectManager
           * @type {ObjectManager}
           **/
          this.cache = cache;
          /**
           * Layer types. Can be extended, but the already defined types are supposed to be constants and not to be changed.
           *
           * @attribute layerTypes
           * @type {Object}
           */
          this.layerTypes = {
            staticType: {
              id: LAYER_TYPE_STATIC,
              layer: _staticLayer
            },
            movableType: {
              id: LAYER_TYPE_MOVABLE,
              layer: _movableLayer
            }
          };
        }

        /**
         * This initializes the map and makes everything appear on the map and actually work. Also initializes the given plugins since normally the plugins have to be activated before the map is shown.
         *
         * @method init
         * @param {String[]|Object[]} plugins                  Plugins to be activated for the map. Normally you should give the plugins here
         * instead of separately passing them to activatePlugins method. You can provide the module strings or module objects.
         * @param  {Object} coord                     Starting coordinates for the map.
         * @param  {Integer} coord.x                  X coordinate.
         * @param  {Integer} coord.y                  Y coordinate.
         * @param {Function} tickCB                   callback function for tick. Tick callback is initiated in every frame. So map draws happen during ticks.
         * @param {Object} options                    Extra options.
         * @param {Boolean} options.fullsize          Do we set fullsize canvas or not at the beginning. Default: true
         * @return {Array}                            Returns an array of Promises. If this is empty / zero. Then there is nothing to wait for, if it contains promises, you have to wait for them to finish for the plugins to work and map be ready.
         **/

        _createClass(Map, [{
          key: 'init',
          value: function init() {
            var plugins = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
            var coord = arguments.length <= 1 || arguments[1] === undefined ? { x: 0, y: 0 } : arguments[1];
            var tickCB = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
            var options = arguments.length <= 3 || arguments[3] === undefined ? { fullsize: true } : arguments[3];

            var allPromises = [];

            options.fullsize && this.toggleFullsize();

            if (plugins.length) {
              allPromises = this.activatePlugins(plugins);
            }

            /* Sets the correct Map starting coordinates */
            coord && _Object$assign(_movableLayer, coord);

            /* We activate the default tick for the map, but if custom tick callback has been given, we activate it too */
            this._defaultTick();
            tickCB && this.customTickOn(tickCB);
            isMapReadyPromises = allPromises;

            if (this.cache) {
              this.cacheMap();
            }

            this.drawOnNextTick();

            return allPromises || _Promise.resolve();
          }

          /**
           * Returns a promise that resolves after the map is fully initialized
           *
           * @method whenReady
           * @return {Promise}        Promise that holds all the individual plugin loading promises
           **/
        }, {
          key: 'whenReady',
          value: function whenReady() {
            return Q.all(isMapReadyPromises);
          }

          /**
           * The correct way to update / redraw the map. Check happens at every tick and thus in every frame.
           *
           * @method drawOnNextTick
           **/
        }, {
          key: 'drawOnNextTick',
          value: function drawOnNextTick() {
            _drawMapOnNextTick = true;
          }

          /**
           * Add an UI object to the wanted layer.
           *
           * @method addUIObject
           * @param {Integer} layer   Type of the layer. layerTypes.STATIC of layerTypes.MOVABLE.
           * @param {Object} object   The object to be attached as UI object.
           */
        }, {
          key: 'addUIObject',
          value: function addUIObject(layerType, object) {
            switch (layerType) {
              case LAYER_TYPE_STATIC:
                this.getStaticLayer().addUIObject(object);
                break;
              case LAYER_TYPE_MOVABLE:
                this.getMovableLayer().addUIObject(object);
                break;
            }
          }

          /**
           * Remove an UI object to the wanted layer.
           *
           * @method removeUIObject
           * @param {Integer} layer   Type of the layer. layerTypes.STATIC of layerTypes.MOVABLE.
           * @param {Object} object   The object to be attached as UI object.
           */
        }, {
          key: 'removeUIObject',
          value: function removeUIObject(layerType, object) {
            switch (layerType) {
              case LAYER_TYPE_STATIC:
                this.getStaticLayer().emptyUIObjects();
                break;
              case LAYER_TYPE_MOVABLE:
                this.getMovableLayer().emptyUIObjects();
                break;
            }
          }

          /**
           * Adds an UI object to the map. This method adds it to the given layer and removes it with removeUIObject-method.
           *
           * @method addUIObjects
           * @param {Integer} layerType     map.layerTypes holds the constants used in this.
           * @param {Array} objects         Object that are added as UI objects
           */
        }, {
          key: 'addUIObjects',
          value: function addUIObjects(layerType, objects) {
            var _this = this;

            objects.forEach(function (object) {
              _this.addUIObject(layerType, object);
            });
          }

          /**
           * Create a special layer, that can holds e.g. UI effects in it.
           *
           * @method createSpecialLayer
           * @param {String} name               name of the layer
           * @param {Object} options            Optional options.
           * @param {Object} options.coord      Coordinates of the layer
           * @param {Integer} options.coord.x   X coordinate
           * @param {Integer} options.coord.y   Y coordinate
           * @param {Object} options.toLayer    To which layer will this layer be added to as UILayer
           * @return {MapLayer}            The created UI layer
           **/
        }, {
          key: 'createSpecialLayer',
          value: function createSpecialLayer() {
            var name = arguments.length <= 0 || arguments[0] === undefined ? "default special layer" : arguments[0];
            var options = arguments.length <= 1 || arguments[1] === undefined ? { coord: { x: 0, y: 0 }, toLayer: toLayer } : arguments[1];
            return (function () {
              var coord = options.coord;
              var toLayer = options.toLayer;

              var layer = new MapLayer(name, coord);

              layer.specialLayer = true;
              toLayer && toLayer.addChild(layer);

              return layer;
            })();
          }

          /**
           * All parameters are passed to ParentLayerConstructor (normally constructor of MapLayer).
           *
           * @method addLayer
           * @uses MapLayer
           * @return {MapLayer}          created MapLayer instance
           **/
        }, {
          key: 'addLayer',
          value: function addLayer(layerOptions) {
            var newLayer;

            if (this.getSubcontainerConfigs() && layerOptions.subcontainers !== false) {
              layerOptions.subcontainers = this.getSubcontainerConfigs();
            }

            newLayer = new ParentLayerConstructor(layerOptions);
            this.getMovableLayer().addChild(newLayer);

            return newLayer;
          }

          /**
           * Just a convenience function (for usability and readability), for checking if the map uses subcontainers.
           *
           * @method usesSubcontainers
           **/
        }, {
          key: 'usesSubcontainers',
          value: function usesSubcontainers() {
            return this.getSubcontainerConfigs() ? true : false;
          }

          /**
           * Returns current subcontainers configurations (like subcontainers size).
           *
           * @method getSubcontainerConfigs
           **/
        }, {
          key: 'getSubcontainerConfigs',
          value: function getSubcontainerConfigs() {
            return this.subcontainersConfig;
          }

          /**
           * Get the size of the area that is shown to the player. More or less the area of the browser window.
           *
           * @method getViewportArea
           * @param  {Boolean} isLocal                                                  Do we want to use Map coordinates or global / canvas coordinates. Default = false
           * @return {{x: Integer, y: Integer, width: Integer, height: Integer}}        x- and y-coordinates and the width and height of the viewport
           **/
        }, {
          key: 'getViewportArea',
          value: function getViewportArea() {
            var isLocal = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

            var layer = isLocal ? this.getMovableLayer() : this.getStaticLayer();

            return {
              x: layer.x,
              y: layer.y,
              width: Math.round(window.innerWidth),
              height: Math.round(window.innerHeight)
            };
          }

          /**
           * Remove a primary layer from the map
           *
           * @method removeLayer
           * @param {MapLayer|PIXI.Container|PIXI.ParticleContainer} layer       The layer object to be removed
           **/
        }, {
          key: 'removeLayer',
          value: function removeLayer(layer) {
            _movableLayer.removeChild(layer);

            return layer;
          }

          /**
           * Moves the map the amount of given x and y pixels. Note that this is not the destination coordinate, but the amount of movement that the map should move. Internally it moves the movableLayer, taking into account necessary properties (like scale). Draws map after movement.
           *
           * @method moveMap
           * @param {Object} coord                 The amount of x and y coordinates we want the map to move. I.e. { x: 5, y: 0 }. With this we want the map to move horizontally 5 pixels and vertically stay at the same position.
           * @param {Integer} coord.x              X coordinate
           * @param {Integer} coord.y              Y coordinate
           * @param {Object} informCoordinates     THIS IS EXPERIMENTAL, TO FIX THE INCORRECT EVENT COORDINATES THIS SEND TO mapEvents, WHEN SCALING
           * @param {Integer} informCoordinates.x  X coordinate
           * @param {Integer} informCoordinates.y  Y coordinate
           **/
        }, {
          key: 'moveMap',
          value: function moveMap() {
            var coord = arguments.length <= 0 || arguments[0] === undefined ? { x: 0, y: 0 } : arguments[0];
            var informCoordinates = arguments.length <= 1 || arguments[1] === undefined ? coord : arguments[1];
            return (function () {
              var realCoordinates = {
                x: Math.round(coord.x / this.getStaticLayer().getZoom()),
                y: Math.round(coord.y / this.getStaticLayer().getZoom())
              };
              _movableLayer.move(realCoordinates);
              mapEvents.publish("mapMoved", informCoordinates || realCoordinates);
              this.drawOnNextTick();
            }).apply(this, arguments);
          }

          /**
           * Is cache on
           *
           * @method isCacheActivated
           * @return {Boolean}
           **/
        }, {
          key: 'isCacheActivated',
          value: function isCacheActivated() {
            return this.cache;
          }

          /**
           * Cache the map. This provides performance boost when used correctly. CacheMap iterates through all the layers on the map and caches the ones that return true from isCached-method. NOT WORKING YET. CACHING IMPLEMENTED SOON.
           *
           * @method cacheMap
           * @param {Object} filters          filters from MapDataManipulator.js
           **/
        }, {
          key: 'cacheMap',
          value: function cacheMap(filters) {
            cacheLayers(true, this.usesSubcontainers());
          }

          /**
           * unCache the map. NOT WORKING ATM. IMPLEMENTED SOON!
           *
           * @method unCacheMap
           * @return {Map}        this map instance
           * */
        }, {
          key: 'unCacheMap',
          value: function unCacheMap() {
            cacheLayers(false, this.usesSubcontainers());
          }

          /**
           * Activate all plugins for the map. Iterates through the given plugins we wish to activate and does the actual work in activatePlugin-method.
           *
           * @method pluginsArray
           * @param {Object[]} pluginsArray   Array that consists the plugin modules to be activated
           * @return {Promise}                Promise. If string are provided resolved those with System.import, otherwise resolves immediately.
           * */
        }, {
          key: 'activatePlugins',
          value: function activatePlugins() {
            var _this2 = this;

            var pluginsArray = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

            var allPromises = [];

            /* Iterates over given plugins Array and calls their init-method, depeding if it is String or Object */
            pluginsArray.forEach(function (plugin) {
              if (typeof plugin === "object") {
                _this2.activatePlugin(plugin);
              } else {
                throw new Error("problem with initializing a plugin");
              }
            });

            return allPromises;
          }

          /**
           * Activate plugin for the map. Plugins need .pluginName property and .init-method. Plugins init-method activates the plugins and we call them in Map. Plugins init-metho receivse this (Map instance) as their only parameter.
           *
           * @method activatePlugin
           * @param {Object} plugin        Plugin module
           * */
        }, {
          key: 'activatePlugin',
          value: function activatePlugin(plugin) {
            try {
              if (!plugin || !plugin.pluginName || !plugin.init) {
                throw new Error("plugin, plugin.pluginName or plugin.init import is missing!");
              }

              if (this.plugins.add(plugin[plugin.pluginName])) {
                plugin.init(this);
              }
            } catch (e) {
              console.log("An error initializing plugin. JSON.stringify: '" + JSON.stringify(plugin) + "' ", e);
            }
          }

          /**
           * Setting new prototype methods for the Map instance
           *
           * @method setPrototype
           * @param {String} property         The property you want to set
           * @param {*} value                 Value for the property
           */
        }, {
          key: 'setPrototype',
          value: function setPrototype(property, value) {
            var thisPrototype = Object.getPrototypeOf(this);

            thisPrototype[property] = value;
          }

          /**
           * Gets object under specific map coordinates. Uses the ObjectManagers retrieve method. Using subcontainers if they exist, other methods if not. If you provide type parameter, the method returns only object types that match it.
           *
           * @method getObjectsUnderArea
           * @param  {Object} globalCoords            Event coordinates on the staticLayer / canvas.
           * @param  {Integer} globalCoords.x         X coordinate
           * @param  {Integer} globalCoords.y         Y coordinate
           * @param  {Object} options                 Optional options
           * @param  {Object} options.filter          The filter to apply to subcontainers
           * @return {Array}                          Array of object found on the map.
           */
        }, {
          key: 'getObjectsUnderArea',
          value: function getObjectsUnderArea() {
            var globalCoords = arguments.length <= 0 || arguments[0] === undefined ? { x: 0, y: 0, width: 0, height: 0 } : arguments[0];
            var options = arguments.length <= 1 || arguments[1] === undefined ? { filter: filter } : arguments[1];
            return (function () {
              var filter = options.filter;

              /* We need both coordinates later on and it's logical to do the work here */
              var allCoords = {
                globalCoords: globalCoords,
                localCoords: this.getMovableLayer().toLocal(new PIXI.Point(globalCoords.x, globalCoords.y))
              };
              var objects = {};
              var selectableContainerfilter;

              allCoords.localCoords.width = globalCoords.width;
              allCoords.localCoords.height = globalCoords.height;
              selectableContainerfilter = new MapDataManipulator({
                type: "filter",
                object: "container",
                property: "selectable",
                value: true
              });
              filter.addRule(selectableContainerfilter);

              if (this.usesSubcontainers()) {
                var allMatchingSubcontainers = this._getSubcontainersUnderArea(allCoords, { filter: filter });

                objects = this._retrieveObjects(allCoords, {
                  subcontainers: allMatchingSubcontainers
                });
              }

              return objects;
            }).apply(this, arguments);
          }

          /**
           * This returns the normal parent layers that we mostly use for manipulation everything. MovableLayer and staticLayer are built-in layers designed to provide the basic functionalities like zooming and moving the map. These layers provide everything that extends the map more.
           *
           * @method getPrimaryLayers
           * @return {Object} Basically anything in the map that is used as a layer (not really counting subcontainers).
           */
        }, {
          key: 'getPrimaryLayers',
          value: function getPrimaryLayers() {
            return this.getMovableLayer().getPrimaryLayers();
          }

          /**
           * Get current map coordinates. Basically the same as movable layers position.
           *
           * @method getMapCoordinates
           * @return {{x: Integer, y: Integer}}          current coordinates for the moved map
           * */
        }, {
          key: 'getMapCoordinates',
          value: function getMapCoordinates() {
            return {
              x: this.getMovableLayer().x,
              y: this.getMovableLayer().y
            };
          }

          /**
           * This returns the layer that is responsible for map zoom
           *
           * @method getZoomLayer
           * @return {MapLayer|PIXI.Container|PIXI.ParticleContainer}
           */
        }, {
          key: 'getZoomLayer',
          value: function getZoomLayer() {
            return this.getStaticLayer();
          }

          /**
           * Set map zoom. 1 = no zoom. <1 zoom out, >1 zoom in.
           *
           * @method setZoom
           * @param {Number} scale    The amount of zoom you want to set
           * @return {Number}         The amount of zoom applied
           */
        }, {
          key: 'setZoom',
          value: function setZoom(scale) {
            return this.getZoomLayer().setZoom(scale);
          }

          /**
           * Get map zoom. 1 = no zoom. <1 zoom out, >1 zoom in.
           *
           * @method getZoom
           * @return {MapLayer|PIXI.Container|PIXI.ParticleContainer}
           */
        }, {
          key: 'getZoom',
          value: function getZoom() {
            return this.getZoomLayer().getZoom();
          }

          /**
           * Returns movable layer. This layer is the one that moves when the player moves the map. So this is used for things that are relative to the current map position the player is seeing. This can be used e.g. when you want to display some objects on the map or UI elements, like effects that happen on certain point on the map.
           *
           * @method getMovableLayer
           * @return {MapLayer|PIXI.Container|PIXI.ParticleContainer}
           */
        }, {
          key: 'getMovableLayer',
          value: function getMovableLayer() {
            return _movableLayer;
          }

          /**
           * Returns the PIXI renderer. Some situations might need this. For more advanced or PIXI specific cases.
           *
           * @method getRenderer
           * @return {PIXI.Renderer}
           */
        }, {
          key: 'getRenderer',
          value: function getRenderer() {
            return _renderer;
          }

          /**
           * Return static layer. The static layer is the topmost of all layers. It handles zooming and other non-movable operations.
           *
           * @method getStaticLayer
           */
        }, {
          key: 'getStaticLayer',
          value: function getStaticLayer() {
            return _staticLayer;
          }

          /*---------------------------------------------
           ------- ABSTRACT APIS THROUGH PLUGINS --------
           --------------------------------------------*/
          /**
           * This is abstract method and needs to be implemented with a plugin. Core module has an implementation for this and if you don't implement your own, I suggest you use it.
           *
           * @method zoomIn
           */
        }, {
          key: 'zoomIn',
          value: function zoomIn() {
            return "notImplementedYet. Activate with plugin";
          }

          /**
           * This is abstract method and needs to be implemented with a plugin. Core module has an implementation for this and if you don't implement your own, I suggest you use it.
           *
           * @method zoomOut
           */
        }, {
          key: 'zoomOut',
          value: function zoomOut() {
            return "notImplementedYet. Activate with plugin";
          }

          /**
           * Resize the canvas to fill the whole browser content area. Defined by the baseEventlisteners-module (core modules plugin)
           *
           * @method toggleFullsize
           **/
        }, {
          key: 'toggleFullsize',
          value: function toggleFullsize() {
            return "notImplementedYet. Activate with plugin";
          }

          /**
           * Toggles fullscreen mode. Defined by the baseEventlisteners-module (core modules plugin)
           *
           * @method toggleFullScreen
           **/
        }, {
          key: 'toggleFullScreen',
          value: function toggleFullScreen() {
            return "notImplementedYet. Activate with plugin";
          }

          /*-------------------------
          --------- PRIVATE ---------
          -------------------------*/
          /**
           * Retrieves the objects from ObjectManager, with the given parameters. Mostly helper functionality for getObjectsUnderArea
           *
           * @private
           * @method _retrieveObjects
           * @param {Object} allCoords                        REQUIRED
           * @param {Object} allCoords.globalCoords           REQUIRED
           * @param {Integer} allCoords.globalCoords.x        REQUIRED
           * @param {Integer} allCoords.globalCoords.y        REQUIRED
           * @param {Integer} allCoords.globalCoords.width    REQUIRED
           * @param {Integer} allCoords.globalCoords.height   REQUIRED
           * @param {Object} allCoords.localCoords            REQUIRED
           * @param {Integer} allCoords.localCoords.x         REQUIRED
           * @param {Integer} allCoords.localCoords.y         REQUIRED
           * @param {Object} options                          Optional options
           * @param {String} options.type                     The type of objects we want
           * @param {Array} options.subcontainers             Array of the subcontainers we will search
           * @return {Array}                                  Found objects
           */
        }, {
          key: '_retrieveObjects',
          value: function _retrieveObjects(allCoords) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? { type: "", subcontainers: [] } : arguments[1];

            return this.objectManager.retrieve(allCoords, {
              type: options.type,
              subcontainers: options.subcontainers,
              size: {
                width: allCoords.globalCoords.width,
                height: allCoords.globalCoords.height
              }
            });
          }

          /**
           * This returns layers by filtering them based on certain attribute. Can be used with more higher order filtering
           *
           * @private
           * @method _getLayersWithAttributes
           * @param {String} attribute
           * @param {*} value
           * @return the current map instance
           **/
        }, {
          key: '_getLayersWithAttributes',
          value: function _getLayersWithAttributes(attribute, value) {
            return this.getMovableLayer().children[0].children.filter(function (layer) {
              return layer[attribute] === value;
            });
          }

          /**
           * Get subcontainers under certain point or rectangle
           *
           * @private
           * @method _getSubcontainersUnderPoint
           * @param  {[type]} globalCoords
           * @param {Object} options              Optional options.
           * @return {Array}                        All subcontainers that matched the critea
           */
        }, {
          key: '_getSubcontainersUnderArea',
          value: function _getSubcontainersUnderArea(allCoords) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? { filter: undefined } : arguments[1];

            var primaryLayers = this.getMovableLayer().getPrimaryLayers();
            var allMatchingSubcontainers = [];
            var filter = options.filter;

            var thisLayersSubcontainers;

            primaryLayers.forEach(function (layer) {
              thisLayersSubcontainers = layer.getSubcontainersByCoordinates(allCoords.globalCoords, { filter: filter });
              allMatchingSubcontainers = allMatchingSubcontainers.concat(thisLayersSubcontainers);
            });

            return allMatchingSubcontainers;
          }

          /**
           * Activate the browsers fullScreen mode and expand the canvas to fullsize
           *
           * @private
           * @method setFullScreen
           */
        }, {
          key: '_setFullScreen',
          value: function _setFullScreen() {
            utils.resize.toggleFullScreen();
            mapEvents.publish("mapResized");
            this._resizeCanvas();
          }

          /**
           * Resizes the canvas to the current most wide and high element status. Basically canvas size === window size.
           *
           * @private
           * @method _resizeCanvas
           */
        }, {
          key: '_resizeCanvas',
          value: function _resizeCanvas() {
            var windowSize = utils.resize.getWindowSize();

            _renderer.autoResize = true;
            _renderer.resize(windowSize.x, windowSize.y);
            mapEvents.publish("mapResized");
            this.drawOnNextTick();
          }

          /**
           * This handles the default drawing of the map, so that map always updates when drawOnNextTick === true. This tick
           * callback is always set and should not be removed or overruled
           *
           * @private
           * @method _defaultTick
           */
        }, {
          key: '_defaultTick',
          value: function _defaultTick() {
            var ONE_SECOND = 1000;
            var FPSCount = 0;
            var fpsTimer = new Date().getTime();
            var renderStart, totalRenderTime;

            PIXI.ticker.shared.add((function () {
              if (_drawMapOnNextTick === true) {
                if (this.trackFPSCB) {
                  renderStart = new Date().getTime();
                }

                _renderer.render(_staticLayer);
                _drawMapOnNextTick = false;

                if (this.trackFPSCB) {
                  totalRenderTime += Math.round(Math.abs(renderStart - new Date().getTime()));
                }
              }
              if (this.trackFPSCB) {
                FPSCount++;

                if (fpsTimer + ONE_SECOND < new Date().getTime()) {
                  this.trackFPSCB({
                    FPS: FPSCount,
                    FPStime: fpsTimer,
                    renderTime: totalRenderTime,
                    drawCount: _renderer.drawCount
                  });

                  FPSCount = 0;
                  totalRenderTime = 0;
                  fpsTimer = new Date().getTime();
                }
              }
            }).bind(this));
          }
        }]);

        return Map;
      })();

      _export('Map', Map);
    }
  };
});
System.register('components/map/core/MapDataManipulator.js', ['npm:babel-runtime@5.8.24/helpers/create-class.js', 'npm:babel-runtime@5.8.24/helpers/class-call-check.js', 'bundles/strippedCoreBundle.js'], function (_export) {
  var _createClass, _classCallCheck, MapLayer, MapLayerParent, MapDataManipulator;

  return {
    setters: [function (_npmBabelRuntime5824HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5824HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs['default'];
    }, function (_bundlesStrippedCoreBundleJs) {
      MapLayer = _bundlesStrippedCoreBundleJs.MapLayer;
      MapLayerParent = _bundlesStrippedCoreBundleJs.MapLayerParent;
    }],
    execute: function () {

      /*---------------------
      --------- API ---------
      ----------------------*/
      'use strict';

      MapDataManipulator = (function () {
        /**
         * Class to get a consistent standard for the engine to be able to filter objects, when retrieving or sorting them.
         *
         * @class MapDataManipulator
         * @constructor
         * @param {Array|Object} rules        REQUIRED. The rules that apply for this instance. Multiple rules in Array or one as Object.
         **/

        function MapDataManipulator(rules) {
          _classCallCheck(this, MapDataManipulator);

          this.rules = Array.isArray(rules) ? rules : [rules];
          this.layerClasses = [MapLayer, MapLayerParent];
        }

        _createClass(MapDataManipulator, [{
          key: 'filterSubcontainers',
          value: function filterSubcontainers(subcontainers) {
            if (!Array.isArray(subcontainers)) {
              return this._runRules(subcontainers);
            }
          }
        }, {
          key: 'addRule',
          value: function addRule(rules) {
            this.rules.concat(rules);
          }

          /**
           * This is the actual method that runs through the rules and arranges the data
           *
           * @method _runRules
           * @private
           * @return {[type]} [description]
           **/
        }, {
          key: '_runRules',
          value: function _runRules(object) {
            var _this = this;

            var foundObjects;

            this.rules.forEach(function (rule) {
              if (rule.type === "filter") {
                switch (rule.object) {
                  case "container":
                    foundObjects = _this._getContainer(object, rule);
                    break;
                  case "object":
                    foundObjects = _this._getObject(object, rule);
                    break;
                }
              }
            });

            return foundObjects;
          }

          /**
           * This is the actual method that runs through the rules and arranges the data
           *
           * @todo Refactor
           *
           * @method _getContainer
           * @private
           * @return {[type]} [description]
           **/
        }, {
          key: '_getContainer',
          value: function _getContainer(object, rule) {
            if (object && (object.parent instanceof this.layerClasses[0] || object && object.parent instanceof this.layerClasses[1])) {
              return object.parent[rule.property] === rule.value;
            } else if (object && object.parent && (object.parent.parent instanceof this.layerClasses[0] || object.parent.parent instanceof this.layerClasses[0])) {
              return object.parent.parent[rule.property] === rule.value;
            }
          }

          /**
           * This is the actual method that runs through the rules and arranges the data
           *
           * @todo Refactor
           *
           * @method _getContainer
           * @private
           * @return {[type]} [description]
           **/
        }, {
          key: '_getContainer',
          value: function _getContainer(object, rule) {
            if (object && (object.parent instanceof this.layerClasses[0] || object && object.parent instanceof this.layerClasses[1])) {
              return object.parent[rule.property] === rule.value;
            } else if (object && object.parent && (object.parent.parent instanceof this.layerClasses[0] || object.parent.parent instanceof this.layerClasses[0])) {
              return object.parent.parent[rule.property] === rule.value;
            }
          }
        }]);

        return MapDataManipulator;
      })();

      _export('MapDataManipulator', MapDataManipulator);
    }
  };
});
System.registerDynamic("npm:core-js@1.1.4/library/modules/$.to-iobject.js", ["npm:core-js@1.1.4/library/modules/$.iobject.js", "npm:core-js@1.1.4/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('npm:core-js@1.1.4/library/modules/$.iobject.js'),
      defined = $__require('npm:core-js@1.1.4/library/modules/$.defined.js');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.object-sap.js", ["npm:core-js@1.1.4/library/modules/$.def.js", "npm:core-js@1.1.4/library/modules/$.core.js", "npm:core-js@1.1.4/library/modules/$.fails.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(KEY, exec) {
    var $def = $__require('npm:core-js@1.1.4/library/modules/$.def.js'),
        fn = ($__require('npm:core-js@1.1.4/library/modules/$.core.js').Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $def($def.S + $def.F * $__require('npm:core-js@1.1.4/library/modules/$.fails.js')(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.object.get-own-property-descriptor.js", ["npm:core-js@1.1.4/library/modules/$.to-iobject.js", "npm:core-js@1.1.4/library/modules/$.object-sap.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('npm:core-js@1.1.4/library/modules/$.to-iobject.js');
  $__require('npm:core-js@1.1.4/library/modules/$.object-sap.js')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/fn/object/get-own-property-descriptor.js", ["npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/es6.object.get-own-property-descriptor.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js');
  $__require('npm:core-js@1.1.4/library/modules/es6.object.get-own-property-descriptor.js');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/core-js/object/get-own-property-descriptor.js", ["npm:core-js@1.1.4/library/fn/object/get-own-property-descriptor.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.1.4/library/fn/object/get-own-property-descriptor.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/helpers/get.js", ["npm:babel-runtime@5.8.24/core-js/object/get-own-property-descriptor.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$getOwnPropertyDescriptor = $__require('npm:babel-runtime@5.8.24/core-js/object/get-own-property-descriptor.js')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/fn/object/create.js", ["npm:core-js@1.1.4/library/modules/$.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/core-js/object/create.js", ["npm:core-js@1.1.4/library/fn/object/create.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.1.4/library/fn/object/create.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.is-object.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return it !== null && (typeof it == 'object' || typeof it == 'function');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.an-object.js", ["npm:core-js@1.1.4/library/modules/$.is-object.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.1.4/library/modules/$.is-object.js');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.a-function.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.ctx.js", ["npm:core-js@1.1.4/library/modules/$.a-function.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('npm:core-js@1.1.4/library/modules/$.a-function.js');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.set-proto.js", ["npm:core-js@1.1.4/library/modules/$.js", "npm:core-js@1.1.4/library/modules/$.is-object.js", "npm:core-js@1.1.4/library/modules/$.an-object.js", "npm:core-js@1.1.4/library/modules/$.ctx.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('npm:core-js@1.1.4/library/modules/$.js').getDesc,
      isObject = $__require('npm:core-js@1.1.4/library/modules/$.is-object.js'),
      anObject = $__require('npm:core-js@1.1.4/library/modules/$.an-object.js');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(buggy, set) {
      try {
        set = $__require('npm:core-js@1.1.4/library/modules/$.ctx.js')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set({}, []);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }() : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.object.set-prototype-of.js", ["npm:core-js@1.1.4/library/modules/$.def.js", "npm:core-js@1.1.4/library/modules/$.set-proto.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.1.4/library/modules/$.def.js');
  $def($def.S, 'Object', {setPrototypeOf: $__require('npm:core-js@1.1.4/library/modules/$.set-proto.js').set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/fn/object/set-prototype-of.js", ["npm:core-js@1.1.4/library/modules/es6.object.set-prototype-of.js", "npm:core-js@1.1.4/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.1.4/library/modules/es6.object.set-prototype-of.js');
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.core.js').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/core-js/object/set-prototype-of.js", ["npm:core-js@1.1.4/library/fn/object/set-prototype-of.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.1.4/library/fn/object/set-prototype-of.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/helpers/inherits.js", ["npm:babel-runtime@5.8.24/core-js/object/create.js", "npm:babel-runtime@5.8.24/core-js/object/set-prototype-of.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$create = $__require('npm:babel-runtime@5.8.24/core-js/object/create.js')["default"];
  var _Object$setPrototypeOf = $__require('npm:babel-runtime@5.8.24/core-js/object/set-prototype-of.js')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.global.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var UNDEFINED = 'undefined';
  var global = module.exports = typeof window != UNDEFINED && window.Math == Math ? window : typeof self != UNDEFINED && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.def.js", ["npm:core-js@1.1.4/library/modules/$.global.js", "npm:core-js@1.1.4/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.1.4/library/modules/$.global.js'),
      core = $__require('npm:core-js@1.1.4/library/modules/$.core.js'),
      PROTOTYPE = 'prototype';
  var ctx = function(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  };
  var $def = function(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] : (global[name] || {})[PROTOTYPE],
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      if (isGlobal && typeof target[key] != 'function')
        exp = source[key];
      else if (type & $def.B && own)
        exp = ctx(out, global);
      else if (type & $def.W && target[key] == out)
        !function(C) {
          exp = function(param) {
            return this instanceof C ? new C(param) : C(param);
          };
          exp[PROTOTYPE] = C[PROTOTYPE];
        }(out);
      else
        exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
      exports[key] = exp;
      if (isProto)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.defined.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.to-object.js", ["npm:core-js@1.1.4/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('npm:core-js@1.1.4/library/modules/$.defined.js');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.cof.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.iobject.js", ["npm:core-js@1.1.4/library/modules/$.cof.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.1.4/library/modules/$.cof.js');
  module.exports = 0 in Object('z') ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.enum-keys.js", ["npm:core-js@1.1.4/library/modules/$.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js');
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.fails.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.assign.js", ["npm:core-js@1.1.4/library/modules/$.to-object.js", "npm:core-js@1.1.4/library/modules/$.iobject.js", "npm:core-js@1.1.4/library/modules/$.enum-keys.js", "npm:core-js@1.1.4/library/modules/$.fails.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('npm:core-js@1.1.4/library/modules/$.to-object.js'),
      IObject = $__require('npm:core-js@1.1.4/library/modules/$.iobject.js'),
      enumKeys = $__require('npm:core-js@1.1.4/library/modules/$.enum-keys.js');
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.fails.js')(function() {
    return Symbol() in Object.assign({});
  }) ? function assign(target, source) {
    var T = toObject(target),
        l = arguments.length,
        i = 1;
    while (l > i) {
      var S = IObject(arguments[i++]),
          keys = enumKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        T[key = keys[j++]] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/es6.object.assign.js", ["npm:core-js@1.1.4/library/modules/$.def.js", "npm:core-js@1.1.4/library/modules/$.assign.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $def = $__require('npm:core-js@1.1.4/library/modules/$.def.js');
  $def($def.S + $def.F, 'Object', {assign: $__require('npm:core-js@1.1.4/library/modules/$.assign.js')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/modules/$.core.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/fn/object/assign.js", ["npm:core-js@1.1.4/library/modules/es6.object.assign.js", "npm:core-js@1.1.4/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.1.4/library/modules/es6.object.assign.js');
  module.exports = $__require('npm:core-js@1.1.4/library/modules/$.core.js').Object.assign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/core-js/object/assign.js", ["npm:core-js@1.1.4/library/fn/object/assign.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.1.4/library/fn/object/assign.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("components/map/core/MapLayers.js", ["npm:babel-runtime@5.8.24/helpers/get.js", "npm:babel-runtime@5.8.24/helpers/inherits.js", "npm:babel-runtime@5.8.24/helpers/create-class.js", "npm:babel-runtime@5.8.24/helpers/class-call-check.js", "npm:babel-runtime@5.8.24/core-js/object/assign.js"], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, _Object$assign, _UIObjects, MapLayer, MapLayerParent, MapSubcontainer;

  /*---------------------
  ------- PRIVATE -------
  ----------------------*/
  /**
   * Helper function for setting subcontainers to parent containers
   *
   * @method setCorrectSubcontainer
   * @private
   * @static
   * @method setCorrectSubcontainer
   * @param {PIXI.DisplayObject} displayObject
   * @param {Object} parentLayer
   */
  function setCorrectSubcontainer(displayObject, parentLayer) {
    var subcontainersConfig = parentLayer.subcontainersConfig;
    var subcontainerList = parentLayer.subcontainerList;

    var xIndex = Math.floor(displayObject.x / subcontainersConfig.width);
    var yIndex = Math.floor(displayObject.y / subcontainersConfig.height);
    var thisSubcontainer;

    subcontainerList[xIndex] = subcontainerList[xIndex] || [];
    thisSubcontainer = subcontainerList[xIndex][yIndex] = subcontainerList[xIndex][yIndex] || [];

    if (subcontainerList[xIndex][yIndex].length <= 0) {
      thisSubcontainer = new MapSubcontainer({
        x: xIndex * subcontainersConfig.width,
        y: yIndex * subcontainersConfig.height,
        width: subcontainersConfig.width,
        height: subcontainersConfig.height
      });

      subcontainerList[xIndex][yIndex] = thisSubcontainer;
      thisSubcontainer.x = xIndex * subcontainersConfig.width;
      thisSubcontainer.y = yIndex * subcontainersConfig.height;
      thisSubcontainer.visible = subcontainersConfig.isHiddenByDefault ? false : true;
    }

    displayObject.x -= thisSubcontainer.x;
    displayObject.y -= thisSubcontainer.y;
    subcontainerList[xIndex][yIndex].addChild(displayObject);

    return subcontainerList[xIndex][yIndex];
  }
  /**
   * Get the closest subcontainers of the given area.
   *
   * @method setCorrectSubcontainer
   * @private
   * @static
   * @method getClosestSubcontainers
   * @param  {Object} layer                         Instance of PIXI.Container - The layer being used
   * @param  {Number} xIndex                        x / horizontal index.
   * @param  {Number} yIndex                        y / vertical index.
   * @param  {Object} options                       Optional options.
   * @param  {MapDataManipulator} options.filter    Filter for selecting only wanted subcontainers
   * @return {Array}                                Array of found subcontainers.
   */
  function getClosestSubcontainers(layer, givenCoordinates) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? { filter: undefined } : arguments[2];
    var filter = options.filter;

    var coordinates = {
      x: givenCoordinates.x >= 0 ? givenCoordinates.x : 0,
      y: givenCoordinates.y >= 0 ? givenCoordinates.y : 0,
      width: givenCoordinates.width,
      height: givenCoordinates.height
    };

    var _layer$getSubcontainerConfigs = layer.getSubcontainerConfigs();

    var width = _layer$getSubcontainerConfigs.width;
    var height = _layer$getSubcontainerConfigs.height;

    var allFoundSubcontainers = [];
    var xIndex = Math.floor(coordinates.x / width);
    var yIndex = Math.floor(coordinates.y / height);
    var x2 = coordinates.width ? coordinates.x + coordinates.width : +coordinates.x;
    var y2 = coordinates.height ? coordinates.y + coordinates.height : +coordinates.y;
    var widthIndex = Math.floor(x2 / width);
    var heightIndex = Math.floor(y2 / height);
    var subcontainerList = layer.subcontainerList;

    for (var thisXIndex = xIndex; thisXIndex <= widthIndex; thisXIndex++) {
      if (thisXIndex >= 0 && subcontainerList && subcontainerList[thisXIndex]) {
        for (var thisYIndex = yIndex; thisYIndex <= heightIndex; thisYIndex++) {
          if (thisYIndex >= 0 && subcontainerList[thisXIndex][thisYIndex]) {
            if (filter && !filter.filterSubcontainers(subcontainerList[thisXIndex][thisYIndex])) {
              continue;
            }
            allFoundSubcontainers.push(subcontainerList[thisXIndex][thisYIndex]);
          }
        }
      }
    }

    return allFoundSubcontainers;
  }
  return {
    setters: [function (_npmBabelRuntime5824HelpersGetJs) {
      _get = _npmBabelRuntime5824HelpersGetJs["default"];
    }, function (_npmBabelRuntime5824HelpersInheritsJs) {
      _inherits = _npmBabelRuntime5824HelpersInheritsJs["default"];
    }, function (_npmBabelRuntime5824HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5824HelpersCreateClassJs["default"];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs["default"];
    }, function (_npmBabelRuntime5824CoreJsObjectAssignJs) {
      _Object$assign = _npmBabelRuntime5824CoreJsObjectAssignJs["default"];
    }],
    execute: function () {
      'use strict';

      /*---------------------
      ------ VARIABLES ------
      ---------------------*/
      _UIObjects = [];

      /*---------------------
      -------- EXPORT -------
      ---------------------*/

      MapLayer = (function (_PIXI$Container) {
        _inherits(MapLayer, _PIXI$Container);

        /**
         * Creates a basic layer for the Map. This type of layer can not hold subcontainers. Note that different devices and graphic cards can only have specific size of bitmap drawn, and PIXI cache always draws a bitmap thus the default is: 4096, based on this site: http://webglstats.com/ and MAX_TEXTURE_SIZE. This is important also when caching.
         *
         * @class MapLayer
         * @constructor
         * @param {Object} options                            optional options
         * @param {String} options.name                       Layers name, used for identifying the layer. Useful in debugging, but can be used for finding correct layers too
         * @param  {Object} options.coord                   coord starting coords of layer. Relative to parent map layer.
         * @param  {Integer} options.coord.x         X coordinate
         * @param  {Integer} options.coord.y         Y coordinate
         * @param  {Object} options.specialLayer            Is this layer special (e.g. UILayer not included in normal operations)
         * @param  {Integer} options.specialLayer.x         X coordinate
         * @param  {Integer} options.specialLayer.y         Y coordinate
         **/

        function MapLayer() {
          var options = arguments.length <= 0 || arguments[0] === undefined ? {
            name: "",
            coord: { x: 0, y: 0 },
            specialLayer: false,
            selectable: false } : arguments[0];

          _classCallCheck(this, MapLayer);

          var name = options.name;
          var coord = options.coord;
          var specialLayer = options.specialLayer;
          var selectable = options.selectable;

          _get(Object.getPrototypeOf(MapLayer.prototype), "constructor", this).call(this);
          _Object$assign(this, coord);

          /**
           * Layers name, used for identifying the layer. Useful in debugging, but can be used for finding correct layers too
           *
           * @attribute name
           * @type {String}
           */
          this.name = "" + name;
          /**
           * Is this layer special (e.g. UILayer not included in normal operations)
           *
           * @attribute specialLayer
           * @type {Boolean}
           */
          this.specialLayer = !!specialLayer;
          /**
           * Can you select objects from this layer. For example with Map.getObjectsUnderArea
           *
           * @attribute selectable
           * @type {Boolean}
           */
          this.selectable = selectable;
        }

        /**
         * Does this layer use subcontainers.
         *
         * @method hasSubcontainers
         * @return {Boolean} true = uses subcontainers.
         */

        _createClass(MapLayer, [{
          key: "hasSubcontainers",
          value: function hasSubcontainers() {
            return this.subcontainersConfig ? true : false;
          }

          /**
           * Is this layer cached at the moment or not.
           *
           * @method isCached
           * @return {Boolean} true = is cached
           */
        }, {
          key: "isCached",
          value: function isCached() {
            return this.cacheAsBitmap;
          }

          /**
           * Move layer based on given amounts
           *
           * @method move
           * @param  {Object} coord            The amount of x and y coordinates we want the layer to move. I.e. { x: 5, y: 0 }. This would move the map 5 pixels horizontally and 0 pixels vertically
           * @param  {Integer} coord.x         X coordinate
           * @param  {Integer} coord.y         Y coordinate
           **/
        }, {
          key: "move",
          value: function move(coord) {
            this.x += coord.x;
            this.y += coord.y;
            this.drawThisChild = true;
          }

          /**
           * set layer zoom
           *
           * @method setZoom
           * @param {Number} amount The amount that you want the layer to zoom.
           * @return {Number} The same amount that was given, except after transform to 2 decimals and type cast to Number
           * */
        }, {
          key: "setZoom",
          value: function setZoom(amount) {
            this.scale.x = this.scale.y = +amount.toFixed(2);

            return this.scale.x;
          }

          /**
           * get layer zoom
           *
           * @method getZoom
           * @return {Boolean} current amount of zoom
           * */
        }, {
          key: "getZoom",
          value: function getZoom() {
            return this.scale.x;
          }

          /**
          * get UIObjects on this layer, if there are any, or defaulty empty array if no UIObjects are active
          *
          * @method getUIObjects
          * @return {Array} current UIObjects
          * */
        }, {
          key: "getUIObjects",
          value: function getUIObjects() {
            return _UIObjects;
          }

          /**
           * Remove all the UIObjects from this layer
           *
           * @method emptyUIObjects
           * @return {Array} empty UIObjects array
           * */
        }, {
          key: "emptyUIObjects",
          value: function emptyUIObjects() {
            var _this = this;

            _UIObjects.map(function (obj) {
              _this.getUILayer().removeChild(obj);
              obj = null;
            });

            return _UIObjects;
          }

          /**
           * Get primary layers, that this layer holds as children. So basically all children that are not special layers (such as UI layers etc.)
           *
           * @method getPrimaryLayers
           * @return {Array}                            Primary children layers under this layer
           * */
        }, {
          key: "getPrimaryLayers",
          value: function getPrimaryLayers() {
            return this.children.filter(function (thisChild) {
              return !thisChild.specialLayer;
            });
          }

          /**
           * Get all objects that are this layers children or subcontainers children. Does not return layers, but the objects.
           *
           * @method getObjects
           * @return {Array}                            All the objects (not layers) found under this layer
           * */
        }, {
          key: "getObjects",
          value: function getObjects() {
            var allObjects = [];

            if (this.hasSubcontainers()) {
              this.subcontainerList.forEach(function (subcontainer) {
                allObjects.concat(subcontainer.children);
              });
            }

            return allObjects;
          }

          /**
           * @todo IMPLEMENT CACHE PROPERLY! TAKE SUBCONTAINERS INTO ACCOUNT!
           *
           * Sets layer cache on or off.
           *
           * @method setCache
           * @param {Boolean} status      true = activate cache, false = disable cache
           */
        }, {
          key: "setCache",
          value: function setCache(status) {
            var toCacheStatus = status ? true : false;

            this.cacheAsBitmap = toCacheStatus;

            return toCacheStatus;
          }

          /**
           * Create and add special layer, that holds UI effects in it.
           *
           * @method createUILayer
           * @param  {String} name          name of the layer
           * @param  {Object} coord         Coordinates of the layer
           * @param  {Integer} coord.x      X coordinate
           * @param  {Integer} coord.y      Y coordinate
           * @return {MapLayer}            The created UI layer
           **/
        }, {
          key: "createUILayer",
          value: function createUILayer() {
            var name = arguments.length <= 0 || arguments[0] === undefined ? "default UI layer" : arguments[0];
            var coord = arguments.length <= 1 || arguments[1] === undefined ? { x: 0, y: 0 } : arguments[1];

            var layer = new MapLayer(name, coord);

            layer.specialLayer = true;
            this.addChild(layer);

            this.UILayer = layer;

            return layer;
          }

          /**
           * Adds and object to this layers UILayer child.
           *
           * @method addUIObject
           * @param {Object} object   The UI object to be added under this layer
           * @return {Array}          All the UIObjects currently on this layer
           */
        }, {
          key: "addUIObject",
          value: function addUIObject(object) {
            var UILayer;
            _UIObjects = _UIObjects || [];

            if (!this.getUILayer()) {
              UILayer = this.createUILayer();
            } else {
              UILayer = this.getUILayer;
            }

            this.UILayer.addChild(object);
            _UIObjects.push(object);

            return _UIObjects;
          }

          /**
           * Return the UILayer. If no UILayer is yet created, will return undefined
           *
           * @method getUILayer
           * @return {MapLayer | undefined}
           */
        }, {
          key: "getUILayer",
          value: function getUILayer() {
            return this.UILayer;
          }
        }]);

        return MapLayer;
      })(PIXI.Container);

      _export("MapLayer", MapLayer);

      MapLayerParent = (function (_MapLayer) {
        _inherits(MapLayerParent, _MapLayer);

        /**
         * Layer designed to hold subcontainers. But can handle objects too. Different devices graphic cards can only have specific size of bitmap drawn, and PIXI cache always draws a bitmap. Thus the default is: 4096, based on this site: http://webglstats.com/ and MAX_TEXTURE_SIZE
         *
         * @class MapLayerParent
         * @constructor
         * @param {Object} options
         * @param {String} options.name                    name layer property name, used for identifiying the layer, usefull in debugging, but used also otherwise too
         * @param  {Object} options.coord                  starting coords of layer. Relative to parent map layer.
         * @param  {Integer} options.coord.x               X coordinate
         * @param  {Integer} options.coord.y               Y coordinate
         * @param  {Object} options.subcontainers          Subontainer size. If given activated subcontainers, otherwise not.
         * @param  {Integer} options.subcontainers.width   width (in pixels)
         * @param  {Integer} options.subcontainers.height  height (in pixels)
         * @param {Boolean} options.specialLayer           Is this special layer or not.
         */

        function MapLayerParent() {
          var options = arguments.length <= 0 || arguments[0] === undefined ? { name: "", coord: { x: 0, y: 0 }, subcontainers: false, specialLayer: false, selectable: false } : arguments[0];

          _classCallCheck(this, MapLayerParent);

          var subcontainers = options.subcontainers;
          var selectable = options.selectable;
          var specialLayer = options.specialLayer;

          _get(Object.getPrototypeOf(MapLayerParent.prototype), "constructor", this).call(this, options);

          this.oldAddChild = _get(Object.getPrototypeOf(MapLayerParent.prototype), "addChild", this).bind(this);
          this.subcontainersConfig = subcontainers;
          this.subcontainerList = [];
          this.selectable = selectable;
          this.specialLayer = specialLayer;
        }

        /**
         * We override the PIXIs own addchild functionality. Since we need to support subcontainers in addChild. We check subcontainers and then we call the original (PIXIs) addChild
         *
         * @method addChild
         * @param {PIXI.DisplayObject} displayObject      PIXI.DisplayObject
         */

        _createClass(MapLayerParent, [{
          key: "addChild",
          value: function addChild(displayObject) {
            if (this.hasSubcontainers()) {
              var correctContainer = undefined;
              correctContainer = setCorrectSubcontainer(displayObject, this);
              this.oldAddChild(correctContainer);
            } else {
              this.oldAddChild(displayObject);
            }

            return displayObject;
          }

          /**
           * Returns the configurations set for subcontainers.
           *
           * @method getSubcontainerConfigs
           */
        }, {
          key: "getSubcontainerConfigs",
          value: function getSubcontainerConfigs() {
            return this.subcontainersConfig;
          }

          /**
           * Returns subcontainers based on the given coordinates. Can be applied through a MapDataManipulator filter also.
           *
           * @method getSubcontainersByCoordinates
           * @param  {Object} coordinates
           * @param  {Integer} coordinates.x                  X coordinate
           * @param  {Integer} coordinates.y                  Y coordinate
           * @param  {Object} options                         Optional options.
           * @param  {MapDataManipulator} options.filter      Filter for selecting only certain subcontainers
           */
        }, {
          key: "getSubcontainersByCoordinates",
          value: function getSubcontainersByCoordinates(coordinates) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? { filter: undefined } : arguments[1];

            if (!this.hasSubcontainers()) {
              throw new Error("tried to retrieve subcontainers, when they are not present");
            }

            var foundSubcontainers, tempCoordinates;
            var filter = options.filter;

            tempCoordinates = this.toLocal(new PIXI.Point(coordinates.x, coordinates.y));
            tempCoordinates.width = coordinates.width;
            tempCoordinates.height = coordinates.height;

            foundSubcontainers = getClosestSubcontainers(this, tempCoordinates, { filter: filter });

            return foundSubcontainers;
          }

          /**
           * @method getSubcontainers
           */
        }, {
          key: "getSubcontainers",
          value: function getSubcontainers() {
            return this.subcontainerList;
          }
        }]);

        return MapLayerParent;
      })(MapLayer);

      _export("MapLayerParent", MapLayerParent);

      MapSubcontainer = (function (_PIXI$Container2) {
        _inherits(MapSubcontainer, _PIXI$Container2);

        /**
         * Subcontainers are containers that hold objects like units and terrain etc. under them. They have some restrictions atm. since they are PIXI.ParticleContainers. But when needed we can extend MapLayers with another class which is subcontainer, but not ParticleContainer at the present there is no need, so we won't extend yet. Subcontainers help the layers to make better movement of the map, by making subcontainers visible or invisible and even helping with selecting objects on the map. Thus we don't need to use our inefficient Quadtree. The intention was to use PIXI.ParticleContainer for this, but it seems it doesn't clean up the memory afterwards the same way as normal Container.
         *
         * @private
         * @class MapSubcontainer
         * @constructor
         * @param  {Object} size              Subontainer size. If given activated subcontainers, otherwise not.
         * @param  {Integer} size.width       width (in pixels)
         * @param  {Integer} size.height      height (in pixels)
         */

        function MapSubcontainer(size) {
          _classCallCheck(this, MapSubcontainer);

          _get(Object.getPrototypeOf(MapSubcontainer.prototype), "constructor", this).call(this);

          this.specialLayer = true;
          this.size = size;
          this.selectable = false;
        }

        /**
         * Gets this subcontainers coordinates and size
         *
         * @method getSubcontainerArea
         * @param {Number} scale                              The size of scale the map currently has
         * @param {Boolean} options.toGlobal                  Do we get the global coordinates or local
         */

        _createClass(MapSubcontainer, [{
          key: "getSubcontainerArea",
          value: function getSubcontainerArea(scale) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? { toGlobal: true } : arguments[1];

            var coordinates;

            coordinates = options.toGlobal ? this.toGlobal(new PIXI.Point(0, 0)) : this;
            if (scale) {
              coordinates.x /= scale;
              coordinates.y /= scale;
            }

            return {
              x: Math.round(coordinates.x),
              y: Math.round(coordinates.y),
              width: Math.round(this.size.width),
              height: Math.round(this.size.height)
            };
          }

          /**
           * Set cache on or off for this layer
           *
           * @method setCache
           * @param {Boolean} status      true = activate cache, false = disable cache
           */
        }, {
          key: "setCache",
          value: function setCache(status) {
            var toCacheStatus = status ? true : false;

            this.cacheAsBitmap = toCacheStatus;

            return toCacheStatus;
          }
        }]);

        return MapSubcontainer;
      })(PIXI.Container);
    }
  };
});
System.register('components/map/core/mapEvents.js', [], function (_export) {
  'use strict';

  /*---------------------
  --------- API ---------
  ----------------------*/
  var mapEvents;

  /*---------------------
  -------- PUBLIC -------
  ----------------------*/
  /**
   * This module handles map events. Like informing map movement, object selection and other changes.
   * Events atm:
   * - mapMoved
   * - mapResize
   * - mapFullscreeActivated
   *
   * @class mapEvents
   * @return {Object}     subsribe and publish
   * @todo I want the pubsub module to go the ES6 way, not the only global exception!
   */
  function setupMapEvents() {
    return {
      subscribe: subscribe,
      publish: publish
    };

    function subscribe(type, cb) {
      document.addEventListener(type, cb);
    }
    function publish(type) {
      var eventToDispatch = new Event(type);

      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      eventToDispatch.customData = data;
      document.dispatchEvent(eventToDispatch);
    }
  }
  return {
    setters: [],
    execute: function () {
      mapEvents = setupMapEvents();

      _export('mapEvents', mapEvents);
    }
  };
});
System.register('components/utilities/general.js', [], function (_export) {
  'use strict';

  /*-----------------------
  ---------- API ----------
  -----------------------*/
  var arrays;

  /*-----------------------
  --------- PUBLIC --------
  -----------------------*/
  /**
   * Array manipulation
   *
   * @class utilities.arrays
   */
  function setupArrays() {
    return {
      flatten2Levels: flatten2Levels
    };

    /**
     * Flattern 2 levels deep, 2-dimensional arrays. Credits: http://stackoverflow.com/a/15030117/1523545
     *
     * @method flatten2Levels
     * @param  {Array} arr        Array to flatten
     * @return {Array}            Flattened array
     */
    function flatten2Levels(arr) {
      return [].concat.apply([], arr);
    }
  }
  return {
    setters: [],
    execute: function () {
      arrays = setupArrays();

      _export('arrays', arrays);
    }
  };
});
System.register('components/map/core/ObjectManager.js', ['npm:babel-runtime@5.8.24/helpers/create-class.js', 'npm:babel-runtime@5.8.24/helpers/class-call-check.js', 'bundles/strippedCoreBundle.js', 'components/utilities/general.js'], function (_export) {
  var _createClass, _classCallCheck, utils, arrays, ObjectManager;

  return {
    setters: [function (_npmBabelRuntime5824HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5824HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs['default'];
    }, function (_bundlesStrippedCoreBundleJs) {
      utils = _bundlesStrippedCoreBundleJs.utils;
    }, function (_componentsUtilitiesGeneralJs) {
      arrays = _componentsUtilitiesGeneralJs.arrays;
    }],
    execute: function () {

      /*---------------------
      --------- API ---------
      ----------------------*/

      /*---------------------
      ------- IMPORT --------
      ----------------------*/
      'use strict';
      ObjectManager = (function () {
        /**
         * this module is responsible for doing hitTesting, like returning the units on certain clicked coordinates or when objects or areas collide with each other.
         *
         * @class ObjectManager
         * @constructor
         * @param {object} hitDetector Object or function that handles hit detection. This can be omitted in many cases
         * @todo It might be a good idea to make the hitDetection more extensive. Now it just uses point or rectangle / bounds to detect hits. It could use sprites or forms.
         */

        function ObjectManager(hitDetector) {
          _classCallCheck(this, ObjectManager);

          this.hitDetector = hitDetector || {};
        }

        /**
         * Retrieve objects under certain coordinates or area, if size is given. Uses subcontainers when used, no other options yet.
         *
         * @method retrieve
         * @param {Object} allCoords                                The coordinates which we want to hitTest
         * @param {x:Integer, y:Integer} allCoords.globalCoords     Global coordinates on static layer / canvas
         * @param {x:Integer, y:Integer} allCoords.globalCoords.x
         * @param {x:Integer, y:Integer} allCoords.globalCoords.y
         * @param {Object} allCoords.localCoords                    Local coordiantes on movable layer
         * @param {x:Integer, y:Integer} allCoords.localCoords.x
         * @param {x:Integer, y:Integer} allCoords.localCoords.y
         * @param {string} type                                     type of the object / layer that we want to retrieve
         * @param {Object} options                                  optional options
         * @param {Array} options.subcontainers                     The subcontainers we match against
         * @param {Object} options.size                             Size of the rectangle area to match against, if we want to match rectangle instead of one point
         * @param {Integer} options.size.width
         * @param {Integer} options.size.height
         * @return {Array}                                          matched objects
         */

        _createClass(ObjectManager, [{
          key: 'retrieve',
          value: function retrieve(allCoords) {
            var _this = this;

            var options = arguments.length <= 1 || arguments[1] === undefined ? { type: false, subcontainers: [], size: { width: 0, height: 0 } } : arguments[1];
            var subcontainers = options.subcontainers;
            var size = options.size;
            var type = options.type;
            var globalCoords = allCoords.globalCoords;
            var localCoords = allCoords.localCoords;

            var foundObjs = [];

            if (subcontainers.length > 0) {
              subcontainers.forEach(function (container) {
                foundObjs = foundObjs.concat(container.children);
              });

              if (!size.width || !size.height) {
                foundObjs = foundObjs.filter(function (obj) {
                  if (type && type !== obj.type) {
                    return false;
                  }

                  var isHit = obj.hitTest ? obj.hitTest(globalCoords, { hitDetector: _this.hitDetector }) : true;

                  return isHit;
                });
              }
            }

            return foundObjs;
          }
        }]);

        return ObjectManager;
      })();

      _export('ObjectManager', ObjectManager);
    }
  };
});
System.register("components/map/core/UI.js", [], function (_export) {
  'use strict';

  /*---------------------
  ------ VARIABLES ------
  ----------------------*/
  var scope;

  /*---------------------
  -------- PUBLIC -------
  ----------------------*/
  /**
   * Main class for showing UI on the map. Like unit selections and such. Has nothing to do with showing off-map data.
   * Good examples for what this shows are: selected units-list, selection highlight (like a circle on the selected unit) and bringing the unit on top in the map. UI themes must implement this core UI module
   *
   * @todo Not implemented fully yet and probably need refactoring
   *
   * @class UI
   * @constructor
   * @param {Object} UITheme        Module that will be used for the UI theme
   * @param {Map} givenMap          Map instance that is used
   * @return {Object}               UI module
  */
  function UI(UITheme, givenMap) {
    var map;

    /* SINGLETON MODULE */
    if (scope) {
      return scope;
    }

    if (!UITheme || !givenMap) {
      throw new Error("UI-module requires UITheme and map object");
    }

    map = givenMap;
    scope = {};

    /**
     * Responsible for showing selection element, where the player select the wanted object out of array of objects.
     * For example if there are several objects in one tile on the map and the player needs to be able to select one
     * specific unit on the stack. This is always defined in the UI theme-module
     *
     * @method showSelections
     * @static
     * @param  {Array} objects     Objects that have been selected.
     * @param {Object} getDatas       This is an object made of functions, that get wanted data from the object. For example if you have objects name in object.data.specialData.name, then you have an object getDatas.name(), which retrieves this.
     * @param {Object} getDatas.name  Retrieves object name
     * @param {Object} options        Extra options
     * @return {Boolean}
     * */
    scope.showSelections = function (objects, getDatas, options) {
      objects = filterObjectsForHighlighting(objects);

      if (objects.length === 1) {
        return UITheme.highlightSelectedObject(objects[0], getDatas);
      } else if (objects.length > 1) {
        return UITheme.showSelections(objects, getDatas);
      }

      return "No objects found";
    };
    /**
     * Resonsible for hignlighting the selected object. For example the unit that is being commanded. The hightlight
     * can mean e.g. bringing the unit on top on the map and showing selection circle around it.
     *
     * @method highlightSelectedObject
     * @static
     * @param  {Object} object        Object that has been selected.
     * @param {Object} getDatas       This is an object made of functions, that get wanted data from the object. For example if you have objects name in object.data.specialData.name, then you have an object getDatas.name(), which retrieves this.
     * @param {Object} getDatas.name  Retrieves object name
     * @param {Object} options        Extra options. Like dropping a shadow etc.
     * */
    scope.highlightSelectedObject = function (object, getDatas, options) {
      UITheme.highlightSelectedObject(object);
    };
    /**
     * Shows arrow or movement or what ever to indicate the selected unit is moving to the given location
     *
     * @method showUnitMovement
     * @static
     * */
    scope.showUnitMovement = function (object, from, to, options) {
      UITheme.showUnitMovement(object, from, to, options);
    };

    return scope;
  }
  /*--------------------------------
  ------------ PRIVATE -------------
  --------------------------------*/
  /**
   * This is a general function which filters only highlightable object for use in UI operations
   *
   * @static
   * @method filterObjectsForHighlighting
   * @param  {Array} objects
   */
  function filterObjectsForHighlighting(objects) {
    var newObjects = objects.filter(function (obj) {
      return obj.highlightable === true ? true : false;
    });

    return newObjects;
  }
  return {
    setters: [],
    execute: function () {

      /*---------------------
      --------- API ---------
      ----------------------*/

      _export("UI", UI);
    }
  };
});
System.registerDynamic("npm:core-js@1.1.4/library/modules/$.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.1.4/library/fn/object/define-property.js", ["npm:core-js@1.1.4/library/modules/$.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.1.4/library/modules/$.js');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/core-js/object/define-property.js", ["npm:core-js@1.1.4/library/fn/object/define-property.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.1.4/library/fn/object/define-property.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/helpers/create-class.js", ["npm:babel-runtime@5.8.24/core-js/object/define-property.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('npm:babel-runtime@5.8.24/core-js/object/define-property.js')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.24/helpers/class-call-check.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register('components/map/UIs/default/layout/CSSRules.js', [], function (_export) {
  'use strict';

  _export('createCSSRules', createCSSRules);

  function createCSSRules(classNames) {
    var dialogOptions = arguments.length <= 1 || arguments[1] === undefined ? { zIndex: 9999, opacity: 0.9 } : arguments[1];

    return '\n    ' + classNames.select + ' {\n      z-index: ' + dialogOptions.zIndex + ';\n      opacity: ' + dialogOptions.opacity + ';\n      position: fixed;\n      left: 0px;\n      bottom: 0px;\n      background-color: brown;\n      border: 1px solid rgb(255, 186, 148);;\n      border-bottom: 0px;\n      padding:15px;\n      margin-left:10px;\n    }';
  }

  return {
    setters: [],
    execute: function () {}
  };
});
System.register('components/map/core/UI_themeBase.js', ['npm:babel-runtime@5.8.24/helpers/create-class.js', 'npm:babel-runtime@5.8.24/helpers/class-call-check.js', 'components/map/UIs/default/layout/CSSRules.js'], function (_export) {
  var _createClass, _classCallCheck, createCSSRules, styleSheetElement, allCSSClasses, UI_templateBase;

  return {
    setters: [function (_npmBabelRuntime5824HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5824HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5824HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5824HelpersClassCallCheckJs['default'];
    }, function (_componentsMapUIsDefaultLayoutCSSRulesJs) {
      createCSSRules = _componentsMapUIsDefaultLayoutCSSRulesJs.createCSSRules;
    }],
    execute: function () {

      /*---------------------
      ------ VARIABLES ------
      ----------------------*/
      'use strict';

      /*---------------------
      ------- IMPORT --------
      ----------------------*/

      /*---------------------
      --------- API ---------
      ----------------------*/

      UI_templateBase = (function () {
        /**
         * The template base class for UI templates
         *
         * @todo This needs a bit of redesign.
         *
         * @class UI_templateBase
         * @constructor
         * @param  {*} CSSClasses
         */

        function UI_templateBase(CSSClasses) {
          _classCallCheck(this, UI_templateBase);

          allCSSClasses = CSSClasses;
          styleSheetElement = this.addStyleElement();
          var createdCSS = createCSSRules(allCSSClasses);
          this.addCSSRulesToScriptTag(styleSheetElement, createdCSS);
        }

        /**
         * Get the stylesheet element. Where are the defined CSS is
         *
         * @method getStyleSheetElement
         * @return {HTMLElement}
         */

        _createClass(UI_templateBase, [{
          key: 'getStyleSheetElement',
          value: function getStyleSheetElement() {
            return styleSheetElement;
          }

          /**
           * @method getCSSClasses
           */
        }, {
          key: 'getCSSClasses',
          value: function getCSSClasses() {
            return allCSSClasses;
          }

          /**
           * @method addCSSRulesToScriptTag
           *
           * @param {Object} sheet
           * @param {Object} rules
           */
        }, {
          key: 'addCSSRulesToScriptTag',
          value: function addCSSRulesToScriptTag(sheet, rules) {
            sheet.insertRule(rules, 0);
          }

          /**
           * @method addStyleElement
           */
        }, {
          key: 'addStyleElement',
          value: function addStyleElement() {
            var _styleElement = document.createElement("style");
            // WebKit hack :(
            _styleElement.appendChild(document.createTextNode(""));
            document.head.appendChild(_styleElement);

            return _styleElement.sheet;
          }

          /**
           * @method showModal
           *
           * @param {HTMLElement} modalElem
           * @param {Object} cssClasses
           * @todo make sure / check, that modalElem.classList.add gets added only once
           */
        }, {
          key: 'showModal',
          value: function showModal(modalElem, cssClasses) {
            modalElem.classList.add(cssClasses.select);
            /* Would be HTML 5.1 standard, but that might be a long way
              this.modal.show();*/
          }
        }]);

        return UI_templateBase;
      })();

      _export('UI_templateBase', UI_templateBase);
    }
  };
});
System.register('bundles/strippedCoreBundle.js', ['assets/lib/pixi/pixi.js', 'assets/lib/hamsterjs/hamster.js', 'assets/lib/polyfills/es6StringPoly/es6StringPoly.js', 'components/map/core/utils/index.js', 'components/map/core/Objects.js', 'components/map/core/eventlisteners.js', 'components/map/core/Map.js', 'components/map/core/MapDataManipulator.js', 'components/map/core/MapLayers.js', 'components/map/core/mapEvents.js', 'components/map/core/ObjectManager.js', 'components/map/core/UI.js', 'components/map/core/UI_themeBase.js'], function (_export) {

  /* Adds to glocal namespace! */
  'use strict';

  /*
   * This one bundles the core functionality by importing and re-exporting the core functionality. You can then use
   * some bundler or transpiler, like JSPM to bundle the core functionality to one build-file.
   */

  // purely for internet explorer. Though I think this issue is only in EI11,not in edge?
  var PIXI, hamster, es6StringPoly;
  return {
    setters: [function (_assetsLibPixiPixiJs) {
      PIXI = _assetsLibPixiPixiJs;
    }, function (_assetsLibHamsterjsHamsterJs) {
      hamster = _assetsLibHamsterjsHamsterJs;
    }, function (_assetsLibPolyfillsEs6StringPolyEs6StringPolyJs) {
      es6StringPoly = _assetsLibPolyfillsEs6StringPolyEs6StringPolyJs;
    }, function (_componentsMapCoreUtilsIndexJs) {
      var _exportObj4 = {};

      for (var _key in _componentsMapCoreUtilsIndexJs) {
        if (_key !== 'default') _exportObj4[_key] = _componentsMapCoreUtilsIndexJs[_key];
      }

      _export(_exportObj4);
    }, function (_componentsMapCoreObjectsJs) {
      var _exportObj5 = {};

      for (var _key2 in _componentsMapCoreObjectsJs) {
        if (_key2 !== 'default') _exportObj5[_key2] = _componentsMapCoreObjectsJs[_key2];
      }

      _export(_exportObj5);
    }, function (_componentsMapCoreEventlistenersJs) {
      var _exportObj6 = {};

      for (var _key3 in _componentsMapCoreEventlistenersJs) {
        if (_key3 !== 'default') _exportObj6[_key3] = _componentsMapCoreEventlistenersJs[_key3];
      }

      _export(_exportObj6);
    }, function (_componentsMapCoreMapJs) {
      var _exportObj7 = {};

      for (var _key4 in _componentsMapCoreMapJs) {
        if (_key4 !== 'default') _exportObj7[_key4] = _componentsMapCoreMapJs[_key4];
      }

      _export(_exportObj7);
    }, function (_componentsMapCoreMapDataManipulatorJs) {
      var _exportObj8 = {};

      for (var _key5 in _componentsMapCoreMapDataManipulatorJs) {
        if (_key5 !== 'default') _exportObj8[_key5] = _componentsMapCoreMapDataManipulatorJs[_key5];
      }

      _export(_exportObj8);
    }, function (_componentsMapCoreMapLayersJs) {
      var _exportObj9 = {};

      for (var _key6 in _componentsMapCoreMapLayersJs) {
        if (_key6 !== 'default') _exportObj9[_key6] = _componentsMapCoreMapLayersJs[_key6];
      }

      _export(_exportObj9);
    }, function (_componentsMapCoreMapEventsJs) {
      var _exportObj10 = {};

      for (var _key7 in _componentsMapCoreMapEventsJs) {
        if (_key7 !== 'default') _exportObj10[_key7] = _componentsMapCoreMapEventsJs[_key7];
      }

      _export(_exportObj10);
    }, function (_componentsMapCoreObjectManagerJs) {
      var _exportObj11 = {};

      for (var _key8 in _componentsMapCoreObjectManagerJs) {
        if (_key8 !== 'default') _exportObj11[_key8] = _componentsMapCoreObjectManagerJs[_key8];
      }

      _export(_exportObj11);
    }, function (_componentsMapCoreUIJs) {
      var _exportObj12 = {};

      for (var _key9 in _componentsMapCoreUIJs) {
        if (_key9 !== 'default') _exportObj12[_key9] = _componentsMapCoreUIJs[_key9];
      }

      _export(_exportObj12);
    }, function (_componentsMapCoreUI_themeBaseJs) {
      var _exportObj13 = {};

      for (var _key10 in _componentsMapCoreUI_themeBaseJs) {
        if (_key10 !== 'default') _exportObj13[_key10] = _componentsMapCoreUI_themeBaseJs[_key10];
      }

      _export(_exportObj13);
    }],
    execute: function () {}
  };
});
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function(window, document, exportName, undefined) {
  'use strict';
  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;
  function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
  }
  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }
    return false;
  }
  function each(obj, iterator, context) {
    var i;
    if (!obj) {
      return;
    }
    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;
      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }
  function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
      var e = new Error('get-stack-trace');
      var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
      var log = window.console && (window.console.warn || window.console.log);
      if (log) {
        log.call(window.console, deprecationMessage, stack);
      }
      return method.apply(this, arguments);
    };
  }
  var assign;
  if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
      var output = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  } else {
    assign = Object.assign;
  }
  var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
      if (!merge || (merge && dest[keys[i]] === undefined)) {
        dest[keys[i]] = src[keys[i]];
      }
      i++;
    }
    return dest;
  }, 'extend', 'Use `assign`.');
  var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');
  function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;
    if (properties) {
      assign(childP, properties);
    }
  }
  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }
  function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
  }
  function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
  }
  function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
      target.addEventListener(type, handler, false);
    });
  }
  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
      target.removeEventListener(type, handler, false);
    });
  }
  function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }
  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }
  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }
  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;
      while (i < src.length) {
        if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
          return i;
        }
        i++;
      }
      return -1;
    }
  }
  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }
  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;
    while (i < src.length) {
      var val = key ? src[i][key] : src[i];
      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }
      values[i] = val;
      i++;
    }
    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function sortUniqueArray(a, b) {
          return a[key] > b[key];
        });
      }
    }
    return results;
  }
  function prefixed(obj, property) {
    var prefix,
        prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = (prefix) ? prefix + camelProp : property;
      if (prop in obj) {
        return prop;
      }
      i++;
    }
    return undefined;
  }
  var _uniqueId = 1;
  function uniqueId() {
    return _uniqueId++;
  }
  function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
  }
  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];
  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;
    this.domHandler = function(ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };
    this.init();
  }
  Input.prototype = {
    handler: function() {},
    init: function() {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },
    destroy: function() {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };
  function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;
    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
  }
  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;
    if (isFirst) {
      manager.session = {};
    }
    input.eventType = eventType;
    computeInputData(manager, input);
    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }
  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;
    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    }
    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }
    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length > session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);
    computeIntervalInputData(session, input);
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
      target = input.srcEvent.target;
    }
    input.target = target;
  }
  function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};
    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }
    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }
  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity,
        velocityX,
        velocityY,
        direction;
    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = input.deltaX - last.deltaX;
      var deltaY = input.deltaY - last.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }
    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }
  function simpleCloneInputData(input) {
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }
    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }
  function getCenter(pointers) {
    var pointersLength = pointers.length;
    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }
    var x = 0,
        y = 0,
        i = 0;
    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }
    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }
  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }
  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }
    if (abs(x) >= abs(y)) {
      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }
  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.sqrt((x * x) + (y * y));
  }
  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }
  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }
  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }
  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
  function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    this.allow = true;
    this.pressed = false;
    Input.apply(this, arguments);
  }
  inherit(MouseInput, Input, {handler: function MEhandler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type];
      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }
      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      }
      if (!this.pressed || !this.allow) {
        return;
      }
      if (eventType & INPUT_END) {
        this.pressed = false;
      }
      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }});
  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  };
  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT
  };
  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
  if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }
  function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    Input.apply(this, arguments);
    this.store = (this.manager.session.pointerEvents = []);
  }
  inherit(PointerEventInput, Input, {handler: function PEhandler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = (pointerType == INPUT_TYPE_TOUCH);
      var storeIndex = inArray(store, ev.pointerId, 'pointerId');
      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      }
      if (storeIndex < 0) {
        return;
      }
      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });
      if (removePointer) {
        store.splice(storeIndex, 1);
      }
    }});
  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
  function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;
    Input.apply(this, arguments);
  }
  inherit(SingleTouchInput, Input, {handler: function TEhandler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
      if (type === INPUT_START) {
        this.started = true;
      }
      if (!this.started) {
        return;
      }
      var touches = normalizeSingleTouches.call(this, ev, type);
      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }
      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }});
  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);
    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }
    return [all, changed];
  }
  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
  function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
    Input.apply(this, arguments);
  }
  inherit(TouchInput, Input, {handler: function MTEhandler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);
      if (!touches) {
        return;
      }
      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }});
  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }
    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;
    targetTouches = allTouches.filter(function(touch) {
      return hasParent(touch.target, target);
    });
    if (type === INPUT_START) {
      i = 0;
      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    }
    i = 0;
    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      }
      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }
      i++;
    }
    if (!changedTargetTouches.length) {
      return;
    }
    return [uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }
  function TouchMouseInput() {
    Input.apply(this, arguments);
    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
  }
  inherit(TouchMouseInput, Input, {
    handler: function TMEhandler(manager, inputEvent, inputData) {
      var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
          isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);
      if (isTouch) {
        this.mouse.allow = false;
      } else if (isMouse && !this.mouse.allow) {
        return;
      }
      if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
        this.mouse.allow = true;
      }
      this.callback(manager, inputEvent, inputData);
    },
    destroy: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  });
  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation';
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  TouchAction.prototype = {
    set: function(value) {
      if (value == TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }
      if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }
      this.actions = value.toLowerCase().trim();
    },
    update: function() {
      this.set(this.manager.options.touchAction);
    },
    compute: function() {
      var actions = [];
      each(this.manager.recognizers, function(recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    },
    preventDefaults: function(input) {
      if (NATIVE_TOUCH_ACTION) {
        return;
      }
      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection;
      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }
      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      if (hasNone) {
        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;
        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }
      if (hasPanX && hasPanY) {
        return;
      }
      if (hasNone || (hasPanY && direction & DIRECTION_HORIZONTAL) || (hasPanX && direction & DIRECTION_VERTICAL)) {
        return this.preventSrc(srcEvent);
      }
    },
    preventSrc: function(srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  };
  function cleanTouchActions(actions) {
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    }
    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }
    return TOUCH_ACTION_AUTO;
  }
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;
  function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});
    this.id = uniqueId();
    this.manager = null;
    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  Recognizer.prototype = {
    defaults: {},
    set: function(options) {
      assign(this.options, options);
      this.manager && this.manager.touchAction.update();
      return this;
    },
    recognizeWith: function(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }
      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }
      return this;
    },
    dropRecognizeWith: function(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    },
    requireFailure: function(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }
      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }
      return this;
    },
    dropRequireFailure: function(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);
      if (index > -1) {
        this.requireFail.splice(index, 1);
      }
      return this;
    },
    hasRequireFailures: function() {
      return this.requireFail.length > 0;
    },
    canRecognizeWith: function(otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    },
    emit: function(input) {
      var self = this;
      var state = this.state;
      function emit(event) {
        self.manager.emit(event, input);
      }
      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
      emit(self.options.event);
      if (input.additionalEvent) {
        emit(input.additionalEvent);
      }
      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    },
    tryEmit: function(input) {
      if (this.canEmit()) {
        return this.emit(input);
      }
      this.state = STATE_FAILED;
    },
    canEmit: function() {
      var i = 0;
      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }
        i++;
      }
      return true;
    },
    recognize: function(inputData) {
      var inputDataClone = assign({}, inputData);
      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      }
      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }
      this.state = this.process(inputDataClone);
      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    },
    process: function(inputData) {},
    getTouchAction: function() {},
    reset: function() {}
  };
  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }
    return '';
  }
  function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
      return 'down';
    } else if (direction == DIRECTION_UP) {
      return 'up';
    } else if (direction == DIRECTION_LEFT) {
      return 'left';
    } else if (direction == DIRECTION_RIGHT) {
      return 'right';
    }
    return '';
  }
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
      return manager.get(otherRecognizer);
    }
    return otherRecognizer;
  }
  function AttrRecognizer() {
    Recognizer.apply(this, arguments);
  }
  inherit(AttrRecognizer, Recognizer, {
    defaults: {pointers: 1},
    attrTest: function(input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    },
    process: function(input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input);
      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }
        return state | STATE_CHANGED;
      }
      return STATE_FAILED;
    }
  });
  function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);
    this.pX = null;
    this.pY = null;
  }
  inherit(PanRecognizer, AttrRecognizer, {
    defaults: {
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    },
    getTouchAction: function() {
      var direction = this.options.direction;
      var actions = [];
      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }
      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }
      return actions;
    },
    directionTest: function(input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY;
      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x != this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y != this.pY;
          distance = Math.abs(input.deltaY);
        }
      }
      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    },
    attrTest: function(input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },
    emit: function(input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);
      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }
      this._super.emit.call(this, input);
    }
  });
  function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(PinchRecognizer, AttrRecognizer, {
    defaults: {
      event: 'pinch',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function() {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function(input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },
    emit: function(input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }
      this._super.emit.call(this, input);
    }
  });
  function PressRecognizer() {
    Recognizer.apply(this, arguments);
    this._timer = null;
    this._input = null;
  }
  inherit(PressRecognizer, Recognizer, {
    defaults: {
      event: 'press',
      pointers: 1,
      time: 251,
      threshold: 9
    },
    getTouchAction: function() {
      return [TOUCH_ACTION_AUTO];
    },
    process: function(input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input;
      if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function() {
          this.state = STATE_RECOGNIZED;
          this.tryEmit();
        }, options.time, this);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }
      return STATE_FAILED;
    },
    reset: function() {
      clearTimeout(this._timer);
    },
    emit: function(input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }
      if (input && (input.eventType & INPUT_END)) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(RotateRecognizer, AttrRecognizer, {
    defaults: {
      event: 'rotate',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function() {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function(input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  });
  function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(SwipeRecognizer, AttrRecognizer, {
    defaults: {
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    },
    getTouchAction: function() {
      return PanRecognizer.prototype.getTouchAction.call(this);
    },
    attrTest: function(input) {
      var direction = this.options.direction;
      var velocity;
      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }
      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },
    emit: function(input) {
      var direction = directionStr(input.offsetDirection);
      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }
      this.manager.emit(this.options.event, input);
    }
  });
  function TapRecognizer() {
    Recognizer.apply(this, arguments);
    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }
  inherit(TapRecognizer, Recognizer, {
    defaults: {
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10
    },
    getTouchAction: function() {
      return [TOUCH_ACTION_MANIPULATION];
    },
    process: function(input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();
      if ((input.eventType & INPUT_START) && (this.count === 0)) {
        return this.failTimeout();
      }
      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType != INPUT_END) {
          return this.failTimeout();
        }
        var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;
        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }
        this._input = input;
        var tapCount = this.count % options.taps;
        if (tapCount === 0) {
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }
      return STATE_FAILED;
    },
    failTimeout: function() {
      this._timer = setTimeoutContext(function() {
        this.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    },
    reset: function() {
      clearTimeout(this._timer);
    },
    emit: function() {
      if (this.state == STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
  }
  Hammer.VERSION = '2.0.6';
  Hammer.defaults = {
    domEvents: false,
    touchAction: TOUCH_ACTION_COMPUTE,
    enable: true,
    inputTarget: null,
    inputClass: null,
    preset: [[RotateRecognizer, {enable: false}], [PinchRecognizer, {enable: false}, ['rotate']], [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}], [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']], [TapRecognizer], [TapRecognizer, {
      event: 'doubletap',
      taps: 2
    }, ['tap']], [PressRecognizer]],
    cssProps: {
      userSelect: 'none',
      touchSelect: 'none',
      touchCallout: 'none',
      contentZooming: 'none',
      userDrag: 'none',
      tapHighlightColor: 'rgba(0,0,0,0)'
    }
  };
  var STOP = 1;
  var FORCED_STOP = 2;
  function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function(item) {
      var recognizer = this.add(new (item[0])(item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  Manager.prototype = {
    set: function(options) {
      assign(this.options, options);
      if (options.touchAction) {
        this.touchAction.update();
      }
      if (options.inputTarget) {
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }
      return this;
    },
    stop: function(force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    },
    recognize: function(inputData) {
      var session = this.session;
      if (session.stopped) {
        return;
      }
      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers;
      var curRecognizer = session.curRecognizer;
      if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
        curRecognizer = session.curRecognizer = null;
      }
      var i = 0;
      while (i < recognizers.length) {
        recognizer = recognizers[i];
        if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        }
        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }
        i++;
      }
    },
    get: function(recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }
      var recognizers = this.recognizers;
      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event == recognizer) {
          return recognizers[i];
        }
      }
      return null;
    },
    add: function(recognizer) {
      if (invokeArrayArg(recognizer, 'add', this)) {
        return this;
      }
      var existing = this.get(recognizer.options.event);
      if (existing) {
        this.remove(existing);
      }
      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    },
    remove: function(recognizer) {
      if (invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }
      recognizer = this.get(recognizer);
      if (recognizer) {
        var recognizers = this.recognizers;
        var index = inArray(recognizers, recognizer);
        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }
      return this;
    },
    on: function(events, handler) {
      var handlers = this.handlers;
      each(splitStr(events), function(event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    },
    off: function(events, handler) {
      var handlers = this.handlers;
      each(splitStr(events), function(event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    },
    emit: function(event, data) {
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      }
      var handlers = this.handlers[event] && this.handlers[event].slice();
      if (!handlers || !handlers.length) {
        return;
      }
      data.type = event;
      data.preventDefault = function() {
        data.srcEvent.preventDefault();
      };
      var i = 0;
      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    },
    destroy: function() {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  };
  function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
      return;
    }
    each(manager.options.cssProps, function(value, name) {
      element.style[prefixed(element.style, name)] = add ? value : '';
    });
  }
  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }
  assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,
    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,
    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,
    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,
    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,
    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,
    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
  });
  var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {}));
  freeGlobal.Hammer = Hammer;
  if (typeof define === 'function' && define.amd) {
    define("github:hammerjs/hammer.js@2.0.6/hammer.js", [], function() {
      return Hammer;
    });
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
  } else {
    window[exportName] = Hammer;
  }
})(window, document, 'Hammer');

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("github:hammerjs/hammer.js@2.0.6.js", ["github:hammerjs/hammer.js@2.0.6/hammer.js"], function(main) {
  return main;
});

_removeDefine();
})();
System.register('components/map/core/baseEventlisteners/baseEventlisteners.js', ['github:hammerjs/hammer.js@2.0.6.js', 'bundles/coreBundle.js'], function (_export) {
  /* global Hammer, Hamster */

  /*-----------------------
  ---------- API ----------
  -----------------------*/
  'use strict';

  /*-----------------------
  --------- IMPORT --------
  -----------------------*/
  var eventListeners, baseEventlisteners;

  /*-----------------------
  -------- PUBLIC ---------
  -----------------------*/
  /**
   * Core plugin. Houses the default eventlisteners used in the map. When plugins are added to the map this class can be used for the eventlistener management.
   *
   * @class baseEventlisteners
   * @requires Hammer.js (for touch events)
   * @requires Hamster.js (for good cross-browser mousewheel events)
   * @param {HTMLElement} canvasElement   The canvas element we listen events from. Will try to search the first canvas in the DOM, if none is provided
   */
  function baseEventlistenersModule() {
    var CBs = {};
    var hammer, hamster, fullSize, fullscreen, zoom, drag, select, boundResizer;

    /*---------------------------
    ----------- API -------------
    ---------------------------*/
    return {
      init: init,
      pluginName: "baseEventlisteners"
    };

    function init(map) {
      hammer = new Hammer.Manager(map.canvas);
      hamster = new Hamster(map.canvas);

      eventListeners.setDetector("fullSize", fullSize().on, fullSize().off);
      eventListeners.setDetector("fullscreen", fullscreen().on, fullscreen().off);
      eventListeners.setDetector("zoom", zoom().on, zoom().off);
      eventListeners.setDetector("drag", drag().on, drag().off);
      eventListeners.setDetector("select", select().on, select().off);

      map.setPrototype("setFullsize", function () {
        /* We set this only once */
        boundResizer = boundResizer || map._resizeCanvas.bind(map);

        eventListeners.on("fullSize", boundResizer);
      });
      map.setPrototype("setFullScreen", function () {
        eventListeners.on("fullscreen", map._setFullScreen.bind(map));
      });
    }

    /**
     * Sets the canvas to fullsize as in the same size of the window / content area. But not fullscreen. Note that
     *
     * @method fullSizeListener
     * @private
     * @static
     */
    function fullSize() {
      return {
        on: function on(cb) {
          window.addEventListener("resize", cb);
        },
        off: function off(cb) {
          window.removeEventListener("resize", cb);
        }
      };
    }
    /**
     * Sets the browser in fullscreen mode.
     *
     * @method toggleFullscreen
     * @static
     * @param {Function} cb     Callback that fires when this event activates
     * @return {Boolean}        Return the state of this event
     */
    function fullscreen() {
      return {
        on: function on(cb) {
          window.addEventListener("fullscreen", cb);
        },
        off: function off(cb) {
          window.removeEventListener("fullscreen", cb);
        }
      };
    };
    /**
     * Zoom the map. Mousewheel (desktop) and pinch (mobile)
     *
     * @method toggleZoomListener
     * @static
     * @param {Function} cb     Callback that fires when this event activates
     * @return {Boolean}        Return the state of this event
     */
    function zoom() {
      return {
        on: function on(cb) {
          var pinch = new Hammer.Pinch();

          hammer.add(pinch);
          hammer.on("pinch", cb);
          /* Hamster handles wheel events really nicely */
          hamster.wheel(cb);
        },
        off: function off(cb) {
          hammer.on("pinch", cb);
          hamster.unwheel(cb);
        }
      };
    };
    /**
     * DragListener (normally used for moving the map)
     *
     * @method toggleDragListener
     * @static
     * @param {Function} cb     Callback that fires when this event activates
     * @return {Boolean}        Return the state of this event
     */
    function drag() {
      return {
        on: function on(cb) {
          var pan = new Hammer.Pan({
            pointers: 1,
            threshold: 5,
            direction: Hammer.DIRECTION_ALL });
          hammer.add(pan);
          hammer.on("pan", cb);
        },
        off: function off(cb) {
          hammer.off("pan", cb);
        }
      };
    };
    /**
     * Selecting something from the map
     *
     * @method toggleSelectListener
     * @static
     * @param {Function} cb     Callback that fires when this event activates
     * @return {Boolean}        Return the state of this event
     */
    function select() {
      return {
        on: function on(cb) {
          var tap = new Hammer.Tap();
          hammer.add(tap);
          hammer.on("tap", cb);
        },
        off: function off(cb) {
          hammer.off("tap", cb);
        }
      };
    }
  }
  return {
    setters: [function (_githubHammerjsHammerJs206Js) {}, function (_bundlesCoreBundleJs) {
      eventListeners = _bundlesCoreBundleJs.eventListeners;
    }],
    execute: function () {
      baseEventlisteners = baseEventlistenersModule();

      _export('baseEventlisteners', baseEventlisteners);
    }
  };
});
System.register('components/map/core/move/mapDrag.js', ['bundles/coreBundle.js'], function (_export) {

  /*---------------------
  --------- API ---------
  ----------------------*/

  /*---------------------
  ------- IMPORT --------
  ----------------------*/
  'use strict';var eventListeners, utils, mapDrag;

  /*---------------------
  -------- PUBLIC -------
  ----------------------*/
  /**
   * Core plugin for the engine. Handles moving the map by dragging the map with mouse or touch event. Core plugins can always be overwrote if needed.
   *
   * @class mapDrag
   * @requires Hammer.js - Mobile part requires
   * @return {Object}      init, _startDragListener
   */
  function setupMap_drag() {
    /* Function for setting and getting the mouse offset. Private functions declared bottom */
    var offsetCoords = _offsetCoords();
    var mapMoved = false;
    var eventListenerCB;

    /*--------------------
    ------- API ----------
    --------------------*/
    return {
      init: init,
      pluginName: "mapDrag",
      _startDragListener: _startDragListener /* Function revealed for testing */
    };

    /*---------------------
    -------- PUBLIC -------
    ----------------------*/
    /**
     * Required init functions for the plugin
     *
     * @method init
     * @param {Map} mapObj        The current instance of Map class
     * */
    function init(map) {
      eventListenerCB = _startDragListener(map);

      /* Singleton should have been instantiated before, we only retrieve it with 0 params */
      eventListeners.on("drag", eventListenerCB);
    }

    /*---------------------
    -------- PRIVATE ------
    ----------------------*/
    /**
     * Mobile version. Starts the functionality, uses Hammer.js heavily for doing the drag. More simple and better than
     * desktop version, since we don't need to calculate the drag with several event listener, one is enough with Hammer
     *
     * @private
     * @static
     * @method _startDragListener
     * @param {Map} map           The current instance of Map class
     */
    function _startDragListener(map) {
      var initialized = false;

      return function startDrag(e) {
        var coords;

        if (eventListeners.getActivityState("zoom")) {
          return false;
        }
        coords = utils.mouse.eventData.getHAMMERPointerCoords(e);

        mapMoved = true;

        coords.x = Math.round(coords.x);
        coords.y = Math.round(coords.y);

        if (!initialized) {
          offsetCoords.setOffset({
            x: coords.x,
            y: coords.y
          });
          initialized = true;

          return;
        } else if (e.isFinal === true) {
          initialized = false;
          mapMoved = false;
        }

        _mapMovement(e, map, coords);
      };
    }

    /**
     * This handles offset Changes and setting data has map been moved based on it. Also
     * sets basic settings like preventDefault etc.
     *
     * @private
     * @static
     * @method _mapMovement
     * @param  {Event} e                        The event being dealt with
     * @param  {Map} map                        The current instance of Map class
     * @param  {Coordinates} coords             Current pointer coordinates
     */
    function _mapMovement(e, map, coords) {
      var offset, moved;

      offset = offsetCoords.getOffset();
      moved = {
        x: coords.x - offset.x,
        y: coords.y - offset.y
      };

      if (moved.x > 0 || moved.y > 0 || moved.x < 0 || moved.y < 0) {
        map.moveMap(moved);
      } else {
        mapMoved = false;
      }

      offsetCoords.setOffset({
        x: coords.x,
        y: coords.y
      });

      e.preventDefault();
    }
    /**
     * Function for setting and getting the mouse offset.
     * Offset is the distance from the left upper coordinates (global 0, 0 coordinates) on the canvas, to the current /
     * last known mouse coordinates
     *
     * @private
     * @static
     * @method _offsetCoords
     */
    function _offsetCoords() {
      var offsetCoords;

      return {
        setOffset: setOffset,
        getOffset: getOffset
      };

      function setOffset(coords) {
        return offsetCoords = coords;
      }
      function getOffset() {
        return offsetCoords;
      }
    }
  }
  return {
    setters: [function (_bundlesCoreBundleJs) {
      eventListeners = _bundlesCoreBundleJs.eventListeners;
      utils = _bundlesCoreBundleJs.utils;
    }],
    execute: function () {
      mapDrag = setupMap_drag();

      _export('mapDrag', mapDrag);
    }
  };
});
System.register('components/map/core/zoom/mapZoom.js', ['bundles/coreBundle.js'], function (_export) {

  /*---------------------
  --------- API ---------
  ----------------------*/
  'use strict';

  /*---------------------
  ------- IMPORT --------
  ----------------------*/
  var eventListeners, utils, mapEvents, mapZoom;

  /*---------------------
  -------- PUBLIC -------
  ----------------------*/
  /**
   * Core plugin for the engine. Handles zooming for the map. Core plugins can always be overwrote if needed. Zooming happens when the user scrolls the mousewheel or in mobile, pinches the screen.
   *
   * @class mapZoom
   * @return {Object}      init
   */
  function setupMap_zoom() {
    /*---------------------
    ------ VARIABLES ------
    ----------------------*/
    var TIMEOUT_AFTER_ZOOM = 40;
    var initialized = false;
    var mobileInitialized = false;
    var difference = {};
    var map;
    /**
     * Maximum and minimum amount, the player can zoom the map
     *
     * @attribute zoomLimit
     * @type {{ farther: Number, closer: Number }}
     */
    var zoomLimit = {
      farther: 0.4,
      closer: 2.5
    };
    /**
     * How much one step of zooming affects
     *
     * @attribute zoomModifier
     * @type {Number}
     */
    var zoomModifier = 0.1;

    /*---------------------
    --------- API ---------
    ---------------------*/
    return {
      init: init,
      pluginName: "mapZoom"
    };

    /*---------------------
    ------- PUBLIC --------
    ----------------------*/
    /**
     * Required init functions for the plugin
     *
     * @method init
     * @param {Map} mapObj       instantiated Map class object
     *
     * @todo think through should setZoomLimits and setZoomModifier be in map.prototype?
     * But zoomLimit and modifier need to be setable in creation, init or later with setters
     **/
    function init(thisMap) {
      map = thisMap;
      map.setPrototype("zoomIn", zoomIn);
      map.setPrototype("zoomOut", zoomOut);
      map.setPrototype("setZoomLimits", setZoomLimits);
      map.setPrototype("setZoomModifier", setZoomModifier);

      /* Singleton should have been instantiated before, we only retrieve it with 0 params */
      eventListeners.on("zoom", unifiedEventCB);
    }

    /*----------------------------------------
    ------ PROTOTYPE extensions for map ------
    ----------------------------------------*/
    /**
     * How much one mouse wheel step zooms
     *
     * @method setZoomModifier
     * @param {Number} amount           How much one mouse wheel step zooms. Needs to be in between 0 - 0.5
     **/
    function setZoomModifier(amount) {
      if (!(amount > 0 || amount <= 0.5)) {
        throw new Error("Wrong zoom modifier! (needs to be >0 and <=0.5, given:" + amount);
      }
      zoomModifier = amount;

      return this;
    }
    /**
     * How much can be zoomed in maximum and minimum
     *
     * @method setZoomLimits
     * @param {Number} farther          (>1) How much one mouse wheel step zooms out
     * @param {Number} closer           (0 - 1) How much one mouse wheel step zooms in
     **/
    function setZoomLimits(farther, closer) {
      zoomLimit.farther = farther;
      zoomLimit.closer = closer;

      return this;
    }
    /**
     * Zoom in to the map
     *
     * @method zoomIn
     * @param {Number} amount how much map is zoomed in
     * */
    function zoomIn(amount) {
      var presentScale = this.getZoom();
      var IS_ZOOM_IN = true;

      mapEvents.publish("mapZoomed", { presentScale: presentScale, amount: amount, isZoomIn: IS_ZOOM_IN });

      return _zoom(this, presentScale, Math.abs(amount) || zoomModifier, IS_ZOOM_IN);
    }
    /**
     * Zoom out of the map
     *
     * @method zoomOut
     * @param {Number} amount how much map is zoomed out
     * */
    function zoomOut(amount) {
      var presentScale = this.getZoom();
      var IS_ZOOM_IN = false;

      amount = amount < 0 ? amount : -amount;
      mapEvents.publish("mapZoomed", { presentScale: presentScale, amount: amount, isZoomIn: IS_ZOOM_IN });

      return _zoom(this, presentScale, amount || -zoomModifier, IS_ZOOM_IN);
    }

    /*---------------------------
    ------ EVENT FUNCTIONS ------
    ---------------------------*/
    /**
     * This starts the correct eventListener for the current environment. Mousewheel and pinch differ quite dramatically
     * so we keep them as separate functions.
     *
     * @method unifiedEventCB
     * @param  {Event} e             Event object
     * @param  {Integer} delta       Hamster.js provided delta
     * @param  {Integer} deltaX      Hamster.js provided delta
     * @param  {Integer} deltaY      Hamster.js provided delta
     */
    function unifiedEventCB(e, delta, deltaX, deltaY) {
      if (delta) {
        handleZoomEventDesktop(e, delta, deltaX, deltaY);
      } else if (e.pointers) {
        if (!mobileInitialized) {
          mobileInitialized = true;
          setZoomModifier(zoomModifier * 0.5);
        }
        handleZoomEventMobile(e);
      }
    }
    /**
     * Setup desktop zoomEvent by currying. Internally: Sets up correct scale + moves map accordingly to zoom to the
     * current center coordinates
     *
     * @method handleZoomEventDesktop
     * @param  {Map} map             Map instance
     */
    function handleZoomEventDesktop(e, delta, deltaX, deltaY) {
      var mouseWheelDelta = deltaY;
      /* Scale changes when the map is drawn. We make calculations with the old scale before draw */
      var oldScale = map.getZoom();

      /* No nasty scrolling side-effects */
      e.preventDefault();

      if (mouseWheelDelta > 0) {
        if (map.zoomIn()) {
          map.moveMap(_calculateCenterMoveCoordinates(oldScale, true), _calculateCenterMoveCoordinates(map.getZoom(), true));
        }
      } else if (mouseWheelDelta < 0) {
        if (map.zoomOut()) {
          map.moveMap(_calculateCenterMoveCoordinates(oldScale), _calculateCenterMoveCoordinates(map.getZoom()));
        }
      }
    }
    /**
     * handleZoomEventMobile
     *
     * @method handleZoomEventMobile
     * @param  {Event} e
     */
    function handleZoomEventMobile(e) {
      var pointers = e.pointers;
      var coords = [{
        x: pointers[0].pageX,
        y: pointers[0].pageY
      }, {
        x: pointers[1].pageX,
        y: pointers[1].pageY
      }];
      var changeX = Math.abs(coords[0].x - coords[1].x);
      var changeY = Math.abs(coords[0].y - coords[1].y);

      e.preventDefault();

      try {
        if (!initialized) {
          difference = {
            x: changeX,
            y: changeY
          };
          eventListeners.setActivityState("zoom", true);
          initialized = true;

          return;
        } else if (e.eventType === 4 || e.eventType === 8) {
          /* e.eventType 4 = event canceled, e.eventType 8 = event finished */
          /* We don't want another event to be fired right after a pinch event. It makes the zoomign experience rather
           * bad if after zoom there is immediately an unexplainable drag and the map moves a bit
           * */
          window.setTimeout(function () {
            eventListeners.setActivityState("zoom", false);
          }, TIMEOUT_AFTER_ZOOM);
          initialized = false;
        }

        if (difference.x + difference.y < changeX + changeY) {
          if (map.zoomIn()) {
            map.moveMap(_calculateCenterMoveCoordinates(map.getZoom(), true));
          }
        } else {
          if (map.zoomOut()) {
            map.moveMap(_calculateCenterMoveCoordinates(map.getZoom()));
          }
        }

        difference = {
          x: changeX,
          y: changeY
        };
      } catch (ev) {
        console.log("Error! ", ev);
      }
    }

    /*---------------------
    ------- PRIVATE -------
    ---------------------*/
    /**
     * _isOverZoomLimit
     *
     * @private
     * @static
     * @method _isOverZoomLimit
     **/
    function _isOverZoomLimit(amount, isZoomIn) {
      if (isZoomIn && amount > zoomLimit.closer || !isZoomIn && amount < zoomLimit.farther) {
        return true;
      }

      return false;
    }
    /**
     * @private
     * @static
     * @method _calculateCenterMoveCoordinates
     **/
    function _calculateCenterMoveCoordinates(scale, isZoomIn) {
      var windowSize = utils.resize.getWindowSize();
      var halfWindowSize = {
        x: windowSize.x / 2 / scale,
        y: windowSize.y / 2 / scale
      };
      var realMovement = {
        x: halfWindowSize.x * (isZoomIn ? -zoomModifier : zoomModifier),
        y: halfWindowSize.y * (isZoomIn ? -zoomModifier : zoomModifier)
      };

      return realMovement;
    }
    /**
     * @private
     * @static
     * @method _zoom
     **/
    function _zoom(map, presentScale, amount, isZoomIn) {
      var newScale;

      if (!_isOverZoomLimit(presentScale, isZoomIn)) {
        newScale = map.setZoom(amount ? presentScale + amount : presentScale + zoomModifier);
      }

      return newScale;
    }
  }
  return {
    setters: [function (_bundlesCoreBundleJs) {
      eventListeners = _bundlesCoreBundleJs.eventListeners;
      utils = _bundlesCoreBundleJs.utils;
      mapEvents = _bundlesCoreBundleJs.mapEvents;
    }],
    execute: function () {
      mapZoom = setupMap_zoom();

      _export('mapZoom', mapZoom);
    }
  };
});
System.register('bundles/coreBundle.js', ['bundles/strippedCoreBundle.js', 'components/map/core/baseEventlisteners/baseEventlisteners.js', 'components/map/core/move/mapDrag.js', 'components/map/core/zoom/mapZoom.js'], function (_export) {
  'use strict';

  /*
   * This one bundles the core functionality by importing and re-exporting the core functionality. You can then use
   * some bundler or transpiler, like JSPM to bundle the core functionality to one build-file.
   */

  return {
    setters: [function (_bundlesStrippedCoreBundleJs) {
      var _exportObj = {};

      for (var _key in _bundlesStrippedCoreBundleJs) {
        if (_key !== 'default') _exportObj[_key] = _bundlesStrippedCoreBundleJs[_key];
      }

      _export(_exportObj);
    }, function (_componentsMapCoreBaseEventlistenersBaseEventlistenersJs) {
      var _exportObj2 = {};

      for (var _key2 in _componentsMapCoreBaseEventlistenersBaseEventlistenersJs) {
        if (_key2 !== 'default') _exportObj2[_key2] = _componentsMapCoreBaseEventlistenersBaseEventlistenersJs[_key2];
      }

      _export(_exportObj2);
    }, function (_componentsMapCoreMoveMapDragJs) {
      var _exportObj3 = {};

      for (var _key3 in _componentsMapCoreMoveMapDragJs) {
        if (_key3 !== 'default') _exportObj3[_key3] = _componentsMapCoreMoveMapDragJs[_key3];
      }

      _export(_exportObj3);
    }, function (_componentsMapCoreZoomMapZoomJs) {
      var _exportObj4 = {};

      for (var _key4 in _componentsMapCoreZoomMapZoomJs) {
        if (_key4 !== 'default') _exportObj4[_key4] = _componentsMapCoreZoomMapZoomJs[_key4];
      }

      _export(_exportObj4);
    }],
    execute: function () {}
  };
});
System.register('components/map/extensions/hexagons/eventListeners/select.js', ['bundles/coreBundle.js'], function (_export) {

  /*---------------------
  --------- API ---------
  ----------------------*/
  'use strict';

  /*---------------------
  ------- IMPORT --------
  ----------------------*/
  var utils, mapEvents, UI, MapDataManipulator, eventListeners;

  /*---------------------
  ------- PUBLIC --------
  ----------------------*/
  /**
   * Handles the eventlistner for selecting objects on the map. THe actual logic for detecting the objects under mouse
   * etc. are in selectHexagonPlugin
   *
   * @class hexagonPlugin.setupHexagonClick
   * @requires Hammer.js. Some events are done with Hammer.js, so we need it to handle those events correctly
   * @param  {Map} map      The currently use Map instance
   * @return {Boolean}      True
   */
  function _setupHexagonClick(map) {
    var ui;

    if (!map) {
      throw new Error("eventlisteners initialization require map arguments");
    }

    ui = UI();

    eventListeners.on("select", tapListener);

    return true;

    /*----------------------
    ------- PUBLIC ---------
    ----------------------*/
    /**
     * the listener that received the event object
     *
     * @method tapListener
     * @param  {Event} e      Event object
     */
    function tapListener(e) {
      var globalCoords = utils.mouse.eventData.getHAMMERPointerCoords(e);
      var getData = {
        allData: function allData(object) {
          return object.data.typeData;
        }
      };
      var objects, filter;

      filter = new MapDataManipulator({
        type: "filter",
        object: "container",
        property: "name",
        value: "unitLayer"
      });

      objects = map.getObjectsUnderArea(globalCoords, { filter: filter });
      objects = utils.dataManipulation.mapObjectsToArray(objects);
      objects = utils.dataManipulation.flattenArrayBy1Level(objects);

      /* Throw a mapEvent if there are objects found. It might be required to throw this event later on, not yet here. */
      if (objects.length) {
        mapEvents.publish("objectsSelected", objects);
      }

      ui.showSelections(objects, getData);
      map.drawOnNextTick();
    }
  }
  return {
    setters: [function (_bundlesCoreBundleJs) {
      utils = _bundlesCoreBundleJs.utils;
      mapEvents = _bundlesCoreBundleJs.mapEvents;
      UI = _bundlesCoreBundleJs.UI;
      MapDataManipulator = _bundlesCoreBundleJs.MapDataManipulator;
      eventListeners = _bundlesCoreBundleJs.eventListeners;
    }],
    execute: function () {
      _export('setupHexagonClick', _setupHexagonClick);
    }
  };
});
System.register('components/map/extensions/hexagons/selectHexagonPlugin.js', ['components/map/extensions/hexagons/eventListeners/select.js'], function (_export) {

  /*-----------------------
  ---------- API ----------
  -----------------------*/
  /* For debugging. This will show up if the plugin fails to load in Map.js */
  'use strict';

  /*-----------------------
  --------- IMPORT --------
  -----------------------*/
  var setupHexagonClick, selectHexagonObject;

  /*-----------------------
  -------- PUBLIC ---------
  -----------------------*/
  /**
   * Handles the selection of hexagons on the map
   *
   * @class hexagonPlugin.setupObject_select_hexagon
   * @return {Object}       Return methods inside object
   */
  function setupObject_select_hexagon() {
    var map = {};

    return {
      init: init,
      pluginName: "selectHexagonObject"
    };

    /**
     * @method  init
     * @param {Map} givenMap         Instantiated Map class object
     */
    function init(givenMap) {
      map = givenMap;

      startClickListener(map);
    }

    /*-----------------------
    -------- PRIVATE --------
    -----------------------*/
    /**
     * @method startClickListener
     * @param {Map} map              Instantiated Map class object
     */
    function startClickListener(map) {
      return setupHexagonClick(map);
    }
  }
  return {
    setters: [function (_componentsMapExtensionsHexagonsEventListenersSelectJs) {
      setupHexagonClick = _componentsMapExtensionsHexagonsEventListenersSelectJs.setupHexagonClick;
    }],
    execute: function () {
      selectHexagonObject = setupObject_select_hexagon();

      _export('selectHexagonObject', selectHexagonObject);
    }
  };
});
System.register('components/map/extensions/hexagons/index.js', ['components/map/extensions/hexagons/eventListeners/select.js', 'components/map/extensions/hexagons/utils/createHexagon.js', 'components/map/extensions/hexagons/utils/hexagonMath.js', 'components/map/extensions/hexagons/Objects.js', 'components/map/extensions/hexagons/selectHexagonPlugin.js'], function (_export) {

	/*
  * Bundles the hexagons plugin
  */

	'use strict';var setupHexagonClick, createHexagon, createVisibleHexagon, calcShortDiagonal, calcLongDiagonal, getHexagonPoints, hexaHitTest, ObjectHexaTerrain, ObjectHexaUnit, selectHexagonObject, hexagonPlugin;
	return {
		setters: [function (_componentsMapExtensionsHexagonsEventListenersSelectJs) {
			setupHexagonClick = _componentsMapExtensionsHexagonsEventListenersSelectJs.setupHexagonClick;
		}, function (_componentsMapExtensionsHexagonsUtilsCreateHexagonJs) {
			createHexagon = _componentsMapExtensionsHexagonsUtilsCreateHexagonJs.createHexagon;
			createVisibleHexagon = _componentsMapExtensionsHexagonsUtilsCreateHexagonJs.createVisibleHexagon;
		}, function (_componentsMapExtensionsHexagonsUtilsHexagonMathJs) {
			calcShortDiagonal = _componentsMapExtensionsHexagonsUtilsHexagonMathJs.calcShortDiagonal;
			calcLongDiagonal = _componentsMapExtensionsHexagonsUtilsHexagonMathJs.calcLongDiagonal;
			getHexagonPoints = _componentsMapExtensionsHexagonsUtilsHexagonMathJs.getHexagonPoints;
			hexaHitTest = _componentsMapExtensionsHexagonsUtilsHexagonMathJs.hexaHitTest;
		}, function (_componentsMapExtensionsHexagonsObjectsJs) {
			ObjectHexaTerrain = _componentsMapExtensionsHexagonsObjectsJs.ObjectHexaTerrain;
			ObjectHexaUnit = _componentsMapExtensionsHexagonsObjectsJs.ObjectHexaUnit;
		}, function (_componentsMapExtensionsHexagonsSelectHexagonPluginJs) {
			selectHexagonObject = _componentsMapExtensionsHexagonsSelectHexagonPluginJs.selectHexagonObject;
		}],
		execute: function () {
			hexagonPlugin = {
				setupHexagonClick: setupHexagonClick,
				ObjectHexaTerrain: ObjectHexaTerrain,
				ObjectHexaUnit: ObjectHexaUnit,
				selectHexagonObject: selectHexagonObject,
				utils: {
					createHexagon: createHexagon,
					createVisibleHexagon: createVisibleHexagon,
					calcShortDiagonal: calcShortDiagonal,
					calcLongDiagonal: calcLongDiagonal,
					getHexagonPoints: getHexagonPoints,
					hexaHitTest: hexaHitTest
				}
			};

			_export('hexagonPlugin', hexagonPlugin);
		}
	};
});
System.register('bundles/fullModuleBundle.js', ['bundles/coreBundle.js', 'components/logger/log.js', 'components/map/extensions/basicActions/basicActions.js', 'components/map/extensions/mapMovement/mapMovement.js', 'components/map/UIs/default/default.js', 'components/map/UIs/default/layout/index.js', 'components/map/UIs/default/utils/arrows.js', 'components/preloading/preloading.js', 'components/utilities/polyfills.js', 'factories/index.js', 'components/map/extensions/hexagons/index.js'], function (_export) {
  'use strict';

  /*
   * This should bundle all engines functions
   */

  /* Export factories */

  /* Export hexagon plugin */
  return {
    setters: [function (_bundlesCoreBundleJs) {
      var _exportObj = {};

      for (var _key in _bundlesCoreBundleJs) {
        if (_key !== 'default') _exportObj[_key] = _bundlesCoreBundleJs[_key];
      }

      _export(_exportObj);
    }, function (_componentsLoggerLogJs) {
      var _exportObj2 = {};

      for (var _key2 in _componentsLoggerLogJs) {
        if (_key2 !== 'default') _exportObj2[_key2] = _componentsLoggerLogJs[_key2];
      }

      _export(_exportObj2);
    }, function (_componentsMapExtensionsBasicActionsBasicActionsJs) {
      var _exportObj3 = {};

      for (var _key3 in _componentsMapExtensionsBasicActionsBasicActionsJs) {
        if (_key3 !== 'default') _exportObj3[_key3] = _componentsMapExtensionsBasicActionsBasicActionsJs[_key3];
      }

      _export(_exportObj3);
    }, function (_componentsMapExtensionsMapMovementMapMovementJs) {
      var _exportObj4 = {};

      for (var _key4 in _componentsMapExtensionsMapMovementMapMovementJs) {
        if (_key4 !== 'default') _exportObj4[_key4] = _componentsMapExtensionsMapMovementMapMovementJs[_key4];
      }

      _export(_exportObj4);
    }, function (_componentsMapUIsDefaultDefaultJs) {
      var _exportObj5 = {};

      for (var _key5 in _componentsMapUIsDefaultDefaultJs) {
        if (_key5 !== 'default') _exportObj5[_key5] = _componentsMapUIsDefaultDefaultJs[_key5];
      }

      _export(_exportObj5);
    }, function (_componentsMapUIsDefaultLayoutIndexJs) {
      var _exportObj6 = {};

      for (var _key6 in _componentsMapUIsDefaultLayoutIndexJs) {
        if (_key6 !== 'default') _exportObj6[_key6] = _componentsMapUIsDefaultLayoutIndexJs[_key6];
      }

      _export(_exportObj6);
    }, function (_componentsMapUIsDefaultUtilsArrowsJs) {
      var _exportObj7 = {};

      for (var _key7 in _componentsMapUIsDefaultUtilsArrowsJs) {
        if (_key7 !== 'default') _exportObj7[_key7] = _componentsMapUIsDefaultUtilsArrowsJs[_key7];
      }

      _export(_exportObj7);
    }, function (_componentsPreloadingPreloadingJs) {
      var _exportObj8 = {};

      for (var _key8 in _componentsPreloadingPreloadingJs) {
        if (_key8 !== 'default') _exportObj8[_key8] = _componentsPreloadingPreloadingJs[_key8];
      }

      _export(_exportObj8);
    }, function (_componentsUtilitiesPolyfillsJs) {
      var _exportObj9 = {};
      _exportObj9['polyfills'] = _componentsUtilitiesPolyfillsJs.polyfills;

      _export(_exportObj9);
    }, function (_factoriesIndexJs) {
      var _exportObj10 = {};

      for (var _key9 in _factoriesIndexJs) {
        if (_key9 !== 'default') _exportObj10[_key9] = _factoriesIndexJs[_key9];
      }

      _export(_exportObj10);
    }, function (_componentsMapExtensionsHexagonsIndexJs) {
      var _exportObj11 = {};

      for (var _key10 in _componentsMapExtensionsHexagonsIndexJs) {
        if (_key10 !== 'default') _exportObj11[_key10] = _componentsMapExtensionsHexagonsIndexJs[_key10];
      }

      _export(_exportObj11);
    }],
    execute: function () {}
  };
});
//# sourceMappingURL=flatworld.js.map