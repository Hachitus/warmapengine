<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\components\map\core\MapLayers.js - FlaTWorld</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="FlaTWorld" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/baseEventlisteners.html">baseEventlisteners</a></li>
                                <li><a href="../classes/eventListeners.html">eventListeners</a></li>
                                <li><a href="../classes/generalUtils.polyfills.html">generalUtils.polyfills</a></li>
                                <li><a href="../classes/hexagonPlugin.ObjectHexaTerrain.html">hexagonPlugin.ObjectHexaTerrain</a></li>
                                <li><a href="../classes/hexagonPlugin.ObjectHexaUnit.html">hexagonPlugin.ObjectHexaUnit</a></li>
                                <li><a href="../classes/hexagonPlugin.setupHexagonClick.html">hexagonPlugin.setupHexagonClick</a></li>
                                <li><a href="../classes/hexagonPlugin.setupObject_select_hexagon.html">hexagonPlugin.setupObject_select_hexagon</a></li>
                                <li><a href="../classes/hexagonPlugin.utils.html">hexagonPlugin.utils</a></li>
                                <li><a href="../classes/log.html">log</a></li>
                                <li><a href="../classes/Map.html">Map</a></li>
                                <li><a href="../classes/MapDataManipulator.html">MapDataManipulator</a></li>
                                <li><a href="../classes/mapDrag.html">mapDrag</a></li>
                                <li><a href="../classes/mapEvents.html">mapEvents</a></li>
                                <li><a href="../classes/MapLayer.html">MapLayer</a></li>
                                <li><a href="../classes/MapLayerParent.html">MapLayerParent</a></li>
                                <li><a href="../classes/mapMovement.html">mapMovement</a></li>
                                <li><a href="../classes/MapSubcontainer.html">MapSubcontainer</a></li>
                                <li><a href="../classes/mapZoom.html">mapZoom</a></li>
                                <li><a href="../classes/Object_sprite.html">Object_sprite</a></li>
                                <li><a href="../classes/ObjectManager.html">ObjectManager</a></li>
                                <li><a href="../classes/ObjectSpriteTerrain.html">ObjectSpriteTerrain</a></li>
                                <li><a href="../classes/ObjectSpriteUnit.html">ObjectSpriteUnit</a></li>
                                <li><a href="../classes/Preload.html">Preload</a></li>
                                <li><a href="../classes/UI.html">UI</a></li>
                                <li><a href="../classes/UI_default.html">UI_default</a></li>
                                <li><a href="../classes/UI_templateBase.html">UI_templateBase</a></li>
                                <li><a href="../classes/utilities.arrays.html">utilities.arrays</a></li>
                                <li><a href="../classes/utilities.environmentDetections.html">utilities.environmentDetections</a></li>
                                <li><a href="../classes/utils.dataManipulation.html">utils.dataManipulation</a></li>
                                <li><a href="../classes/utils.effects.html">utils.effects</a></li>
                                <li><a href="../classes/utils.environment.html">utils.environment</a></li>
                                <li><a href="../classes/utils.general.html">utils.general</a></li>
                                <li><a href="../classes/utils.mouse.html">utils.mouse</a></li>
                                <li><a href="../classes/utils.Quadtree.html">utils.Quadtree</a></li>
                                <li><a href="../classes/utils.resize.html">utils.resize</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\components\map\core\MapLayers.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/*---------------------
------ VARIABLES ------
---------------------*/
var _UIObjects = [];

/*---------------------
-------- EXPORT -------
---------------------*/
export class MapLayer extends PIXI.Container {
  /**
   * Creates a basic layer for the Map. This type of layer can not hold subcontainers. Note that different devices and graphic cards can only have specific size of bitmap drawn, and PIXI cache always draws a bitmap thus the default is: 4096, based on this site: http://webglstats.com/ and MAX_TEXTURE_SIZE. This is important also when caching.
   *
   * @class MapLayer
   * @constructor
   * @param {Object} options                            optional options
   * @param {String} options.name                       Layers name, used for identifying the layer. Useful in debugging, but can be used for finding correct layers too
   * @param  {Object} options.coord                   coord starting coords of layer. Relative to parent map layer.
   * @param  {Integer} options.coord.x         X coordinate
   * @param  {Integer} options.coord.y         Y coordinate
   * @param  {Object} options.specialLayer            Is this layer special (e.g. UILayer not included in normal operations)
   * @param  {Integer} options.specialLayer.x         X coordinate
   * @param  {Integer} options.specialLayer.y         Y coordinate
   **/
  constructor(options = {
      name: &quot;&quot;,
      coord: { x: 0, y: 0 },
      specialLayer: false,
      selectable: false } ) {
    var { name, coord, specialLayer, selectable } = options;

    super();
    Object.assign(this, coord);

    /**
     * Layers name, used for identifying the layer. Useful in debugging, but can be used for finding correct layers too
     *
     * @attribute name
     * @type {String}
     */
    this.name = &quot;&quot; + name;
    /**
     * Is this layer special (e.g. UILayer not included in normal operations)
     *
     * @attribute specialLayer
     * @type {Boolean}
     */
    this.specialLayer = !!specialLayer;
    /**
     * Can you select objects from this layer. For example with Map.getObjectsUnderArea
     *
     * @attribute selectable
     * @type {Boolean}
     */
    this.selectable = selectable;
  }
  /**
   * Does this layer use subcontainers.
   *
   * @method hasSubcontainers
   * @return {Boolean} true = uses subcontainers.
   */
  hasSubcontainers() {
    return this.subcontainersConfig ? true : false;
  }
  /**
   * Is this layer cached at the moment or not.
   *
   * @method isCached
   * @return {Boolean} true = is cached
   */
  isCached() {
    return this.cacheAsBitmap;
  }
  /**
   * Move layer based on given amounts
   *
   * @method move
   * @param  {Object} coord            The amount of x and y coordinates we want the layer to move. I.e. { x: 5, y: 0 }. This would move the map 5 pixels horizontally and 0 pixels vertically
   * @param  {Integer} coord.x         X coordinate
   * @param  {Integer} coord.y         Y coordinate
   **/
  move(coord) {
    this.x += coord.x;
    this.y += coord.y;
    this.drawThisChild = true;
  }
  /**
   * set layer zoom
   *
   * @method setZoom
   * @param {Number} amount The amount that you want the layer to zoom.
   * @return {Number} The same amount that was given, except after transform to 2 decimals and type cast to Number
   * */
  setZoom(amount) {
    this.scale.x = this.scale.y = +amount.toFixed(2);

    return this.scale.x;
  }
  /**
   * get layer zoom
   *
   * @method getZoom
   * @return {Boolean} current amount of zoom
   * */
  getZoom() {
    return this.scale.x;
  }
    /**
   * get UIObjects on this layer, if there are any, or defaulty empty array if no UIObjects are active
   *
   * @method getUIObjects
   * @return {Array} current UIObjects
   * */
  getUIObjects() {
    return _UIObjects;
  }
  /**
   * Remove all the UIObjects from this layer
   *
   * @method emptyUIObjects
   * @return {Array} empty UIObjects array
   * */
  emptyUIObjects() {
    _UIObjects.map(obj =&gt; {
      this.getUILayer().removeChild(obj);
      obj = null;
    });

    return _UIObjects;
  }
  /**
   * Get primary layers, that this layer holds as children. So basically all children that are not special layers (such as UI layers etc.)
   *
   * @method getPrimaryLayers
   * @return {Array}                            Primary children layers under this layer
   * */
  getPrimaryLayers() {
    return this.children.filter(thisChild =&gt; {
      return !thisChild.specialLayer;
    });
  }
  /**
   * Get all objects that are this layers children or subcontainers children. Does not return layers, but the objects.
   *
   * @method getObjects
   * @return {Array}                            All the objects (not layers) found under this layer
   * */
  getObjects() {
    var allObjects = [];

    if (this.hasSubcontainers()) {
      this.subcontainerList.forEach(subcontainer =&gt; {
        allObjects.concat(subcontainer.children);
      });
    }

    return allObjects;
  }
  /**
   * @todo IMPLEMENT CACHE PROPERLY! TAKE SUBCONTAINERS INTO ACCOUNT!
   *
   * Sets layer cache on or off.
   *
   * @method setCache
   * @param {Boolean} status      true = activate cache, false = disable cache
   */
  setCache(status) {
    var toCacheStatus = status ? true : false;

    this.cacheAsBitmap = toCacheStatus;

    return toCacheStatus;
  }
  /**
   * Create and add special layer, that holds UI effects in it.
   *
   * @method createUILayer
   * @param  {String} name          name of the layer
   * @param  {Object} coord         Coordinates of the layer
   * @param  {Integer} coord.x      X coordinate
   * @param  {Integer} coord.y      Y coordinate
   * @return {MapLayer}            The created UI layer
   **/
  createUILayer(name = &quot;default UI layer&quot;, coord = { x: 0, y: 0 }) {
    var layer = new MapLayer(name, coord);

    layer.specialLayer = true;
    this.addChild(layer);

    this.UILayer = layer;

    return layer;
  }
  /**
   * Adds and object to this layers UILayer child.
   *
   * @method addUIObject
   * @param {Object} object   The UI object to be added under this layer
   * @return {Array}          All the UIObjects currently on this layer
   */
  addUIObject(object) {
    var UILayer;
    _UIObjects = _UIObjects || [];

    if (!this.getUILayer()) {
      UILayer = this.createUILayer();
    } else {
      UILayer = this.getUILayer;
    }

    this.UILayer.addChild(object);
    _UIObjects.push( object );

    return _UIObjects;
  }
  /**
   * Return the UILayer. If no UILayer is yet created, will return undefined
   *
   * @method getUILayer
   * @return {MapLayer | undefined}
   */
  getUILayer() {
    return this.UILayer;
  }
}

export class MapLayerParent extends MapLayer {
  /**
   * Layer designed to hold subcontainers. But can handle objects too. Different devices graphic cards can only have specific size of bitmap drawn, and PIXI cache always draws a bitmap. Thus the default is: 4096, based on this site: http://webglstats.com/ and MAX_TEXTURE_SIZE
   *
   * @class MapLayerParent
   * @constructor
   * @param {Object} options
   * @param {String} options.name                    name layer property name, used for identifiying the layer, usefull in debugging, but used also otherwise too
   * @param  {Object} options.coord                  starting coords of layer. Relative to parent map layer.
   * @param  {Integer} options.coord.x               X coordinate
   * @param  {Integer} options.coord.y               Y coordinate
   * @param  {Object} options.subcontainers          Subontainer size. If given activated subcontainers, otherwise not.
   * @param  {Integer} options.subcontainers.width   width (in pixels)
   * @param  {Integer} options.subcontainers.height  height (in pixels)
   * @param {Boolean} options.specialLayer           Is this special layer or not.
   */
  constructor(options = { name: &quot;&quot;, coord: { x: 0, y: 0 }, subcontainers: false, specialLayer: false, selectable: false } ) {
    var { subcontainers, selectable, specialLayer } = options;

    super(options);

    this.oldAddChild = super.addChild.bind(this);
    this.subcontainersConfig = subcontainers;
    this.subcontainerList = [];
    this.selectable = selectable;
    this.specialLayer = specialLayer;
  }
  /**
   * We override the PIXIs own addchild functionality. Since we need to support subcontainers in addChild. We check subcontainers and then we call the original (PIXIs) addChild
   *
   * @method addChild
   * @param {PIXI.DisplayObject} displayObject      PIXI.DisplayObject
   */
  addChild(displayObject) {
    if (this.hasSubcontainers()) {
      let correctContainer;
      correctContainer = setCorrectSubcontainer(displayObject, this);
      this.oldAddChild(correctContainer);
    } else {
      this.oldAddChild(displayObject);
    }

    return displayObject;
  }
  /**
   * Returns the configurations set for subcontainers.
   *
   * @method getSubcontainerConfigs
   */
  getSubcontainerConfigs () {
    return this.subcontainersConfig;
  }
  /**
   * Returns subcontainers based on the given coordinates. Can be applied through a MapDataManipulator filter also.
   *
   * @method getSubcontainersByCoordinates
   * @param  {Object} coordinates
   * @param  {Integer} coordinates.x                  X coordinate
   * @param  {Integer} coordinates.y                  Y coordinate
   * @param  {Object} options                         Optional options.
   * @param  {MapDataManipulator} options.filter      Filter for selecting only certain subcontainers
   */
  getSubcontainersByCoordinates(coordinates, options = { filter: undefined }) {
    if (!this.hasSubcontainers()) {
      throw new Error(&quot;tried to retrieve subcontainers, when they are not present&quot;);
    }

    var foundSubcontainers, tempCoordinates;
    var { filter } = options;

    tempCoordinates = this.toLocal(new PIXI.Point(coordinates.x, coordinates.y));
    tempCoordinates.width = coordinates.width;
    tempCoordinates.height = coordinates.height;

    foundSubcontainers = getClosestSubcontainers(this, tempCoordinates, { filter });

    return foundSubcontainers;
  }
  /**
   * @method getSubcontainers
   */
  getSubcontainers() {
    return this.subcontainerList;
  }
}

class MapSubcontainer extends PIXI.Container {
  /**
   * Subcontainers are containers that hold objects like units and terrain etc. under them. They have some restrictions atm. since they are PIXI.ParticleContainers. But when needed we can extend MapLayers with another class which is subcontainer, but not ParticleContainer at the present there is no need, so we won&#x27;t extend yet. Subcontainers help the layers to make better movement of the map, by making subcontainers visible or invisible and even helping with selecting objects on the map. Thus we don&#x27;t need to use our inefficient Quadtree. The intention was to use PIXI.ParticleContainer for this, but it seems it doesn&#x27;t clean up the memory afterwards the same way as normal Container.
   *
   * @private
   * @class MapSubcontainer
   * @constructor
   * @param  {Object} size              Subontainer size. If given activated subcontainers, otherwise not.
   * @param  {Integer} size.width       width (in pixels)
   * @param  {Integer} size.height      height (in pixels)
   */
  constructor(size) {
    super();

    this.specialLayer = true;
    this.size = size;
    this.selectable = false;
  }
  /**
   * Gets this subcontainers coordinates and size
   *
   * @method getSubcontainerArea
   * @param {Number} scale                              The size of scale the map currently has
   * @param {Boolean} options.toGlobal                  Do we get the global coordinates or local
   */
  getSubcontainerArea (scale, options = { toGlobal: true } ) {
    var coordinates;

    coordinates = options.toGlobal ? this.toGlobal(new PIXI.Point(0, 0)) : this;
    if (scale) {
      coordinates.x /= scale;
      coordinates.y /= scale;
    }

    return {
      x: Math.round( coordinates.x ),
      y: Math.round( coordinates.y ),
      width: Math.round( this.size.width ),
      height: Math.round( this.size.height )
    };
  }
  /**
   * Set cache on or off for this layer
   *
   * @method setCache
   * @param {Boolean} status      true = activate cache, false = disable cache
   */
  setCache(status) {
    var toCacheStatus = status ? true : false;

    this.cacheAsBitmap = toCacheStatus;

    return toCacheStatus;
  }
}
/*---------------------
------- PRIVATE -------
----------------------*/
/**
 * Helper function for setting subcontainers to parent containers
 *
 * @method setCorrectSubcontainer
 * @private
 * @static
 * @method setCorrectSubcontainer
 * @param {PIXI.DisplayObject} displayObject
 * @param {Object} parentLayer
 */
function setCorrectSubcontainer(displayObject, parentLayer) {
  var { subcontainersConfig, subcontainerList } = parentLayer;
  var xIndex = Math.floor( displayObject.x / subcontainersConfig.width );
  var yIndex = Math.floor( displayObject.y / subcontainersConfig.height );
  var thisSubcontainer;

  subcontainerList[xIndex] = subcontainerList[xIndex] || [];
  thisSubcontainer = subcontainerList[xIndex][yIndex] = subcontainerList[xIndex][yIndex] || [];

  if (subcontainerList[xIndex][yIndex].length &lt;= 0) {
    thisSubcontainer = new MapSubcontainer({
      x: xIndex * subcontainersConfig.width,
      y: yIndex * subcontainersConfig.height,
      width: subcontainersConfig.width,
      height: subcontainersConfig.height
    });

    subcontainerList[xIndex][yIndex] = thisSubcontainer;
    thisSubcontainer.x = xIndex * subcontainersConfig.width;
    thisSubcontainer.y = yIndex * subcontainersConfig.height;
    thisSubcontainer.visible = subcontainersConfig.isHiddenByDefault ? false : true;
  }

  displayObject.x -= thisSubcontainer.x;
  displayObject.y -= thisSubcontainer.y;
  subcontainerList[xIndex][yIndex].addChild(displayObject);

  return subcontainerList[xIndex][yIndex];
}
/**
 * Get the closest subcontainers of the given area.
 *
 * @method setCorrectSubcontainer
 * @private
 * @static
 * @method getClosestSubcontainers
 * @param  {Object} layer                         Instance of PIXI.Container - The layer being used
 * @param  {Number} xIndex                        x / horizontal index.
 * @param  {Number} yIndex                        y / vertical index.
 * @param  {Object} options                       Optional options.
 * @param  {MapDataManipulator} options.filter    Filter for selecting only wanted subcontainers
 * @return {Array}                                Array of found subcontainers.
 */
function getClosestSubcontainers(layer, givenCoordinates, options = { filter: undefined }) {
  var { filter } = options;
  var coordinates = {
    x: givenCoordinates.x &gt;= 0 ? givenCoordinates.x : 0,
    y: givenCoordinates.y &gt;= 0 ? givenCoordinates.y : 0,
    width: givenCoordinates.width,
    height: givenCoordinates.height
  };
  var { width, height } = layer.getSubcontainerConfigs ();
  var allFoundSubcontainers = [];
  var xIndex = Math.floor( coordinates.x / width );
  var yIndex = Math.floor( coordinates.y / height );
  var x2 = coordinates.width ? coordinates.x + coordinates.width :  + coordinates.x;
  var y2 = coordinates.height ? coordinates.y + coordinates.height :  + coordinates.y;
  var widthIndex = Math.floor( x2 / width );
  var heightIndex = Math.floor( y2 / height );
  var subcontainerList = layer.subcontainerList;

  for (let thisXIndex = xIndex; thisXIndex &lt;= widthIndex; thisXIndex++) {
    if (thisXIndex &gt;= 0 &amp;&amp; subcontainerList &amp;&amp; subcontainerList[thisXIndex]) {
      for (let thisYIndex = yIndex; thisYIndex &lt;= heightIndex; thisYIndex++) {
        if (thisYIndex &gt;= 0 &amp;&amp; subcontainerList[thisXIndex][thisYIndex]) {
          if (filter &amp;&amp; !filter.filterSubcontainers(subcontainerList[thisXIndex][thisYIndex])) {
            continue;
          }
          allFoundSubcontainers.push(subcontainerList[thisXIndex][thisYIndex]);
        }
      }
    }
  }

  return allFoundSubcontainers;
}
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
